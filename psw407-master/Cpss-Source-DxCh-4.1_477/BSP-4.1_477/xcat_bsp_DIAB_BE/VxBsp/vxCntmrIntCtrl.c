/*******************************************************************************
*                Copyright 2004, MARVELL SEMICONDUCTOR, LTD.                   *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
*                                                                              *
* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
* (MJKK), MARVELL ISRAEL LTD. (MSIL).                                          *
*******************************************************************************/
/*******************************************************************************
* vxCntmrIntCtrl.c - Timer/Counter interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the Timer/Counter unit.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by a Timer/Counter.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the Timer/Counter unit.
*       NOTE:
*       Eventhough this driver supports connecting the timer completion event,
*       the user can connect to the timer completion bit using the Main
*       Interupt controller (vxIntConnect), thus saving the calling to this
*       driver handler. Note that the completion interrupt is acknowledged
*       in the timer cause register and not in the main cause register, so the
*       user ISR that is directly connected to main cause register must call
*       this driver interrupt clear routine vxCntmrIntClear () to acknowledge.
*
*       Overall Interrupt Architecture description:
*        The system controller handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated
*                 by each Internal controller unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This Timer/Counter Interrupt Controller Driver handles the
*        Timer/Counter interrupts generated by the first stage as each timer has
*        a termination bit in the main cause register.
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's
*           handlers to the main Interrupt controller. Composed
*           of vxCntmrIntCtrlInit()
*           routine.
*        2) User ISR connecting. Here information about user ISR and interrupt
*           priority is gathered. Composed of vxCntmrIntConnect() routine.
*        3) Interrupt handler. Here interrupts are being handle by the
*           Interrupt Handler. Composed of cntmrIntHandler(),
*
*       Full API:
*         vxCntmrIntCtrlInit() - Initiate the Couner/Timer interrupt controller
*         vxCntmrIntConnect()  - Connect a user ISR to Couner/Timer ternimation
*         vxCntmrIntEnable()   - Enable a given Couner/Timer termination event
*         vxCntmrIntDisable()  - Disable a given Couner/Timer termination event
*         cntmrIntHandler()    - Handles counter/timer termination event.
*
*       The controller concept is very simple:
*       The Interrupt handler is connected directly to the main interrupt
*       controller summary bit. An Interrupt generated by one of the counters
*       timers will result direct calling to user ISR connected to it in the
*       connection phase.
*
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts: vxCntmrIntDisable() and
*       vxCntmrIntEnable().
*
* DEPENDENCIES:
*       Main Interrupt Control Driver.
*       Counter/Timer module.
*       VxWorks types and interrupt lib.
*
*******************************************************************************/

/* includes */
#include "VxWorks.h"
#include "config.h"

#include "mvCntmr.h"
#include "vxCntmrIntCtrlInternal.h"
#include "vxCntmrIntCtrl.h"
#include "logLib.h"
#include "mvCpuIfRegs.h"

LOCAL int vxCntmrIntCtrlInitialized = 0;

#ifdef __cplusplus
extern "C" {
#endif

/*******************************************************************************
* vxCntmrIntCtrlInit - Initiating the Counter/Timer Interrupt Controller.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers to its
*       corresponding bits in the main Interrupt Controller using the
*       mvIntConnect() routine.
*       It is also cleans and masks interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxCntmrIntCtrlInit(void)
{
    if(vxCntmrIntCtrlInitialized)
       return;

#if defined (MV78XX0)
    MV_REG_WRITE(CNTMR_CAUSE_REG, 0);
    MV_REG_WRITE(CNTMR_MASK_REG, 0);
#elif   defined (MV88F6183) || defined (MV88F6XXX)
    MV_REG_WRITE(CPU_AHB_MBUS_CAUSE_INT_REG, 0);    /* Clean Cause register */
    MV_REG_WRITE(CPU_AHB_MBUS_MASK_INT_REG, 0);     /* Clean Mask register  */
#endif

    vxCntmrIntCtrlInitialized = 1;
}

/*******************************************************************************
* vxCntmrIntEnable - Enable an Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified Counter/Timer termination event in
*       Counter/Timer mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cntmrNum - Counter/Timer number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
#ifdef MV_SYS_TIMER_THROUGH_GPIO
extern MV_VOID fiq_entry(MV_VOID);
extern MV_VOID fiq_handler(MV_VOID);
MV_VOID mvFiqAckGpioInt35(MV_VOID);
void bridgeIntFiq(void);
STATUS sysToMonitor (int startType);
STATUS vxGppIntConnect(int cause, int group, VOIDFUNCPTR routine, int parameter, int prio);
void sysClkIntGpio(void);
MV_VOID mvPrepareGpioForIntEmulation(MV_VOID);

MV_VOID mvSwitchToFiqIsrGpio(MV_VOID)
{
    mvPrepareGpioForIntEmulation();

    *(MV_U32 *)0x38 = (MV_U32)fiq_entry;
    *(MV_U32 *)fiq_handler = (MV_U32)mvFiqAckGpioInt35;

    MV_REG_BIT_RESET(CPU_MAIN_IRQ_MASK_HIGH_REG, 0x80);
    MV_REG_BIT_SET  (CPU_MAIN_FIQ_MASK_HIGH_REG, 0x80);
}

MV_VOID mvEmulateGpioInt(MV_U32 gpioNum)
{
    /*
     * Emulate sysTimer interrupt through GPIO
     * (currently GPIO_35 only is supported).
     */
    MV_REG_BIT_SET(0x10140, BIT3);
}

MV_VOID mvFiqAckGpioInt(MV_U32 gpioNum)
{
    /*
     * Acknowledge GPIO interrupt (currently GPIO_35 only is supported).
     */
    MV_REG_BIT_RESET(0x10140, BIT3);
}

MV_VOID mvFiqAckGpioInt35(MV_VOID)
{
    /* Emulate sysTimer interrupt through GPIO_35. */
    MV_REG_BIT_RESET(0x10140, BIT3);
}

MV_VOID mvFiqGppIntConnect(MV_U32 gpioNum)
{
    int gppNo, group;
    STATUS status = ERROR;

    gppNo = gpioNum % 32;
    group = gpioNum / 32;

    status = vxGppIntConnect(gppNo, group, (VOIDFUNCPTR)sysClkIntGpio, 0, 0);
    if (status != OK)
    {
        mvOsPrintf("%s: vxGppIntConnect failed.\n", __func__);
    }
}

MV_VOID mvSwitchTimerToFiqIsr(MV_VOID)
{
    mvPrepareGpioForIntEmulation();

    mvFiqGppIntConnect(MV_SYS_TIMER_THROUGH_GPIO_NUM);

    *(MV_U32 *)0x38 = (MV_U32)fiq_entry;
    *(MV_U32 *)fiq_handler = (MV_U32)bridgeIntFiq;

    MV_REG_BIT_RESET(CPU_MAIN_IRQ_MASK_REG, CNTMR_MASK_CAUSE_TC(0));
    MV_REG_BIT_SET  (CPU_MAIN_FIQ_MASK_REG, CNTMR_MASK_CAUSE_TC(0));
}

MV_VOID mvSwitchTimerToIrqIsr(MV_VOID)
{
    MV_REG_BIT_RESET(CPU_MAIN_FIQ_MASK_REG, CNTMR_MASK_CAUSE_TC(0));
    MV_REG_BIT_SET  (CPU_MAIN_IRQ_MASK_REG, CNTMR_MASK_CAUSE_TC(0));
}
#endif

STATUS vxCntmrIntEnable(MV_U32 cntmrNum)
{
    /* MV_U32 tmp = excVecGet((FUNCPTR *)0x1C); */

    if (INVALID_CNTMR(cntmrNum))
    {
        logMsg("\nvxCntmrIntEnable: Invalid counter %d\n", cntmrNum,0,0,0,0,0);
        return ERROR;
    }

    /* Set mask bit to enable interrupt  */
#if defined (MV78XX0)
    MV_REG_BIT_SET(CPU_AHB_MBUS_MASK_INT_REG(whoAmI()), CNTMR_MASK_TC(cntmrNum));
    MV_REG_BIT_SET(CPU_MAIN_IRQ_MASK_REG, CNTMR_MASK_CAUSE_TC(cntmrNum));
#elif defined (MV88F6XXX) || defined (MV88F6183)
    MV_REG_BIT_SET(CPU_AHB_MBUS_MASK_INT_REG, CNTMR_MASK_TC(cntmrNum));
    MV_REG_BIT_SET(CPU_MAIN_IRQ_MASK_REG, CNTMR_MASK_CAUSE_TC(cntmrNum));
#endif

    return OK;
}

/*******************************************************************************
* vxCntmrIntDisable - Disable an Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine masks a specified Counter/Timer termination event in
*       Counter/Timer mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cntmrNum - Counter/Timer number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxCntmrIntDisable(MV_U32 cntmrNum)
{
    if (INVALID_CNTMR(cntmrNum))
    {
        logMsg("\nvxCntmrIntDisable: Invalid counter %d\n", cntmrNum,0,0,0,0,0);
        return ERROR;
    }

    /* Reset mask bit to disable interrupt */
#if defined (MV78XX0)
    MV_REG_BIT_RESET(CPU_AHB_MBUS_MASK_INT_REG(whoAmI()), CNTMR_MASK_TC(cntmrNum));
#elif defined (MV88F6XXX) || defined (MV88F6183)
    MV_REG_BIT_RESET(CPU_AHB_MBUS_MASK_INT_REG, CNTMR_MASK_TC(cntmrNum));
#endif
    return OK;
}
/*******************************************************************************
* vxCntmrIntClear - Clear an Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine clears a specified Counter/Timer termination event in
*       Counter/Timer cause register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cntmrNum - Counter/Timer number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxCntmrIntClear(MV_U32 cntmrNum)
{
    if (INVALID_CNTMR(cntmrNum))
    {
        logMsg("\nvxCntmrIntClear: Invalid counter %d\n", cntmrNum,0,0,0,0,0);
        return ERROR;
    }
    /* Reset cause bit to acknowledge interrupt */
#if defined (MV78XX0)
    MV_REG_WRITE(CNTMR_CAUSE_REG, ~CNTMR_MASK_TC(cntmrNum));
#elif defined (MV88F6XXX) || defined (MV88F6183)
    MV_REG_WRITE(CPU_AHB_MBUS_CAUSE_INT_REG, ~CNTMR_MASK_TC(cntmrNum));
#endif
    return OK;
}

#ifdef __cplusplus
}
#endif

