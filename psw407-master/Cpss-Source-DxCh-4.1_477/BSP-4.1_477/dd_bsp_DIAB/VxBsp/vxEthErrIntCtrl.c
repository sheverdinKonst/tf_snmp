/*******************************************************************************
*                Copyright 2004, MARVELL SEMICONDUCTOR, LTD.                   *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
*                                                                              *
* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
* (MJKK), MARVELL ISRAEL LTD. (MSIL).                                          *
*******************************************************************************/
/*******************************************************************************
* vxEthErrIntCtrl.c - Ethernet unit Error interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the ethernet unit errors.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific error events caused by the Eth unit.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the ethernet unit error events.
*       
*       Overall Interrupt Architecture description:
*        The system controller handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated
*                 by each Internal controller unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This Interrupt Controller Driver handles the various interrupts
*        generated by the second stage.
*
*       All Ethernet unit various error interrupt causes are numbered using the 
*       ETH_ERR_CAUSE enumerator. 
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's
*           handlers to the main Interrupt controller. Composed 
*           of vxEthErrIntCtrlInit() routine.
*        2) User ISR connecting. Here information about user ISR and interrupt
*           priority is gathered. Composed of vxEthErrIntConnect() routine.
*        3) Interrupt handler. Here interrupts are being handle by the
*           Interrupt Handler. Composed of pciIntHandler(),
*
*       Full API:
*         vxEthErrIntCtrlInit() - Initiate the Eth interrupt controller driver.
*         vxEthErrIntConnect()  - Connect a user ISR to a Eth error event.
*         vxEthErrIntEnable()   - Enable a given Eth error interrupt cause.
*         vxEthErrIntDisable()  - Disable a given Eth error interrupt cause.
*         ethIntErrHandler()    - Handles Eth errors user hooked ISR.
*
*       The controller concept is very simple:
*       The Interrupt handler has a table which holds information on
*       the connected user ISR. An error interrupt generated by the Eth
*       will result a search through this table in order to allocate
*       the generating interrupt cause.
*       After the initiating interrupt cause is identify, the ISR reside in
*       the same table entry is executed.
*
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts: vxEthErrIntDisable() and
*       vxEthErrIntEnable().
*
*       NOTE:
*       This driver connects defauilt error handler to Eth unit errors. 
*		This handler merely display error message. In case the user would like 
*		to change the system respond to those error events, connecting a new
*		ISR, using vxEthErrIntConnect(), will override the default
*		driver handler.
*
* DEPENDENCIES:
*       Main Interrupt Control Driver.
*       Ethernet unit module.
*       VxWorks types and interrupt lib.
*
*******************************************************************************/

/* includes */
#include "VxWorks.h"
#include "config.h"

#include "mvEth.h"
#include "vxEthErrIntCtrl.h"
#include "logLib.h"

#ifdef __cplusplus
extern "C" {
#endif

/* defines  */
#define ETH_INVALID_CAUSE(cause)    \
            ((cause) <= ETH_ERR_CAUSE_START || ETH_ERR_CAUSE_END <= (cause))

/* typedefs */


/* locals   */
LOCAL MV_ISR_ENTRY ethErrCauseArray[ETH_ERR_CAUSE_END];  
LOCAL int  ethErrCauseCount = 0;    /* Accumulates the number of connection */
LOCAL void ethErrShow(UINT32 causeBit, int port);

/*******************************************************************************
* vxEthErrIntCtrlInit - Initiating the Eth error Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the driver's interrupt handler to its
*       corresponding bits in the main Interrupt Controller using the
*       mvIntConnect() routine.	It also connect its internal error handler to 
*		Ethernet unit error interrupt cause using vxEthErrIntConnect().
*       It is also cleans and masks interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxEthErrIntCtrlInit(void)
{
    MV_U32 dummy;
#if !defined(DISCO_DUO_FPGA) 
	int port;
#endif
	
#if defined(DISCO_DUO_FPGA) 
	MV_REG_WRITE(ETH_UNIT_INTERRUPT_CAUSE_REG, 0);  /* Clean Cause register */
	MV_REG_WRITE(ETH_UNIT_INTERRUPT_MASK_REG, 0);   /* Clean Mask register  */
    /* Clear any previous latched error by reading registers */
    dummy   = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG);
    dummy   = MV_REG_READ(ETH_UNIT_INTERNAL_ADDR_ERROR_REG);

	/* Connect the default error handles that only prints a massage */
	vxEthErrIntConnect(ETH_PARITY_ERR,     ethErrShow, ETH_PARITY_ERR,     5);
	vxEthErrIntConnect(ETH_ADDR_VIOLATION, ethErrShow, ETH_ADDR_VIOLATION, 5);
	vxEthErrIntConnect(ETH_ADDR_NO_MATCH,  ethErrShow, ETH_ADDR_NO_MATCH,  5);
	vxEthErrIntConnect(ETH_INTER_ADDR_ERR, ethErrShow, ETH_INTER_ADDR_ERR, 5);
	vxEthErrIntConnect(ETH_PORT0_DP_ERR,   ethErrShow, ETH_PORT0_DP_ERR,   5);
	vxEthErrIntConnect(ETH_PORT1_DP_ERR,   ethErrShow, ETH_PORT1_DP_ERR,   5);
	vxEthErrIntConnect(ETH_PORT2_DP_ERR,   ethErrShow, ETH_PORT2_DP_ERR,   5);
	vxEthErrIntConnect(ETH_TOP_DP_ERR,     ethErrShow, ETH_TOP_DP_ERR,     5);

	/* Enable those interrupts */
	vxEthErrIntEnable(0,ETH_PARITY_ERR);
	vxEthErrIntEnable(0,ETH_ADDR_VIOLATION);
	vxEthErrIntEnable(0,ETH_ADDR_NO_MATCH);
	vxEthErrIntEnable(0,ETH_INTER_ADDR_ERR);
	vxEthErrIntEnable(0,ETH_PORT0_DP_ERR);
	vxEthErrIntEnable(0,ETH_PORT1_DP_ERR);
	vxEthErrIntEnable(0,ETH_PORT2_DP_ERR);
	vxEthErrIntEnable(0,ETH_TOP_DP_ERR);
#else
	for (port=0; port<MV_ETH_MAX_PORTS; port++)
	{
		MV_REG_WRITE(ETH_UNIT_INTR_CAUSE_REG(port), 0);	 /* Clean Cause register */
		MV_REG_WRITE(ETH_UNIT_INTR_MASK_REG(port), 0);	 /* Clean Mask register  */
		/* Clear any previous latched error by reading registers */
		dummy   = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(port));
		dummy   = MV_REG_READ(ETH_UNIT_INT_ADDR_ERROR_REG(port));
	}   

	/* Connect the default error handles that only prints a massage */
	vxEthErrIntConnect(ETH_PARITY_ERR,     ethErrShow, ETH_PARITY_ERR,     5);
	vxEthErrIntConnect(ETH_ADDR_VIOLATION, ethErrShow, ETH_ADDR_VIOLATION, 5);
	vxEthErrIntConnect(ETH_ADDR_NO_MATCH,  ethErrShow, ETH_ADDR_NO_MATCH,  5);
	vxEthErrIntConnect(ETH_INTER_ADDR_ERR, ethErrShow, ETH_INTER_ADDR_ERR, 5);
	vxEthErrIntConnect(ETH_PORT0_DP_ERR,   ethErrShow, ETH_PORT0_DP_ERR,   5);
	vxEthErrIntConnect(ETH_PORT1_DP_ERR,   ethErrShow, ETH_PORT1_DP_ERR,   5);
	vxEthErrIntConnect(ETH_PORT2_DP_ERR,   ethErrShow, ETH_PORT2_DP_ERR,   5);
	vxEthErrIntConnect(ETH_TOP_DP_ERR,     ethErrShow, ETH_TOP_DP_ERR,     5);

	for (port=0; port<MV_ETH_MAX_PORTS; port++)
	{
		/* Enable those interrupts */
		vxEthErrIntEnable(port,ETH_PARITY_ERR);
		vxEthErrIntEnable(port,ETH_ADDR_VIOLATION);
		vxEthErrIntEnable(port,ETH_ADDR_NO_MATCH);
		vxEthErrIntEnable(port,ETH_INTER_ADDR_ERR);
		vxEthErrIntEnable(port,ETH_PORT0_DP_ERR);
		vxEthErrIntEnable(port,ETH_PORT1_DP_ERR);
		vxEthErrIntEnable(port,ETH_PORT2_DP_ERR);
		vxEthErrIntEnable(port,ETH_TOP_DP_ERR);
	}
#endif    
}

/*******************************************************************************
* vxEthErrIntConnect - connect a C routine to a specific Eth error interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified Eth error
*       interrupt cause.
*       The ISR handler has its own user ISR array.
*       The connection is done by setting the desired routine and parameter in
*       the cause array (ethErrCauseArray[]):
*         1) Check for existing connection for the cause bit in the table.
*         2) Connecting the user ISR by inserting the given parameters into
*           an entry according to the user ISR given priority.
*
* INPUT:
*       cause     - Eth error interrupt cause. See ETH_ERR_CAUSE.
*       routine   - user ISR.
*       parameter - user ISR parameter.
*       prio      - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - if the table entry of the cause bit, was filled.
*       ERROR - if cause argument is invalid or connected cause is already
*                found in table.
*
*******************************************************************************/
STATUS vxEthErrIntConnect(ETH_ERR_CAUSE cause, VOIDFUNCPTR routine, 
                         int parameter, int prio)
{
    int i, sysIntOldConfig;

    /* Make sure that this is an atomic operation */
    sysIntOldConfig = intLock();

    /* Check the validity of the parameters */
    if(routine == NULL)
    {
        logMsg("\nvxEthErrIntConnect: NULL pointer routine\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        logMsg("\nvxEthErrIntConnect: Invalid interrupt priority\n",0,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(ETH_INVALID_CAUSE(cause))
    {
        logMsg("\nvxEthErrIntConnect: Invalid cause %d\n",cause,0,0,0,0,0);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }

    /* Scan the table to check for reconnection to the same cause bit */
    for(i = ethErrCauseCount; i >= 0; i--)
        if(ethErrCauseArray[i].causeBit == MV_BIT_MASK(cause))
        {
            ethErrCauseArray[i].userISR  = ethErrCauseArray[i-1].userISR;
            ethErrCauseArray[i].arg1     = ethErrCauseArray[i-1].arg1;
            intUnlock(sysIntOldConfig);
            return OK;
        }
    
    /* Connection phase */
    for(i = ethErrCauseCount; i >= 0; i--)
    {
        if(i == 0 || ethErrCauseArray[i-1].prio < prio) 
        {
            /* Make connection */
            ethErrCauseArray[i].causeBit = MV_BIT_MASK(cause);
            ethErrCauseArray[i].userISR  = routine;
            ethErrCauseArray[i].arg1     = parameter;
            ethErrCauseArray[i].prio     = prio;
            (ethErrCauseCount)++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            ethErrCauseArray[i].causeBit = ethErrCauseArray[i-1].causeBit;
            ethErrCauseArray[i].userISR  = ethErrCauseArray[i-1].userISR;
            ethErrCauseArray[i].arg1     = ethErrCauseArray[i-1].arg1;
            ethErrCauseArray[i].prio     = ethErrCauseArray[i-1].prio;
        }
    }

    intUnlock(sysIntOldConfig);
    return OK;
}

/*******************************************************************************
* vxEthErrIntEnable - Enable an Eth error interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified Eth error cause in the mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       port     - Eth port number.
*       cause    - Eth error interrupt cause as defined in PCI_ERR_CAUSE.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxEthErrIntEnable(int port, ETH_ERR_CAUSE cause)
{
    if (ETH_INVALID_CAUSE(cause))
    {
        logMsg("\nvxEthErrIntEnable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    /* Set mask bit to enable interrupt */
#if defined(DISCO_DUO_FPGA) 
	MV_REG_BIT_SET(ETH_UNIT_INTERRUPT_MASK_REG, MV_BIT_MASK(cause));
#else
	MV_REG_BIT_SET(ETH_UNIT_INTR_MASK_REG(port), MV_BIT_MASK(cause));
#endif
    
    return OK;
}

/*******************************************************************************
* vxEthErrIntDisable - Disable a Eth error interrupt
*
* DESCRIPTION:
*       This routine masks a specified Eth error cause in the mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cause    - Eth error interrupt cause as defined in ETH_ERR_CAUSE.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxEthErrIntDisable(int port, ETH_ERR_CAUSE cause)
{
    if (ETH_INVALID_CAUSE(cause))
    {
        logMsg("\vxEthErrIntDisable: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    /* Set mask bit to enable interrupt */
#if defined(DISCO_DUO_FPGA) 
	MV_REG_BIT_RESET(ETH_UNIT_INTERRUPT_MASK_REG, MV_BIT_MASK(cause));
#else
	MV_REG_BIT_RESET(ETH_UNIT_INTR_MASK_REG(port), MV_BIT_MASK(cause));
#endif

    return OK;
}

/*******************************************************************************
* vxEthErrIntClear - Clear a Eth error interrupt
*
* DESCRIPTION:
*       This routine clears a specified Eth interrupt in the cause register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cause - Eth error interrupt cause as defined in ETH_ERR_CAUSE.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxEthErrIntClear(int port, ETH_ERR_CAUSE cause)
{
    if (ETH_INVALID_CAUSE(cause))
    {
        logMsg("\nvxEthErrIntClear: Invalid cause %d\n", cause,0,0,0,0,0);
        return ERROR;
    }

    /* Reset mask bit to disable interrupt */
#if defined(DISCO_DUO_FPGA) 
	MV_REG_WRITE(ETH_UNIT_INTERRUPT_CAUSE_REG, ~(MV_BIT_MASK(cause)));
#else
	MV_REG_WRITE(ETH_UNIT_INTR_CAUSE_REG(port), ~(MV_BIT_MASK(cause)));
#endif

    return OK;
}

/*******************************************************************************
* ethErrIntHandler - Eth Error interrupt handler.
*
* DESCRIPTION:
*       This routine handles the Ethernet unit error interrupts.
*       As soon as the interrupt signal is active the CPU analyzes the Eth 
*       unit Interrupt Cause register (according to Eth interface number)
*       in order to locate the originating interrupt event.
*       Then the routine calls the user specified service routine for that
*       interrupt cause.
*       The function scans the ethErrCauseArray[] (ethErrCauseCount 
*       valid entries) trying to find a hit in the ethErrCauseArray 
*       cause table. When found, the ISR in the same entry is executed.
*		Note: The handler automatically acknowledges the generating interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void ethErrIntHandler (void)
{
    int i;
    UINT32 activeErr, dummy;
#if !defined(DISCO_DUO_FPGA) 
	int port;
#endif


    /* Extract the pending error interrupts (in LE). 	*/
#if defined(DISCO_DUO_FPGA) 
    activeErr = (MV_REG_READ(ETH_UNIT_INTERRUPT_CAUSE_REG) & 
                 MV_REG_READ(ETH_UNIT_INTERRUPT_MASK_REG));

    /* Acknowledge pending interrupts to allow next interrupts to register  */
    MV_REG_WRITE(ETH_UNIT_INTERRUPT_CAUSE_REG, ~(activeErr));

    /* Execute user ISR if connected */
    for(i = 0; i < ethErrCauseCount; i++)
        if(activeErr & ethErrCauseArray[i].causeBit)
            (*ethErrCauseArray[i].userISR) (ethErrCauseArray[i].arg1,0);                        
    
    /* Upon address latched, no new address can be registered (due to       */
    /* another error) until the Address registers are read.         		*/
    /* We perform dummy read to make sure next error registrate properly.   */
	dummy = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG);
	dummy = MV_REG_READ(ETH_UNIT_INTERNAL_ADDR_ERROR_REG);
#else

	for (port=0; port<MV_ETH_MAX_PORTS; port++)
	{

		activeErr = (MV_REG_READ(ETH_UNIT_INTR_CAUSE_REG(port)) & 
					 MV_REG_READ(ETH_UNIT_INTR_MASK_REG(port)));

		/* Acknowledge pending interrupts to allow next interrupts to register  */
		MV_REG_WRITE(ETH_UNIT_INTR_CAUSE_REG(port), ~(activeErr));

		/* Execute user ISR if connected */
		for(i = 0; i < ethErrCauseCount; i++)
			if(activeErr & ethErrCauseArray[i].causeBit)
				(*ethErrCauseArray[i].userISR) (ethErrCauseArray[i].arg1,port);                        

		/* Upon address latched, no new address can be registered (due to       */
		/* another error) until the Address registers are read.         		*/
		/* We perform dummy read to make sure next error registrate properly.   */
		dummy = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(port));
		dummy = MV_REG_READ(ETH_UNIT_INT_ADDR_ERROR_REG(port));
	}
#endif
    return;
}
    
/*******************************************************************************
* ethErrShow - Show error information.
*
* DESCRIPTION:
*       This routine show Eth error information according to error report
*		registers.
*
* INPUT:
*       causeBit - cause bit that invoked the handled interrupt.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
LOCAL void ethErrShow(UINT32 causeBit, int port)
{
    UINT32 errAddr;
    
	logMsg("Eth unit Error on port %d \n",port,0,0,0,0,0);

    switch(causeBit)
    {
        case(ETH_PARITY_ERR):
            logMsg("Parity Error on Port %d\n", port,0,0,0,0,0);
            break;
        case(ETH_ADDR_VIOLATION):
#if defined(DISCO_DUO_FPGA) 
            errAddr = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG);
#else
            errAddr = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(port));
#endif
			logMsg("Address Violation at 0x%x on Port %d\n",errAddr,port,0,0,0,0);
            break;
        case(ETH_ADDR_NO_MATCH):
#if defined(DISCO_DUO_FPGA) 
            errAddr = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG);
#else
            errAddr = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(port));
#endif
			logMsg("Address No Match at 0x%x on Port %d\n",errAddr,port,0,0,0,0);
            break;
        case(ETH_INTER_ADDR_ERR):
#if defined(DISCO_DUO_FPGA) 
            errAddr = MV_REG_READ(ETH_UNIT_INTERNAL_ADDR_ERROR_REG);
#else
            errAddr = MV_REG_READ(ETH_UNIT_INT_ADDR_ERROR_REG(port));
#endif
            logMsg("An access to an illegal offset of the internal registers on Port %d\n",
																  port,0,0,0,0,0);
			logMsg("Internal Address Error register: 0x%x on Port %d\n",errAddr,port,0,0,0,0);
            break;
        case(ETH_PORT0_DP_ERR):
            logMsg("Port 0 Internal data path parity error on Port %d\n", port,0,0,0,0,0);
            break;
        case(ETH_PORT1_DP_ERR):
            logMsg("Port 1 Internal data path parity error\n", 0,0,0,0,0,0);
            break;
        case(ETH_PORT2_DP_ERR):
            logMsg("Port 2 Internal data path parity error\n", 0,0,0,0,0,0);
            break;
        case(ETH_TOP_DP_ERR):
            logMsg("G TOP Internal data path parity error Port %d\n\n", port,0,0,0,0,0);
            break;
        default:
            logMsg("Eth unit unknown error\n", 0,0,0,0,0,0);
    }

    return;
}

#ifdef __cplusplus
}
#endif

