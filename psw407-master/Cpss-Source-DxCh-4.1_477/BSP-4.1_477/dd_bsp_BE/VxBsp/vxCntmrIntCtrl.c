/*******************************************************************************
*                Copyright 2004, MARVELL SEMICONDUCTOR, LTD.                   *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
*                                                                              *
* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
* (MJKK), MARVELL ISRAEL LTD. (MSIL).                                          *
*******************************************************************************/
/*******************************************************************************
* vxCntmrIntCtrl.c - Timer/Counter interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the Timer/Counter unit.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by a Timer/Counter.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the Timer/Counter unit.
*       NOTE:
*       Eventhough this driver supports connecting the timer completion event,
*       the user can connect to the timer completion bit using the Main
*       Interupt controller (vxIntConnect), thus saving the calling to this
*       driver handler. Note that the completion interrupt is acknowledged
*       in the timer cause register and not in the main cause register, so the
*       user ISR that is directly connected to main cause register must call 
*       this driver interrupt clear routine vxCntmrIntClear () to acknowledge.
*
*       Overall Interrupt Architecture description:
*        The system controller handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated
*                 by each Internal controller unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This Timer/Counter Interrupt Controller Driver handles the 
*        Timer/Counter interrupts generated by the first stage as each timer has 
*        a termination bit in the main cause register. 
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's
*           handlers to the main Interrupt controller. Composed 
*           of vxCntmrIntCtrlInit()
*           routine.
*        2) User ISR connecting. Here information about user ISR and interrupt
*           priority is gathered. Composed of vxCntmrIntConnect() routine.
*        3) Interrupt handler. Here interrupts are being handle by the
*           Interrupt Handler. Composed of cntmrIntHandler(),
*
*       Full API:
*         vxCntmrIntCtrlInit() - Initiate the Couner/Timer interrupt controller
*         vxCntmrIntConnect()  - Connect a user ISR to Couner/Timer ternimation
*         vxCntmrIntEnable()   - Enable a given Couner/Timer termination event
*         vxCntmrIntDisable()  - Disable a given Couner/Timer termination event
*         cntmrIntHandler()    - Handles counter/timer termination event.
*
*       The controller concept is very simple:
*       The Interrupt handler is connected directly to the main interrupt 
*       controller summary bit. An Interrupt generated by one of the counters
*       timers will result direct calling to user ISR connected to it in the 
*       connection phase.
*
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts: vxCntmrIntDisable() and
*       vxCntmrIntEnable().
*
* DEPENDENCIES:
*       Main Interrupt Control Driver.
*       Counter/Timer module.
*       VxWorks types and interrupt lib.
*
*******************************************************************************/

/* includes */
#include "VxWorks.h"
#include "config.h"

#include "mvCntmr.h"
#include "vxCntmrIntCtrl.h"
#include "logLib.h"
#include "mvCpuIfRegs.h"

#ifdef __cplusplus
extern "C" {
#endif

/* defines  */
#define INVALID_CNTMR(cntmrNum)    ((cntmrNum) >= MV_CNTMR_MAX_COUNTER)
/*
 * Timers bits
 */

#if defined(MV78XX0)
/* Timer/Counter Interrupt Mask register fields  (CNTMR_MASK_REG)*/
#define CNTMR_MASK_TC(counter)	    ((counter) < 2 ?(BIT1 << (counter)) : (BIT6 << (counter-2)))
#define CNTMR_MASK_CAUSE_TC(counter)   (BIT0 << (counter + INT_LVL_TIMER0))
#if defined (MV78100)
#define CPU_MAIN_IRQ_MASK_REG 		CPU_INT_MASK_LOW_REG(0)
#define CPU_MAIN_IRQ_MASK_HIGH_REG	CPU_INT_MASK_HIGH_REG(0)
#else
#define CPU_MAIN_IRQ_MASK_REG 		CPU_INT_MASK_LOW_REG(whoAmI())
#define CPU_MAIN_IRQ_MASK_HIGH_REG	CPU_INT_MASK_HIGH_REG(whoAmI())

#endif
#elif defined (MV88F6XXX) 
#define CNTMR_MASK_TC(counter)	    (BIT1 << (counter))
#define CNTMR_MASK_CAUSE_TC(counter)   (INT_LVL_BRIDGE)
#endif


/* typedefs */


/* locals   */
LOCAL int  vxCntmrIntCtrlInitialized = 0;

/*******************************************************************************
* vxCntmrIntCtrlInit - Initiating the Counter/Timer Interrupt Controller.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers to its
*       corresponding bits in the main Interrupt Controller using the
*       mvIntConnect() routine.
*       It is also cleans and masks interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxCntmrIntCtrlInit(void)
{
    if(vxCntmrIntCtrlInitialized)
       return;

	MV_REG_WRITE(CNTMR_CAUSE_REG, 0);    /* Clean Cause register */
	MV_REG_WRITE(CNTMR_MASK_REG, 0);     /* Clean Mask register  */

    vxCntmrIntCtrlInitialized = 1;
}

/*******************************************************************************
* vxCntmrIntEnable - Enable an Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified Counter/Timer termination event in 
*       Counter/Timer mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cntmrNum - Counter/Timer number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxCntmrIntEnable(MV_U32 cntmrNum)
{
    if (INVALID_CNTMR(cntmrNum))
    {
        logMsg("\nvxCntmrIntEnable: Invalid counter %d\n", cntmrNum,0,0,0,0,0);
        return ERROR;
    }

    /* Set mask bit to enable interrupt  */
	MV_REG_BIT_SET(CPU_AHB_MBUS_MASK_INT_REG(0), CNTMR_MASK_TC(cntmrNum));
	MV_REG_BIT_SET(CPU_MAIN_IRQ_MASK_REG, CNTMR_MASK_CAUSE_TC(cntmrNum));

    
    return OK;
}

/*******************************************************************************
* vxCntmrIntDisable - Disable an Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine masks a specified Counter/Timer termination event in 
*       Counter/Timer mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cntmrNum - Counter/Timer number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxCntmrIntDisable(MV_U32 cntmrNum)
{
    if (INVALID_CNTMR(cntmrNum))
    {
        logMsg("\nvxCntmrIntDisable: Invalid counter %d\n", cntmrNum,0,0,0,0,0);
        return ERROR;
    }

    /* Reset mask bit to disable interrupt */
	MV_REG_BIT_RESET(CPU_AHB_MBUS_MASK_INT_REG(0) , CNTMR_MASK_TC(cntmrNum));

    return OK;
}
/*******************************************************************************
* vxCntmrIntClear - Clear an Counter/Timer interrupt
*
* DESCRIPTION:
*       This routine clears a specified Counter/Timer termination event in 
*       Counter/Timer cause register.
*       The routine will preform argument validity check.
*
* INPUT:
*       cntmrNum - Counter/Timer number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxCntmrIntClear(MV_U32 cntmrNum)
{
    if (INVALID_CNTMR(cntmrNum))
    {
        logMsg("\nvxCntmrIntClear: Invalid counter %d\n", cntmrNum,0,0,0,0,0);
        return ERROR;
    }
    /* Reset cause bit to acknowledge interrupt */
	MV_REG_WRITE(CNTMR_CAUSE_REG, ~CNTMR_MASK_TC(cntmrNum));
    return OK;
}

#ifdef __cplusplus
}
#endif

