/*******************************************************************************
*                Copyright 2004, MARVELL SEMICONDUCTOR, LTD.                   *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
*                                                                              *
* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
* (MJKK), MARVELL ISRAEL LTD. (MSIL).                                          *
*******************************************************************************/
/*******************************************************************************
* vxIdmaIntCtrl.c - IDMA interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts concerning the IDMA unit.
*
*       Main features:
*        - The controller provides an easy way to hook a C Interrupt Service
*          Routine (ISR) to a specific interrupt caused by the IDMA channels.
*        - The controller interrupt mechanism provides a way for the programmer
*          to set the priority of an interrupt.
*        - Full interrupt control over the IDMA facility.
*       NOTE:
*       Eventhough this driver supports connecting the IDMA completion event, 
*       the user can connect to the IDMA completion bit using the Main 
*       Interupt controller (VxIntConnect), thus saving the calling to this 
*       driver handler. Note that the completion interrupt is acknowledged 
*       in the IDMA cause register and not in the main cause register, so the 
*       user ISR must use this driver interrupt clear routine vxIdmaIntClear ()
*       
*       Overall Interrupt Architecture description:
*        The system controller handles interrupts in two stages:
*        STAGE 1: Main Cause register that summarize the interrupts generated
*                 by each Internal controller unit.
*        STAGE 2: Unit specified cause registers, that distinguish between each
*                 specific interrupt event.
*        This IDMA Interrupt Controller Driver handles the various interrupts
*        generated by the second stage.
*
*       All IDMA various error interrupt causes are numbered using the 
*       IDMA_ERR_CAUSE enumerator. 
*
*       The driver's execution flow has three phases:
*        1) Driver initialization. This initiation includes hooking driver's
*           handlers to the main Interrupt controller. Composed 
*           of vxIdmaIntCtrlInit()
*           routine.
*        2) User ISR connecting. Here information about user ISR and interrupt
*           priority is gathered. Composed of vxIdmaIntConnect() routine.
*        3) Interrupt handler. Here interrupts are being handle by the
*           Interrupt Handler. Composed of idmaIntHandler(),
*
*       Full API:
*         vxIdmaIntCtrlInit() - Initiate the IDMA interrupt controller driver.
*         vxIdmaIntConnect()  - Connect a user ISR to an IDMA interrupt event.
*         vxIdmaIntEnable()   - Enable a given IDMA interrupt cause.
*         vxIdmaIntDisable()  - Disable a given IDMA interrupt cause.
*         idmaErrHandler()    - Handles IDMA interrupts according to user ISR.
*
*       The controller concept is very simple:
*       The Interrupt handler has a table which holds information on
*       the connected user ISR. An Interrupt generated by one of the IDMA
*       channels will result a search through this table in order to allocate
*       the generating interrupt cause.
*       After the initiating interrupt cause is identify, the ISR reside in
*       the same table entry is executed.
*
*       The controller interface also includes interrupt control routines which
*       can enable/disable specific interrupts: vxIdmaIntDisable() and
*       vxIdmaIntEnable().
*
* DEPENDENCIES:
*       Main Interrupt Control Driver.
*       IDMA module.
*       VxWorks types and interrupt lib.
*
*******************************************************************************/

/* includes */
#include "VxWorks.h"
#include "config.h"

#include "mvIdma.h"
#include "vxIdmaIntCtrl.h"
#include "mvCtrlEnvLib.h"
#include "logLib.h"

#ifdef __cplusplus
extern "C" {
#endif

/* defines  */
#define IDMA_INVALID_CAUSE(cause)    \
            ((cause) <= IDMA_ERR_CAUSE_START || IDMA_ERR_CAUSE_END <= (cause))

/* typedefs */


/* locals   */
LOCAL MV_ISR_ENTRY idmaErrCauseArray[32]; 
LOCAL int  idmaErrCauseCount = 0;    /* Accumulates the number of connection */
LOCAL int  vxIdmaIntCtrlInitialized = 0;
LOCAL void idmaErrShow(UINT32 chan, UINT32 causeBit);
LOCAL void idmaErrSelShow(UINT32 chan, UINT32 causeBit);
/*******************************************************************************
* vxIdmaIntCtrlInit - Initiating the IDMA Interrupt Controller driver.
*
* DESCRIPTION:
*       This routines connects the drivers interrupt handlers to its
*       corresponding bits in the main Interrupt Controller using the
*       mvIntConnect() routine.
*       It is also cleans and masks interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxIdmaIntCtrlInit(void)
{
	int chan;
	MV_U32 dummy;

	MV_REG_WRITE(IDMA_CAUSE_REG, 0);    /* Clean Cause register */
	MV_REG_WRITE(IDMA_MASK_REG, 0);     /* Clean Mask register  */

    /* Clear any previous latched error by reading error address 	        */
    dummy = MV_REG_READ(IDMA_ERROR_ADDR_REG);

    if(vxIdmaIntCtrlInitialized)
       return;

	for (chan = 0; chan < mvCtrlIdmaMaxChanGet(); chan++)
	{
        /* Connect the default error handles that only prints a massage */
        vxIdmaIntConnect(chan,IDMA_ADDRMISS,idmaErrSelShow,chan,IDMA_ADDRMISS,5);
        vxIdmaIntConnect(chan,IDMA_ACCPROT, idmaErrSelShow,chan,IDMA_ACCPROT, 5);
        vxIdmaIntConnect(chan,IDMA_WRPROT,  idmaErrSelShow,chan,IDMA_WRPROT,  5);
        vxIdmaIntConnect(chan,IDMA_DPERR,   idmaErrShow,   chan,IDMA_DPERR,   5);

        vxIdmaIntEnable(chan, IDMA_ADDRMISS);
        vxIdmaIntEnable(chan, IDMA_ACCPROT);
        vxIdmaIntEnable(chan, IDMA_WRPROT);
        vxIdmaIntEnable(chan, IDMA_DPERR);

	}

    vxIdmaIntCtrlInitialized = 1;
}

/*******************************************************************************
* vxIdmaIntConnect - connect a C routine to a specific IDMA interrupt.
*
* DESCRIPTION:
*       This routine connects a specified user ISR to a specified IDMA
*       interrupt cause.
*       The ISR handler has its own user ISR array.
*       The connection is done by setting the desired routine and parameter in
*       the cause array (idmaErrCauseArray[]):
*         1) Check for existing connection for the cause bit in the table.
*         2) Connecting the user ISR by inserting the given parameters into
*           an entry according to the user ISR given priority.
*
* INPUT:
*       chan    - IDMA Channel number.
*       cause   - IDMA interrupt cause. See IDMA_ERR_CAUSE.
*       routine - user ISR.
*       arg1    - user ISR argument1.
*       arg2    - user ISR argument2.
*       prio    - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - if the table entry of the cause bit, was filled.
*       ERROR - if cause argument is invalid or connected cause is already
*                found in table.
*
*******************************************************************************/
STATUS vxIdmaIntConnect(MV_U32 chan, IDMA_ERR_CAUSE cause,
                        VOIDFUNCPTR routine, int arg1, int arg2, int prio)
{
    int i, sysIntOldConfig, causeBitMask;

    /* Make sure that this is an atomic operation */
    sysIntOldConfig = intLock();

    /* Check the validity of the parameters */
    if(routine == NULL)
    {
        printf("\nvxIdmaIntConnect: NULL pointer routine\n");
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(prio < 0)
    {
        printf("\nvxIdmaIntConnect: Invalid interrupt priority\n");
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(IDMA_INVALID_CAUSE(cause))
    {
        printf("\nvxIdmaIntConnect: Invalid cause %d\n",cause);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }
    else if(chan >= mvCtrlIdmaMaxChanGet())
    {
        printf("\nvxIdmaIntConnect: Invalid chan %d\n",chan);
        intUnlock(sysIntOldConfig);
        return ERROR;
    }

    if (IDMA_COMP == cause)
    {
        printf("\nvxIdmaIntConnect: Use intConnect for DMA completion\n");
        return ERROR;
    }
    else
    {
        /* Calculate the cause bit location in the register according to chan */
        causeBitMask = ICICR_CAUSE_MASK(chan, cause);
        
        /* Scan the table to check for reconnection to the same cause bit */
        for(i = idmaErrCauseCount; i >= 0; i--)
            if(idmaErrCauseArray[i].causeBit == causeBitMask)
            {
                idmaErrCauseArray[i].userISR  = routine;
                idmaErrCauseArray[i].arg1     = arg1;
                idmaErrCauseArray[i].arg2     = arg2;
                intUnlock(sysIntOldConfig);
				return OK;
            }
        
        /* Connection phase */
        for(i = idmaErrCauseCount; i >= 0; i--)
        {
            if(i == 0 || idmaErrCauseArray[i-1].prio < prio) 
            {
                /* Make connection */
                idmaErrCauseArray[i].causeBit = causeBitMask;
                idmaErrCauseArray[i].userISR  = routine;
                idmaErrCauseArray[i].arg1     = arg1;
                idmaErrCauseArray[i].arg2     = arg2;
                idmaErrCauseArray[i].prio     = prio;
                idmaErrCauseCount++;
                break;
            }
            else
            {
                /* Push the low priority connection down the table */
                idmaErrCauseArray[i].causeBit = idmaErrCauseArray[i-1].causeBit;
                idmaErrCauseArray[i].userISR  = idmaErrCauseArray[i-1].userISR;
                idmaErrCauseArray[i].arg1     = idmaErrCauseArray[i-1].arg1;
                idmaErrCauseArray[i].arg2     = idmaErrCauseArray[i-1].arg2;
                idmaErrCauseArray[i].prio     = idmaErrCauseArray[i-1].prio;
            }
        }
    }

    intUnlock(sysIntOldConfig);
    return OK;
}

/*******************************************************************************
* vxIdmaIntEnable - Enable an IDMA interrupt
*
* DESCRIPTION:
*       This routine unmasks a specified IDMA cause in the mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       chan - IDMA channel number.
*       cause   - IDMA interrupt cause as defined in IDMA_ERR_CAUSE.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxIdmaIntEnable(MV_U32 chan, IDMA_ERR_CAUSE cause)
{
    if (IDMA_INVALID_CAUSE(cause))
    {
        printf("\nvxIdmaIntEnable: Invalid cause %d\n", cause);
        return ERROR;
    }
    else if(chan >= mvCtrlIdmaMaxChanGet())
    {
        printf("\nvxIdmaIntEnable: Invalid chan %d\n",chan);
        return ERROR;
    }

    /* Set mask bit to enable interrupt */
	MV_REG_BIT_SET(IDMA_MASK_REG, ICICR_CAUSE_MASK(chan,cause));
    
    return OK;
}

/*******************************************************************************
* vxIdmaIntDisable - Disable an IDMA interrupt
*
* DESCRIPTION:
*       This routine masks a specified IDMA interrupt in the mask register.
*       The routine will preform argument validity check.
*
* INPUT:
*       chan - IDMA channel number.
*       cause   - IDMA interrupt cause as defined in IDMA_ERR_CAUSE.
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxIdmaIntDisable(MV_U32 chan, IDMA_ERR_CAUSE cause)
{
    if (IDMA_INVALID_CAUSE(cause))
    {
        printf("\nvxIdmaIntDisable: Invalid cause %d\n", cause);
        return ERROR;
    }
    else if(chan >= mvCtrlIdmaMaxChanGet())
    {
        printf("\nvxIdmaIntDisable: Invalid chan %d\n",chan);
        return ERROR;
    }

    /* Reset mask bit to disable interrupt */
	MV_REG_BIT_RESET(IDMA_MASK_REG, ICICR_CAUSE_MASK(chan,cause));

    return OK;
}
/*******************************************************************************
* vxIdmaIntClear - Clear an IDMA interrupt
*
* DESCRIPTION:
*       This routine clears a specified IDMA interrupt in the cause register.
*       The routine will preform argument validity check.
*
* INPUT:
*       chan - IDMA channel number.
*       cause   - IDMA interrupt cause as defined in IDMA_ERR_CAUSE
*
* OUTPUT:
*       None.
*
* RETURN:
*       OK    - If the bit was set
*       ERROR - In case of invalid parameters.
*
*******************************************************************************/
STATUS vxIdmaIntClear(MV_U32 chan, IDMA_ERR_CAUSE cause)
{
    if (IDMA_INVALID_CAUSE(cause))
    {
        printf("\nvxIdmaIntClear: Invalid cause %d\n", cause);
        return ERROR;
    }
    else if(chan >= mvCtrlIdmaMaxChanGet())
    {
        printf("\nvxIdmaIntClear: Invalid chan %d\n",chan);
        return ERROR;
    }

    /* Reset mask bit to disable interrupt */
	MV_REG_WRITE(IDMA_CAUSE_REG, ~ICICR_CAUSE_MASK(chan, cause));

    return OK;
}

/*******************************************************************************
* idmaErrHandler - IDMA interrupt handler.
*
* DESCRIPTION:
*       This routine handles the IDMA interrupts.
*       As soon as the interrupt signal is active the CPU analyzes the IDMA
*       Interrupt Cause register in order to locate the originating
*       interrupt event.
*       Then the routine calls the user specified service routine for that
*       interrupt cause.
*       The function scans the idmaErrCauseArray[] (idmaErrCauseCount valid 
*		entries) trying to find a hit in the idmaErrCauseArray cause table.
*       When found, the ISR in the same entry is executed.
*		Note: The handler automatically acknowledges the generating interrupts.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void idmaErrHandler (void)
{
    int i;
    UINT32 activeErr, dummy;

    /* Extract the pending error interrupts. Exclude completion interrupts 	*/
	activeErr = MV_REG_READ(IDMA_MASK_REG)  & 
			    MV_REG_READ(IDMA_CAUSE_REG) & 
				ICICR_ERR_MASK;

     /* Execute user ISR if connected */
    for(i = 0; i < idmaErrCauseCount; i++)
        if(activeErr & idmaErrCauseArray[i].causeBit)
            (*idmaErrCauseArray[i].userISR) (idmaErrCauseArray[i].arg1,
                                             idmaErrCauseArray[i].arg2);
    
    /* If multiple errors occur, only the first error is latched.            */
    /* New error report latching is only enabled after the SRAM Error        */
    /* Address register Low is being read, and interrupt is cleared.         */
    dummy  = MV_REG_READ(IDMA_ERROR_ADDR_REG);

    /* Acknowledge pending interrupts to allow next interrupts to register  */
    /* Pay attention not to acknowledge completion bits						*/
    MV_REG_WRITE(IDMA_CAUSE_REG, ~(activeErr));


    return;
}

/*******************************************************************************
* idmaErrDisplay - Display select error information.
*
* DESCRIPTION:
*       This routine display IDMA select error information according to 
*       error report registers.
*
* INPUT:
*       chan     - Channel number.
*       causeBit - cause bit number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
LOCAL void idmaErrSelShow	(UINT32 chan, UINT32 causeBit)
{
    UINT32 errSelect;
    UINT32 errAddr;

    /* Extract the cause register and channel number */
    logMsg("IDMA error:\n",0,0,0,0,0,0);
    
    switch(causeBit)
    {
        case(IDMA_ADDRMISS):
            logMsg("Channel %d address miss error\n", chan,0,0,0,0,0);
            break;
        case(IDMA_ACCPROT):
            logMsg("Channel %d access protection violation\n", chan,0,0,0,0,0);
            break;
        case(IDMA_WRPROT):
            logMsg("Channel %d write protection violation\n", chan,0,0,0,0,0);
            break;
        case(IDMA_OWN):
            logMsg("Channel %d accessed CPU owned descriptor\n", 
				   chan,0,0,0,0,0);
            break;
        default:
            return;
    }

    /* Read the error type latched						*/
    errSelect = MV_REG_READ(IDMA_ERROR_SELECT_REG) & IESR_ERR_TYPE_MASK;
    
    /* Print error information if the data latched belongs to this cause */
    if (causeBit + (chan * ICICR_CHAN_OFFS) == errSelect)
    {
        errAddr = MV_REG_READ(IDMA_ERROR_ADDR_REG);
        logMsg("Error address 0x%08x\n", errAddr,0,0,0,0,0);
    }

}

/*******************************************************************************
* idmaErrShow - Display error information.
*
* DESCRIPTION:
*       This routine display IDMA error information according to cause
*		register for errors that does not latch error address/data.
*
* INPUT:
*       chan     - Channel number.
*       causeBit - cause bit number.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
* NOTE:
*       The user can add here messaging about End Of Transfer (EOT) interrupt. 
*******************************************************************************/
LOCAL void idmaErrShow(UINT32 chan, UINT32 causeBit)
{
    
    logMsg("IDMA error:\n",0,0,0,0,0,0);

    switch(causeBit)
    {
        case(IDMA_DPERR):
            logMsg("Aunit internal data path parity error detected\n",
				   0,0,0,0,0,0);
            break;
        case(IDMA_EOTINT):
        default:
            return;
    }
    return;
}

#ifdef __cplusplus
}
#endif
