/*******************************************************************************
*                Copyright 2004, MARVELL SEMICONDUCTOR, LTD.                   *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL.                      *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
*                                                                              *
* MARVELL COMPRISES MARVELL TECHNOLOGY GROUP LTD. (MTGL) AND ITS SUBSIDIARIES, *
* MARVELL INTERNATIONAL LTD. (MIL), MARVELL TECHNOLOGY, INC. (MTI), MARVELL    *
* SEMICONDUCTOR, INC. (MSI), MARVELL ASIA PTE LTD. (MAPL), MARVELL JAPAN K.K.  *
* (MJKK), MARVELL ISRAEL LTD. (MSIL).                                          *
*******************************************************************************/
/*******************************************************************************
* vxGppIntCtrl.c - GPP Interrupt controller library
*
* DESCRIPTION:
*       This driver provides various interface routines to manipulate and
*       connect the hardware interrupts described by the GPP facility
*       (i.e. PCI, UART, etc.).
*       Once a GPP pin is configued as input pin active low, it behaves as an
*       interrupt pin. When asserted, the interrupt reflects in the GPP cause
*       register generating interrupt event if not masked.
*
*       For example the RS232 channel A interrupt is connected to GPP pin 21
*       which means that when this pin is activate (low value) the GPP cause
*       register bit 21 will be set to signal an interrupt from this UART chnl.
*
*       Main features:
*       - The controller provides an easy way to hook a C Interrupt Service
*         Routine (ISR) to a specific interrupt caused by the MV GPP interrupt.
*       - This controller automatically acknowledges the interrupt as soon as
*         the user C Interrupt service Routine returns.
*       - The controller interrupt mechanism provides a way for the programmer
*         to set the priority of an interrupt.
*       - Full interrupt control over the MV GPP facility.
*
*       Overall Interrupt Architecture description:
*       The MV handles interrupts in two stages:
*       STAGE 1: Main Cause register that summarize the interrupts generated by
*		         each Internal MV unit.
*       STAGE 2: Unit specified cause registers, that distinguish between each
*                specific interrupt event.
*       This System Interrupt Controller Driver handles the various interrupts
*       generated by the GPP interrupt cause register.
*
*       The driver's execution flow has three phases:
*        1) Driver initialization.
*           This initiation includes hooking driver's ISR to
*           the MV Interrupt controller. Composed of vxGppIntCtrlInit() routine.
*        2) User ISR connecting. Here information about system ISR and
*           interrupt priority is gathered. Composed of vxGppIntConnect()
*           routine.
*        3) Interrupt handler. Here an interrupt is being handle by the
*           Interrupt Handlers (driver's ISR). Composed of gpp7_0Int(),
*           gpp15_8Int(), gpp23_16Int(), gpp31_24Int().
*
*       Full API:
*        vxGppIntCtrlInit() - Initiate the GPP Interrupt Controller driver.
*        vxGppIntConnect()  - Connect the system ISR to a GPP interrupt event.
*        vxGppIntEnable()   - Enable a given GPP interrupt cause.
*        vxGppIntDisable()  - Disable a given GPP interrupt cause.
*        gpp7_0Int() 	    - Handle GPP  7- 0 interrupts.
*        gpp15_8Int() 	    - Handle GPP 15- 8 interrupts.
*        gpp23_16Int() 	    - Handle GPP 23-16 interrupts.
*        gpp31_24Int() 	    - Handle GPP 31-24 interrupts.
*
*
*       The controller concept is very simple:
*        Each of the Interrupt handlers has a small table which holds
*        information on the connected ISR. For example, gpp23_16Int() has
*        gpp23_16Array[] which holds the ISR concerning RS232 channel A and
*        RS232 channel B.
*        An Interrupt generated by one of those pins will result a search
*        through this table in order to locate the generating interrupt cause.
*        After the initiating interrupt cause is identify, the ISR reside in
*        the same table entry is executed.
*        Before the ISR executes the interrupt is acknowledged.
*
*       The controller interface also includes interrupt control routines
*       which can enable/disable specific interrupts: vxGppIntDisable() and
*       vxGppIntEnable().
*
* DEPENDENCIES:
*       MV Interrupt Control Driver.
*		VxWorks types and interrupt lib.
*
*******************************************************************************/

/* includes */
#include "VxWorks.h"
#include "config.h"

#include "vxGppIntCtrl.h"
#include "mvGpp.h"
#include "mvBoardEnvLib.h"

#include <logLib.h>

#ifdef __cplusplus
extern "C" {
#endif


/* defines  */
#define GPP_INVALID_CAUSE(cause)    ((cause) < 0 || 31 < (cause))
#if defined (MV78XX0)
#define mvBoardGpioIntMaskLowGet	mvBoardGpioIntMaskGet
#endif

/* typedefs */


/* locals   */
/* These arrays accumulates ISR information for each GPP group in the main 	*/
/* cause register 															*/
MV_ISR_ENTRY gpp7_0Array[2][8];
MV_ISR_ENTRY gpp15_8Array[2][8];
MV_ISR_ENTRY gpp23_16Array[2][8];
#if defined (MV88F6XXX)
MV_ISR_ENTRY gpp31_24Array[2][8];
#endif
/*Each counter accumulate the number of connection done to a cause array. */
LOCAL int gpp7_0Count[2]   = {0,0};
LOCAL int gpp15_8Count[2]  = {0,0};
LOCAL int gpp23_16Count[2] = {0,0};
#if defined (MV88F6XXX) 
LOCAL int gpp31_24Count[2] = {0,0};
#endif
/*******************************************************************************
* vxGppIntCtrlInit - Initiating the GPP Interrupt Controller driver.
*
* DESCRIPTION:
*		This function configures the GPP port to latch the board interrupts 
*		connected to GPP pins. It also clears the interrupt cause and mask all
*		interrupts.
*		NOTE: This unit interrupt handlers are connected to Main interrupt 
*		controller using the VxWorks intConnect() routine. 
*
* INPUT:
*       None.
*
* OUTPUT:
*       Driver's ISR are connected to the CPU's Interrupt vector and
*       interrupts are unmasked.
*
* RETURN:
*       None.
*
*******************************************************************************/
void vxGppIntCtrlInit(MV_VOID)
{

    MV_U32 gppLowMask;
#if defined (MV88F6XXX) 
    MV_U32 gppHighMask;
#endif
	/* Set low gpp interrupts as needed */
	gppLowMask = mvBoardGpioIntMaskLowGet();

	mvGppTypeSet(0, gppLowMask , (MV_GPP_IN & gppLowMask));
	mvGppPolaritySet(0, gppLowMask , (MV_GPP_IN_INVERT & gppLowMask));
#if defined (MV88F6XXX) 
	/* Set high gpp interrupts as needed */
	gppHighMask = mvBoardGpioIntMaskHighGet();
	mvGppTypeSet(1, gppHighMask , (MV_GPP_IN & gppHighMask));
	mvGppPolaritySet(1, gppHighMask , (MV_GPP_IN_INVERT & gppHighMask));
#endif
	
    /* Clean level mask register  */
    MV_REG_WRITE(GPP_INT_LVL_REG(0), 0);
#if defined (MV88F6XXX) 
    MV_REG_WRITE(GPP_INT_LVL_REG(1), 0);
#endif

}

/*******************************************************************************
* vxGppIntConnect - connect a C routine to a specific GPP interrupt.
*
* DESCRIPTION:
*       This routine connects a specified ISR to a specified GPP interrupt
*       cause. Each ISR handler has its own user ISR array. The connection
*       is done by setting the desired routine and parameter in the
*		corresponding cause array (i.e. gpp23_16Array[]). Connecting the 
*		user ISR is done by inserting the given parameters into an entry 
*		according to the user ISR given priority.
*
* INPUT:
*       cause     - GPP interrupt cause (0-31).
*       routine   - user ISR.
*       parameter - user ISR parameter.
*       prio      - Interrupt handling priority where 0 is highest.
*
* OUTPUT:
*       An appropriate table entry is filled.
*
* RETURN:
*       OK    if succeeded
*       ERROR if cause argument is wrong or connected cause is already
*             found in table.
*
*******************************************************************************/
STATUS vxGppIntConnect(int cause, VOIDFUNCPTR routine, int parameter, int prio)
{
    MV_ISR_ENTRY *intCauseArray=NULL; /* Pointer to the selected cause table */
    int *intConnectCount=NULL;       	 /* Pointer to the table connection counter*/
    int i, intKey;
	int group = 0;

#if defined (MV88F6XXX) 
	if (cause > 31)
	{
		group = 1;
		cause -= 32;
	}
#endif
    intKey = intLock();

    /* Check for cause parameter validity */
    if(routine == NULL)
    {
        printf("vxGppIntConnect: ERR. NULL pointer routine\n");
        intUnlock(intKey);
        return ERROR;
    }
    else if(prio < 0)
    {
        printf("vxGppIntConnect: ERR. Invalid interrupt prio\n");
        intUnlock(intKey);
        return ERROR;
    }
    else if(0 <= cause && cause <= 7)
    {
        intCauseArray   = gpp7_0Array[group];
        intConnectCount = &gpp7_0Count[group];
    }
    else if(8 <= cause && cause <= 15)
    {
        intCauseArray   = gpp15_8Array[group];
        intConnectCount = &gpp15_8Count[group];
    }
    else if(16 <= cause && cause <= 23)
    {
        intCauseArray   = gpp23_16Array[group];
        intConnectCount = &gpp23_16Count[group];
    }
#if defined (MV88F6XXX) 
	else if(24 <= cause && cause <= 31)
    {
        intCauseArray   = gpp31_24Array[group];
        intConnectCount = &gpp31_24Count[group];
    }
#endif
    else
    { /* undefined interrupt cause */
        printf("vxGppIntConnect: undefined cause %d\n", cause);
        intUnlock(intKey);
        return ERROR;
    }

    /* Scan the table to check for double connection to the same cause bit */
    for(i = *intConnectCount; i >= 0; i--)
    {
        if(intCauseArray[i].causeBit == MV_BIT_MASK(cause))
        {
            intCauseArray[i].userISR  = routine;
            intCauseArray[i].arg1     = parameter;
            intUnlock(intKey);
            return OK;
        }
    }

    /* Connection phase */
    for(i = *intConnectCount; i >= 0; i--)
    {
        if(i==0 || intCauseArray[i-1].prio < prio) /* Make connection */
        {
            intCauseArray[i].causeBit = MV_BIT_MASK(cause);
            intCauseArray[i].userISR  = routine;
            intCauseArray[i].arg1     = parameter;
            intCauseArray[i].prio     = prio;
            (*intConnectCount)++;
            break;
        }
        else
        {
            /* Push the low priority connection down the table */
            intCauseArray[i].causeBit = intCauseArray[i-1].causeBit;
            intCauseArray[i].userISR  = intCauseArray[i-1].userISR;
            intCauseArray[i].arg1     = intCauseArray[i-1].arg1;
            intCauseArray[i].prio     = intCauseArray[i-1].prio;
        }
    }

    intUnlock(intKey);
    return OK;
}

/*******************************************************************************
* vxGppIntEnable - Enable a GPP interrupt
*
* DESCRIPTION:
*       This routine makes a specified MV GPP interrupt cause available to
*		the CPU.
*
* INPUT:
*       cause - GPP interrupt cause (0-31).
*
* OUTPUT:
*       The appropriate bit in GPP mask register is reset.
*
* RETURN:
*       OK.
*
* SEE ALSO:
*       vxGppIntDisable()
*
*******************************************************************************/
STATUS vxGppIntEnable(int cause)
{
  volatile 	int group = 0;

#if defined (MV88F6XXX) 
	if (cause > 31)
	{
		group = 1;
		cause -= 32;
	}
#endif
    if (GPP_INVALID_CAUSE(cause))
    {
        printf("vxGppIntEnable: ERR. Invalid cause %d\n", cause);
        return ERROR;
    }

    MV_REG_BIT_SET(GPP_INT_LVL_REG(group), MV_BIT_MASK(cause));

    return OK;
}

/*******************************************************************************
* vxGppIntDisable - Disable a GPP interrupt
*
* DESCRIPTION:
*       This routine makes a specified MV GPP interrupt cause unavailable to
*       the CPU.
*
* INPUT:
*       cause - GPP interrupt cause (0-31).
*
* OUTPUT:
*       The appropriate bit in GPP mask register is reset.
*
* RETURN:
*       OK.
*
* SEE ALSO:
*       vxGppIntEnable()
*
*******************************************************************************/
STATUS vxGppIntDisable(int cause)
{
	volatile int group = 0;

#if defined (MV88F6XXX) 
	if (cause > 31)
	{
		group = 1;
		cause -= 32;
	}
#endif
    if (GPP_INVALID_CAUSE(cause))
    {
        printf("vxGppIntDisable: ERR. Invalid cause %d\n", cause);
        return ERROR;
    }

    MV_REG_BIT_RESET(GPP_INT_LVL_REG(group), MV_BIT_MASK(cause));

    return OK;
}

/*******************************************************************************
* gpp7_0Int - GPP pins 7-0 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 7-0 interrupts.
*      As soon as the interrupt signal is active the CPU analyzes the MV GPP
*      Interrupt Cause register in order to locate the originating interrupt
*      event. Then the routine calls the user specified service routine for that
*      The function scans the gpp15_8Array[] (gpp15_8Count valid entries)
*      trying to find a hit in the gpp15_8Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp7_0Int(UINT32 group)
{
    int     i;
    MV_U32 activeIns;

    activeIns = (MV_REG_READ(GPP_DATA_IN_REG(group)) & 
				 MV_REG_READ(GPP_INT_LVL_REG(group)));
	
	for(i = 0; i < gpp7_0Count[group]; i++)
        if(activeIns & gpp7_0Array[group][i].causeBit)
            (*gpp7_0Array[group][i].userISR) (gpp7_0Array[group][i].arg1);

}

/*******************************************************************************
* gpp15_8Int - GPP pins 15-8 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 15-8 interrupts.
*      As soon as the interrupt signal is active the CPU analyzes the MV GPP
*      Interrupt Cause register in order to locate the originating interrupt
*      event. Then the routine calls the user specified service routine for that
*      The function scans the gpp15_8Array[] (gpp15_8Count valid entries)
*      trying to find a hit in the gpp15_8Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp15_8Int(UINT32 group)
{
    int     i;
    MV_U32 activeIns;

    activeIns = (MV_REG_READ(GPP_DATA_IN_REG(group)) & 
				 MV_REG_READ(GPP_INT_LVL_REG(group)));

	for(i = 0; i < gpp15_8Count[group]; i++)
        if(activeIns & gpp15_8Array[group][i].causeBit)
            (*gpp15_8Array[group][i].userISR) (gpp15_8Array[group][i].arg1);

}

/*******************************************************************************
* gpp23_16Int - GPP pins 23-16 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 23-16 interrupts.
*      As soon as the interrupt signal is active the CPU analyzes the MV GPP
*      Interrupt Cause register in order to locate the originating interrupt
*      event. Then the routine calls the user specified service routine for that
*      The function scans the gpp23_16Array[] (gpp23_16Count valid entries)
*      trying to find a hit in the gpp23_16Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp23_16Int(UINT32 group)
{
    int     i;
    MV_U32 activeIns;
    activeIns = (MV_REG_READ(GPP_DATA_IN_REG(group)) & 
				 MV_REG_READ(GPP_INT_LVL_REG(group)));

	for(i = 0; i < gpp23_16Count[group]; i++)
        if(activeIns & gpp23_16Array[group][i].causeBit)
            (*gpp23_16Array[group][i].userISR) (gpp23_16Array[group][i].arg1);

}
#if defined (MV88F6XXX) 
/*******************************************************************************
* gpp31_24Int - GPP pins 31_24 Interrupt controller routine.
*
* DESCRIPTION:
*      This routine handles the GPP pins 31_24 interrupts.
*      As soon as the interrupt signal is active the CPU analyzes the MV GPP
*      Interrupt Cause register in order to locate the originating interrupt
*      event. Then the routine calls the user specified service routine for that
*      The function scans the gpp31_24Array[] (gpp31_24Count valid entries)
*      trying to find a hit in the gpp23_16Array cause table.
*      When found, the ISR in the same entry is executed.
*      Before ISR execution, the handler acknowledges the initiating interrupt.
*
* INPUT:
*       None.
*
* OUTPUT:
*       None.
*
* RETURN:
*       None.
*
*******************************************************************************/
void gpp31_24Int(UINT32 group)
{
    int     i;
    MV_U32 activeIns;
    activeIns = (MV_REG_READ(GPP_DATA_IN_REG(group)) & 
				 MV_REG_READ(GPP_INT_LVL_REG(group)));

	for(i = 0; i < gpp31_24Count[group]; i++)
        if(activeIns & gpp31_24Array[group][i].causeBit)
            (*gpp31_24Array[group][i].userISR) (gpp31_24Array[group][i].arg1);

}
#endif
#ifdef __cplusplus
}
#endif

