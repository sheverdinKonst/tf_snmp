/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
* snetXCatPolicer.c
*
* DESCRIPTION:
*       (XCat) Policing Engine processing for frame -- simulation
*
* DEPENDENCIES:
*       None.
*
* FILE REVISION NUMBER:
*       $Revision: 55 $
*
*******************************************************************************/

#include <asicSimulation/SKernel/skernel.h>
#include <asicSimulation/SKernel/smem/smemCheetah.h>
#include <asicSimulation/SKernel/suserframes/snet.h>
#include <asicSimulation/SKernel/suserframes/snetLion2Oam.h>
#include <asicSimulation/SKernel/cheetahCommon/sregCheetah.h>
#include <common/Utils/Math/sMath.h>
#include <asicSimulation/SKernel/suserframes/snetXCatPolicer.h>
#include <asicSimulation/SLog/simLog.h>

/* remark entry size in bits for egress policer */
#define SNET_XCAT_POLICER_EGR_REMARK_ENTRY_SIZE_CNS 17

/* Policer Counting modes GET */
#define SNET_XCAT_POLICER_COUNTING_MODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 1, 2)
/* Policer Counter Color Mode GET */
#define SNET_XCAT_POLICER_COUNT_COLOR_MODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 7, 1)

/* Enable IPfix aging */
#define SNET_XCAT_POLICER_IPFIX_AGE_ENABLE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 22, 1)
/* VLAN Counting Mode */
#define SNET_XCAT_POLICER_VLAN_COUNT_MODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 3, 1)

/* IPFIX Control Enable dropped packets counting GET */
#define SNET_XCAT_POLICER_IPFIX_DROP_COUNT_EN_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 8, 1)

/* IPFIX Control IPfix Wrap Around Action GET */
#define SNET_XCAT_POLICER_IPFIX_WA_ACTION_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 9, 1)

/* IPFIX CPU code GET */
#define SNET_XCAT_POLICER_IPFIX_CPU_CODE_GET_MAC(control) \
    SMEM_U32_GET_FIELD((control)[0], 0, 6)

#define SNET_CHT3_POLICER_COLOR_MODE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[6], 2, 1) : \
        SMEM_U32_GET_FIELD(entry[4], 1, 1)


/* Enumeration and structures */

/* Enumeration of Policer Counting modes */
typedef enum {
    SNET_XCAT_POLICER_COUNTING_DISABLE_E = 0,
    SNET_XCAT_POLICER_COUNTING_BILLING_E,
    SNET_XCAT_POLICER_COUNTING_POLICY_E,
    SNET_XCAT_POLICER_COUNTING_VLAN_E
} SNET_XCAT_POLICER_COUNTING_MODE_ENT;

/* Enumeration of Policer Meter modes */
typedef enum {
    SNET_XCAT_POLICER_METER_PORT_E = 0,
    SNET_XCAT_POLICER_METER_FLOW_E
}SNET_XCAT_POLICER_METER_MODE_ENT;

/* Enumeration of E_ARCH (Eport/Evlan) Policer Meter modes */
typedef enum {
    E_ARCH_POLICER_METER_DISABLED_E = 0,
    E_ARCH_POLICER_METER_EPORT_USED_E,
    E_ARCH_POLICER_METER_EVLAN_USED_E,
    E_ARCH_POLICER_METER_NOT_SUPPORTED_E
}E_ARCH_POLICER_METER_MODE_ENT;



/* Enumeration of Policer Meter modes */
typedef enum {
    SNET_XCAT_POLICER_METER_UCAST_E = 0,
    SNET_XCAT_POLICER_METER_UNK_UCAST_E,
    SNET_XCAT_POLICER_METER_REG_MCAST_E,
    SNET_XCAT_POLICER_METER_UNREG_MCAST_E,
    SNET_XCAT_POLICER_METER_BCAST_E,
    SNET_XCAT_POLICER_METER_TCP_SYN_E
}SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT;

/* Enumeration of Policer IPFix Sampling modes */
typedef enum {
    SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E = 0,
    SNET_XCAT_POLICER_SAMPLE_MODE_PCKT_E,
    SNET_XCAT_POLICER_SAMPLE_MODE_BYTE_E,
    SNET_XCAT_POLICER_SAMPLE_MODE_TIME_E
}SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT;

/* Enumeration of Ingress/Egress Policer Interrupts */
typedef enum {
    SNET_XCAT_POLICER_INTR_DATA_ERROR_E     = (1<<1),
    SNET_XCAT_POLICER_INTR_ADDR_OUT_MEM_E   = (1<<2),
    SNET_XCAT_POLICER_INTR_IPFIX_WRAP_E     = (1<<3),
    SNET_XCAT_POLICER_INTR_IPFIX_ALARM_E    = (1<<4),
    SNET_XCAT_POLICER_INTR_IPFIX_ALARM_ENTRIES_FIFO_WA_E = (1<<5)
}SNET_XCAT_POLICER_INTR_ENT;

/* Enumeration of IPFix Sampling action */
typedef enum {
    SNET_XCAT_POLICER_IPFIX_SAMPLE_ALARM_E,
    SNET_XCAT_POLICER_IPFIX_SAMPLE_MIRROR_E
}SNET_XCAT_POLICER_IPFIX_SAMPLE_ACTION_ENT;

/* Structure of Policer IPFix Sampling related info */
typedef struct {
    GT_U64 lastSampleValue64;
    GT_BIT randomEnable;
    GT_U32 randomOffset;
    GT_U32 sampleRange;
    GT_U64 sampleWindow64;
    GT_U32 sampleAction;
    GT_U32 cpuSubCode;
}SNET_XCAT_POLICER_IPFIX_SAMPLE_STC;

#define SMEM_LION3_PLR_METERING_TABLE_FIELDS_NAME                                     \
     STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME0                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME1                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR0                   )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR1                   )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0                               )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1                               )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0                                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1                                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_COLOR_MODE                               )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_POLICER_MODE                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MG_COUNTERS_SET_EN                       )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR                              )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_PACKET_SIZE_MODE                         )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD                  )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE              )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_RED_CMD                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_YELLOW_CMD                       )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_GREEN_CMD                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_DSCP                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_UP                        )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_QOS_PROFILE                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_REMARK_MODE                       )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_DROP_RED                          )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP                     )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP                    )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_TC                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_UP                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DP                      )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_RANK                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_RANK                             )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_COLOR                            )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_COLOR                            )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG                            )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG0                           )\
    ,STR(SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_RATE_INDEX                           )


char * lion3PlrMeteringFieldsTableNames[
    SMEM_LION3_PLR_METERING_TABLE_FIELDS___LAST_VALUE___E]=
    {SMEM_LION3_PLR_METERING_TABLE_FIELDS_NAME};


SNET_ENTRY_FORMAT_TABLE_STC lion3PlrMeteringTableFieldsFormat[
    SMEM_LION3_PLR_METERING_TABLE_FIELDS___LAST_VALUE___E]=
{
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME0                            */
    STANDARD_FIELD_MAC(28),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_LAST_UPDATE_TIME1                            */
    STANDARD_FIELD_MAC(28),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR0                       */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_WRAP_AROUND_INDICATOR1                       */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0                                 */
    STANDARD_FIELD_MAC(32),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1                                 */
    STANDARD_FIELD_MAC(32),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0                                   */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1                                   */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0                                        */
    STANDARD_FIELD_MAC(17),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1                                        */
    STANDARD_FIELD_MAC(17),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0                              */
    STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1                              */
    STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_COLOR_MODE                                   */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_POLICER_MODE                                 */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MG_COUNTERS_SET_EN                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR                                  */
    STANDARD_FIELD_MAC(16),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_PACKET_SIZE_MODE                             */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE                        */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE                  */
    STANDARD_FIELD_MAC(1),

/* ingress only fields */

/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_RED_CMD                              */
    {FIELD_SET_IN_RUNTIME_CNS,
     2,
     SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE},
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_YELLOW_CMD                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_GREEN_CMD                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_DSCP                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_MODIFY_UP                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_INGRESS_QOS_PROFILE                          */
    STANDARD_FIELD_MAC(10),

/* egress only fields */

/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_REMARK_MODE                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE},
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_DROP_RED                              */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP                         */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP                        */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_TC                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_UP                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DP                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_RANK                                 */
    {FIELD_SET_IN_RUNTIME_CNS,
     3,
     SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1},
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_RANK                                 */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_COLOR                                */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_COLOR                                */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG                                */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_COUPLING_FLAG0                               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_RATE_INDEX                               */
    STANDARD_FIELD_MAC(7)

};

#define SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_NAME                                       \
     STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                         )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                       )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                 )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                        )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E       )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                   )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E)\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E            )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E              )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E        )\
         /* ingress only fields*/                                                            \
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                    )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                 )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                  )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                  )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                )\
         /* egress only fields*/                                                             \
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                 )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                    )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E               )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E              )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E       )\
    ,STR(SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                  )

static char * sip5_15PlrMeteringConfigFieldsTableNames[
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_NAME};

/* new table in sip 5_15 that was not in sip5 */
static SNET_ENTRY_FORMAT_TABLE_STC sip5_15PlrMeteringConfigTableFieldsFormat[
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E]=
{
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                                   */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                                 */
    STANDARD_FIELD_MAC(3),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                                  */
    STANDARD_FIELD_MAC(16),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                             */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                        */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E                  */
    STANDARD_FIELD_MAC(1),

/* ingress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                              */
    {FIELD_SET_IN_RUNTIME_CNS,
     2,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                          */
    STANDARD_FIELD_MAC(10),

/* egress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                              */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E                         */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E                        */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E                 */
    STANDARD_FIELD_MAC(1),

/* field common to ingress and to egress */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     3,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E}
};

/* new table in sip 5_15 that was not in sip5 */
static SNET_ENTRY_FORMAT_TABLE_STC sip5_20PlrMeteringConfigTableFieldsFormat[
    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS___LAST_VALUE___E]=
{
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E                                   */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E                                 */
    STANDARD_FIELD_MAC(3),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E                                  */
    STANDARD_FIELD_MAC(17),/*was 16 in sip 5_15 */
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E                 */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E                             */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                        */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E                  */
    STANDARD_FIELD_MAC(1),

/* ingress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_RED_CMD_E                              */
    {FIELD_SET_IN_RUNTIME_CNS,
     2,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_YELLOW_CMD_E                           */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_GREEN_CMD_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_DSCP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_MODIFY_UP_E                            */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E                          */
    STANDARD_FIELD_MAC(10),

/* egress only fields */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E},
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E                              */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E                         */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E                        */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E                          */
    STANDARD_FIELD_MAC(2),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_YELLOW_ECN_MARKING_E                 */
    STANDARD_FIELD_MAC(1),

/* field common to ingress and to egress */

/*SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E                           */
    {FIELD_SET_IN_RUNTIME_CNS,
     3,
     SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INGRESS_QOS_PROFILE_E}
};

#define SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_NAME                                  \
     STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E              )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E              )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E                  )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E         )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E       )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E  )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E)\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E             )\
    ,STR(SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E               )

char * lion3PlrEAttributesFieldsTableNames[
    SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3PlrEAttributesTableFieldsFormat[
    SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E               */
     STANDARD_FIELD_MAC(1)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E               */
    ,STANDARD_FIELD_MAC(1)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E                   */
    ,STANDARD_FIELD_MAC(16)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E          */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E        */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E   */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E              */
    ,STANDARD_FIELD_MAC(3)
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E                */
    ,STANDARD_FIELD_MAC(3)
};

#define SMEM_LION3_PLR_BILLING_TABLE_FIELDS_NAME                                  \
     STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E                        )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E                       )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E                          )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_E                             )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E                )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNT_ALL_EN_E                 )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E              )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E               )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E         )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E                     )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E  )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E              )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E          )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_1_E                           )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E                         )\
    ,STR(SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_2_E                           )


static char * lion3PlrBillingFieldsTableNames[
    SMEM_LION3_PLR_BILLING_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_BILLING_TABLE_FIELDS_NAME};

static SNET_ENTRY_FORMAT_TABLE_STC lion3PlrBillingTableFieldsFormat[
    SMEM_LION3_PLR_BILLING_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E                         */
     STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E                        */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E                           */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_E                              */
    ,STANDARD_FIELD_MAC(14)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E                 */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNT_ALL_EN_E                  */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E                */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E                      */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E   */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                 */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E           */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_1_E                            */
    ,STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E                          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_2_E                            */
    ,STANDARD_FIELD_MAC(12)
};

static SNET_ENTRY_FORMAT_TABLE_STC sip5_15PlrBillingTableFieldsFormat[
    SMEM_LION3_PLR_BILLING_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E                         */
     STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E                        */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E                           */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_E                              */
    ,STANDARD_FIELD_MAC(14)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E                 */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNT_ALL_EN_E                  */
    ,STANDARD_FIELD_MAC(2)/* increment by 1 */
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E                */
    ,STANDARD_FIELD_MAC(42)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E                      */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E   */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E               */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E                 */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E           */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_1_E                            */
    ,STANDARD_FIELD_MAC(35)/* reduced by 1 */
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E                          */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RESERVED_2_E                            */
    ,STANDARD_FIELD_MAC(0)/* removed */
};


#define SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_NAME                                  \
     STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E           )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E         )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E           )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E        )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E          )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E   )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E      )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E         )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E      )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E   )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E        )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E         )\
    ,STR(SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_COUNTER_MODE_E         )

char * lion3PlrIpfixFieldsTableNames[
    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3PlrIpfixTableFieldsFormat[
    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E          */
     STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E        */
    ,STANDARD_FIELD_MAC(30)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E          */
    ,STANDARD_FIELD_MAC(16)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E       */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E         */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E  */
    ,STANDARD_FIELD_MAC(6)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E     */
    ,STANDARD_FIELD_MAC(1)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E        */
    ,STANDARD_FIELD_MAC(2)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E     */
    ,STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E  */
    ,STANDARD_FIELD_MAC(36)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E       */
    ,STANDARD_FIELD_MAC(32)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E        */
    ,STANDARD_FIELD_MAC(30)
/*SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_COUNTER_MODE_E        */
    ,STANDARD_FIELD_MAC(1)
};

#define SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_NAME                             \
     STR(SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_POLICER_PTR_E                  )\
    ,STR(SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_METERING_ENABLE_E              )\
    ,STR(SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_COUNTING_ENABLE_E              )

char * lion3PlrHierarchicalFieldsTableNames[
    SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3PlrHierarchicalTableFieldsFormat[
    SMEM_LION3_PLR_HIERARCHICAL_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E                   */
     STANDARD_FIELD_MAC(16),
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E               */
     STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E               */
     STANDARD_FIELD_MAC(1)
};
/* Function prototypes */

static GT_VOID snetXCatPolicerPolicyCounterIncrement(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytes
);

static GT_VOID snetXCatPolicerVlanCounterIncrement(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytes
);

static GT_VOID snetXCatPolicerStormRateTypeGet(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT * pcktTypePtr
);

static void snetXcatPolicerIpfixDropWaCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_BIT dropCountEn,
    IN GT_U32 * dropPcktsPtr,
    GT_U32 treshold,
    GT_BIT wrapAction,
    GT_BOOL * wrapTriggeredPtr
);

static void snetXcatPolicerIpfixGoodPcktWaCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * goodPcktsPtr,
    IN GT_U32 treshold,
    IN GT_BIT wrapAction,
    INOUT GT_BOOL * wrapTriggeredPtr
);

static void snetXcatPolicerIpfixBytesWaCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U64 * bytesCntPtr,
    IN GT_U32 bytes,
    IN GT_U64 * treshold64Ptr,
    IN GT_BIT wrapAction,
    OUT GT_BOOL * wrapTriggeredPtr
);

static GT_BOOL snetLion2PolicerOamLmCounterIncrement(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 policerCntIndex,
    GT_U64 increment64
);


/*******************************************************************************
*   snetLion3PolicerPacketSizeGet
*
* DESCRIPTION:
*       Sip5 : Traffic Packet Size for Metering and Counting.
*             Get number of bytes for metering/billing/other .
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*       direction   - ingress/egress policer direction
*       packetSizeMode - packet size mode
*       entryPtr - pointer to the meter/billing entry that hold info for the calculation
*                   relevant when : packetSizeMode = SNET_LION3_POLICER_PACKET_SIZE_FROM_METER_ENTRY_E
*                                or packetSizeMode = SNET_LION3_POLICER_PACKET_SIZE_FROM_BILLING_ENTRY_E
*
* OUTPUT
*       bytesCountPtr  - counter in bytes
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetLion3PolicerPacketSizeGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN SNET_LION3_POLICER_PACKET_SIZE_MODE_ENT packetSizeMode,
    IN GT_U32           *entryPtr,
    OUT GT_U32          *bytesCountPtr
)
{
    DECLARE_FUNC_NAME(snetLion3PolicerPacketSizeGet);

    GT_U32  entryIndex;
    GT_U32 * policerCtrlRegPtr;         /* egress policer control data */
    GT_U32  packet_size_mode;
    GT_U32  tunnel_termination_packet_size_mode;
    GT_U32  include_layer1_overhead;
    GT_U32  dsa_tag_counting_mode;
    GT_U32  timestamp_tag_counting_mode;
    GT_U32  finalByteCount;
    GT_U32  tmpBytes;
    GT_BIT  marvellTagged;
    SKERNEL_EXT_DSA_TAG_TYPE_ENT    dsaTagType;
    GT_BIT  dsaReplacesVlan;
    GT_BIT timestampTagged;
    GT_BIT  isTunnel;
    GT_U32  l2Valid,l2HeaderSize,l2HeaderSizeTunnel,l2NumBytesToRemove;
    GT_U32  byteCount,byteCountTunnel,byteCountToUse;
    GT_BIT  useGlobalModes = 0;

    if(packetSizeMode == SNET_LION3_POLICER_PACKET_SIZE_FROM_METER_ENTRY_E && entryPtr != NULL)
    {
        __LOG(("Calc Byte count for Metering \n"));

        entryIndex = descrPtr->policerActuallAccessedIndex;
        if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
        {
            packet_size_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_PACKET_SIZE_MODE_E);
            tunnel_termination_packet_size_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E);
            include_layer1_overhead  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E);
            dsa_tag_counting_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E);
            timestamp_tag_counting_mode  =
                SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                    descrPtr->policerMeterConfigEntryMemoryPtr,
                    entryIndex,
                    SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E);
        }
        else
        {
            packet_size_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_PACKET_SIZE_MODE);
            tunnel_termination_packet_size_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE);
            include_layer1_overhead  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD);
            dsa_tag_counting_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE);
            timestamp_tag_counting_mode  =
                SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                    entryIndex,
                    SMEM_LION3_PLR_METERING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE);
        }
    }
    else
    if(packetSizeMode == SNET_LION3_POLICER_PACKET_SIZE_FROM_BILLING_ENTRY_E && entryPtr != NULL)
    {
        __LOG(("Calc Byte count for Billing \n"));

        entryIndex = descrPtr->countingActuallAccessedIndex;

        packet_size_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_PACKET_SIZE_MODE_E);
        tunnel_termination_packet_size_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TUNNEL_TERMINATION_PACKET_SIZE_MODE_E);
        include_layer1_overhead  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_INCLUDE_LAYER1_OVERHEAD_E);
        dsa_tag_counting_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_DSA_TAG_COUNTING_MODE_E);
        timestamp_tag_counting_mode  =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                entryIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_TIMESTAMP_TAG_COUNTING_MODE_E);
    }
    else
    {
        if(descrPtr->policerCounterGlobalNumBytes)
        {
            *bytesCountPtr = descrPtr->policerCounterGlobalNumBytes;
            __LOG(("Final Byte count: [%d] bytes (already calculated according to global modes) \n",
                *bytesCountPtr));
            return;
        }

        useGlobalModes = 1;
        __LOG(("Calc Byte count for non-meter , non-billing purpose \n"));

        policerCtrlRegPtr =
            smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle));

        packet_size_mode             = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 16, 1);
        include_layer1_overhead      = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 17, 1);
        dsa_tag_counting_mode        = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 23, 1);
        tunnel_termination_packet_size_mode  = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 24, 1);
        timestamp_tag_counting_mode  = SMEM_U32_GET_FIELD(policerCtrlRegPtr[0], 4, 1);
    }

    __LOG_PARAM(packet_size_mode);
    __LOG_PARAM(include_layer1_overhead);
    __LOG_PARAM(dsa_tag_counting_mode);
    __LOG_PARAM(tunnel_termination_packet_size_mode);
    __LOG_PARAM(timestamp_tag_counting_mode);

    if(direction == SMAIN_DIRECTION_INGRESS_E)
    {
        isTunnel = descrPtr->tunnelTerminated;
        l2Valid = descrPtr->l2Valid;

        if(isTunnel)
        {
            l2HeaderSizeTunnel = descrPtr->origInfoBeforeTunnelTermination.originalL3Ptr -
                descrPtr->origInfoBeforeTunnelTermination.originalL2Ptr;

            __LOG(("Tunnel : for tunnel mode : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSizeTunnel));

            byteCountTunnel = descrPtr->origByteCount;
            __LOG(("Tunnel : for tunnel mode : Num bytes for L2: is[%d] bytes \n",
                byteCountTunnel));

            /* num bytes to decrement from byte count of passenger to be with L3 only */
            if(l2Valid)
            {
                l2HeaderSize = descrPtr->l3StartOffsetPtr - descrPtr->macDaPtr;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 valid , is[%d] bytes \n",
                    l2HeaderSize));
            }
            else
            {
                l2HeaderSize = 0;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 NOT valid , is 0 bytes \n"));
            }

            byteCount = descrPtr->byteCount;
            __LOG(("Tunnel : for passenger mode : Num bytes for L2: is[%d] bytes \n",
                byteCount));

        }
        else
        {
            l2HeaderSize       = descrPtr->l2HeaderSize;
            l2HeaderSizeTunnel = l2HeaderSize;

            __LOG(("No Tunnel : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSize));

            byteCount = descrPtr->byteCount;
            byteCountTunnel = byteCount;

            __LOG(("No Tunnel : Num bytes for L2: is[%d] bytes \n",
                byteCount));
        }
    }
    else
    {
        isTunnel = descrPtr->tunnelStart;
        /*for TS that is not with ethernet passenger this is NULL */
        /*for TS that is     with ethernet passenger this is the mac da of the passenger */
        /*for non-TS that this is the mac da of the packet */
        l2Valid = descrPtr->haToEpclInfo.macDaSaPtr ? 1 : 0;

        if(isTunnel)
        {
            l2HeaderSizeTunnel = descrPtr->haToEpclInfo.tunnelStartL3StartOffsetPtr -
                           descrPtr->haToEpclInfo.tunnelStartL2StartOffsetPtr;
            __LOG(("Tunnel : for tunnel mode : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSizeTunnel));

            byteCountTunnel = descrPtr->egressByteCount;
            __LOG(("Tunnel : for tunnel mode : Num bytes for L2: is[%d] bytes \n",
                byteCountTunnel));

            if(l2Valid)
            {
                l2HeaderSize = descrPtr->haToEpclInfo.l3StartOffsetPtr - descrPtr->haToEpclInfo.macDaSaPtr;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 valid , is[%d] bytes \n",
                    l2HeaderSize));

                byteCount = descrPtr->haToEpclInfo.macDaSaPtr - devObjPtr->egressBuffer;
                __LOG(("Tunnel : for passenger mode : Num bytes for L2: when L2 valid , is[%d] bytes \n",
                    byteCount));
            }
            else
            {
                l2HeaderSize = 0;
                __LOG(("Tunnel : for passenger mode : Num bytes to remove to get L3 from L2: when L2 NOT valid , is 0 bytes \n"));

                byteCount = descrPtr->haToEpclInfo.l3StartOffsetPtr - devObjPtr->egressBuffer;
                __LOG(("Tunnel : for passenger mode : Num bytes for L2: when L2 valid , is[%d] bytes \n",
                    byteCount));
            }

        }
        else
        {
            l2HeaderSize = descrPtr->haToEpclInfo.l3StartOffsetPtr -
                           descrPtr->haToEpclInfo.macDaSaPtr;
            l2HeaderSizeTunnel = l2HeaderSize;

            __LOG(("No Tunnel : Num bytes to remove to get L3 from L2: is[%d] bytes \n",
                l2HeaderSize));

            byteCount       = descrPtr->egressByteCount;
            byteCountTunnel = byteCount;

            __LOG(("No Tunnel : Num bytes for L2: is[%d] bytes \n",
                byteCount));
        }
    }

    if(isTunnel && tunnel_termination_packet_size_mode == 1/*Passenger*/)
    {
        __LOG(("Tunnel : byte count of the 'passenger and not the tunnel' \n"));

        l2NumBytesToRemove = l2HeaderSize;
        byteCountToUse = byteCount;
    }
    else
    if (isTunnel)
    {
        __LOG(("Tunnel : byte count of the 'tunnel and not the passenger' \n"));

        l2NumBytesToRemove = l2HeaderSizeTunnel;
        byteCountToUse = byteCountTunnel;
    }
    else
    {
        __LOG(("Non Tunnel : byte count of the packet \n"));
        l2NumBytesToRemove = l2HeaderSize;
        byteCountToUse = byteCount;
    }
    __LOG_PARAM(byteCountToUse);

    if(packet_size_mode == SNET_CHT3_LAYER3_PCKT_SIZE_E)/*L3*/
    {
        finalByteCount = byteCountToUse - l2NumBytesToRemove - 4/*CRC*/;

        __LOG(("count L3 bytes :[%d] \n",
            finalByteCount));
    }
    else /*L2*/
    {
        finalByteCount = byteCountToUse;
        __LOG(("count L2 bytes :[%d] \n",
            finalByteCount));
        if(include_layer1_overhead)
        {
            /* Packet byte count includes 20 bytes of layer-1 overhead */
            __LOG(("include LAYER1 (20 bytes) \n"));
            finalByteCount += 20;
        }
        else
        {
            __LOG(("NOT including LAYER1 (20 bytes) \n"));
        }

        if(direction == SMAIN_DIRECTION_INGRESS_E)
        {
            marvellTagged = descrPtr->marvellTagged;
            dsaTagType = descrPtr->marvellTaggedExtended;
            dsaReplacesVlan = descrPtr->origSrcTagged;
        }
        else
        {
            marvellTagged = descrPtr->egrMarvellTagType != MTAG_TYPE_NONE_E ? 1 : 0;
            dsaTagType    = descrPtr->egrMarvellTagType;
            dsaReplacesVlan = descrPtr->origSrcTagged;SIM_TBD_BOOKMARK /*descrPtr->eArchExtInfo.haInfo.dsaReplacesVlan*/
        }

        /* Enable Compensation of DSA Tag added byte count when metering and counting
           packets received via DSA-enabled ports */
        if (dsa_tag_counting_mode && marvellTagged)
        {
            /* decrement the bytes of the DSA tag */
            tmpBytes = (dsaTagType + 1)*4;

            __LOG(("decrement the bytes of the DSA tag (remove [%d] bytes) \n",
                tmpBytes));
            if(dsaReplacesVlan)
            {
                /* add the bytes of the original tag (that used in first word of the DSA tag) */
                __LOG(("add the 4 bytes of the original tag (that used in first word of the DSA tag)"));
                tmpBytes += 4;
            }

            finalByteCount -= tmpBytes;
        }
        else
        if(marvellTagged)
        {
            __LOG(("DSA tagged packet but Compensation on DSA tag bytes is disabled \n"));
        }

        timestampTagged = descrPtr->timestampTagged[direction];

        if(timestamp_tag_counting_mode && timestampTagged !=  SKERNEL_TIMESTAMP_TAG_TYPE_UNTAGGED_E)
        {
            if (timestampTagged ==  SKERNEL_TIMESTAMP_TAG_TYPE_NON_EXTENDED_E)
            {
                finalByteCount -= 8;
                __LOG(("Timestamp Tag NON_EXTENDED - packet Timestamp Tag Compensation is 8 bytes \n"));
            }
            else if (timestampTagged ==  SKERNEL_TIMESTAMP_TAG_TYPE_EXTENDED_E)
            {
                finalByteCount -= 16;
                __LOG(("Timestamp Tag EXTENDED - packet Timestamp Tag Compensation is 16 bytes \n"));
            }
            else
            {
                __LOG(("Timestamp Tagged packet but Compensation on Timestamp Tagged bytes NOT implemented \n"));
            }
        }
        else
        if(timestampTagged !=  SKERNEL_TIMESTAMP_TAG_TYPE_UNTAGGED_E)
        {
            __LOG(("Timestamp Tagged packet but Compensation on Timestamp Tagged bytes is disabled \n"));
        }

        if(direction == SMAIN_DIRECTION_EGRESS_E &&
           devObjPtr->errata.eplrNotCountCrc)/* CRC not relevant to L3 counting */
        {
            GT_U32  numBytesRemoved;
            GT_U32  diffTo64Bytes;

            __LOG_PARAM(finalByteCount);

            diffTo64Bytes = finalByteCount >= 64 ? (finalByteCount - 64) : 0;

            if(diffTo64Bytes >= 4)
            {
                __LOG(("WARNING : Errata : The EPLR do wrong calc of packet length (not using 4 bytes CRC) \n"));
                numBytesRemoved = 4;
            }
            else
            {
                __LOG(("WARNING : Errata : The EPLR do minimal 64 bytes calc , so remove [%d] bytes from <finalByteCount> (not full 4 bytes of CRC) \n",
                    diffTo64Bytes));

                numBytesRemoved = diffTo64Bytes;
            }

            /* remove the needed bytes */
            finalByteCount -= numBytesRemoved;

            __LOG_PARAM(finalByteCount);
        }
    }

    if(finalByteCount < 64)
    {
        /*POLICER-1382 - The PLR do minimal count of 64 bytes.(regardless to IPLR/EPLR , count mode : L1,L2,L3)*/

        __LOG(("The Policer unit count minimal 64 bytes so modified from [%d]\n",
            finalByteCount));
        finalByteCount = 64;
    }

    if(useGlobalModes)
    {
        /* save this value for it may be needed again by other counter */
        descrPtr->policerCounterGlobalNumBytes = finalByteCount;
    }

    *bytesCountPtr = finalByteCount;
    __LOG(("Final Byte count: [%d] bytes \n",
        *bytesCountPtr));
    return;

}


/*******************************************************************************
*   reduceCommonDenominator
*
* DESCRIPTION:
*       divide to values by their common denominator.
*
* INPUTS:
*       value1   - first value
*       value2   - second value
* OUTPUT
*       updatedValue1Ptr   - pointer to updated first value
*       updatedValue2Ptr   - pointer to updated second value
*
* RETURN:
*
*******************************************************************************/
void reduceCommonDenominator
(
    IN GT_U32  value1,
    IN GT_U32  value2,
    OUT GT_U32  *updatedValue1Ptr,
    OUT GT_U32  *updatedValue2Ptr
)
{
    /* list from http://astrospiker.com/MATHCOACH/primes.html */
    GT_U32  primeNumbersArr[] = {
          2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,
          43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101,

         103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,
         173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,

         241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
         317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,

         401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
         479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569,

         571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
         647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733,

         739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,
         827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,

         919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997,
         SMAIN_NOT_VALID_CNS};
    GT_U32  updatedValue1 = value1;
    GT_U32  updatedValue2 = value2;
    GT_U32  index;
    GT_U32  primeValue;

    for(index = 0 ; primeNumbersArr[index] != SMAIN_NOT_VALID_CNS ; index++)
    {
        primeValue = primeNumbersArr[index];
        if(updatedValue1 < primeValue)
            break;
        if(updatedValue2 < primeValue)
            break;

        if((updatedValue1 % primeValue) == 0 &&
           (updatedValue2 % primeValue) == 0)
        {
            /* both numbers can be divided by this number */
            updatedValue1 /= primeValue;
            updatedValue2 /= primeValue;

            index--;/* make sure to repeat this prim number */
        }
    }

    *updatedValue1Ptr = updatedValue1;
    *updatedValue2Ptr = updatedValue2;

    return;
}

/*******************************************************************************
*   snetLion3PolicerCalcNumByteAddToToken
*
* DESCRIPTION:
*       Sip5_15 : calculate max tokens that need to be added to buken due to
*                  time passed from last packet in this entry
*
* INPUTS:
*       rate        - rate from the meter entry
*       rate_type   - TYPE rate from the meter entry
* OUTPUT
*       maxTokensToAddPtr   - pointer to max tokens to add
*
* RETURN:
*
*******************************************************************************/
static void snetLion3PolicerCalcNumByteAddToToken
(
    IN GT_U32  rate,
    IN GT_U32  rate_type,
    OUT GT_U32  *maxTokensToAddPtr
)
{
    GT_CHAR     *timeUnitNames[SKERNEL_TIME_UNITS__LAST__E] = {
        STR(SKERNEL_TIME_UNITS_NOT_VALID_E),
        STR(SKERNEL_TIME_UNITS_MILI_SECONDS_E),
        STR(SKERNEL_TIME_UNITS_MICRO_SECONDS_E),
        STR(SKERNEL_TIME_UNITS_NANO_SECONDS_E),
        STR(SKERNEL_TIME_UNITS_PICO_SECONDS_E)};
    GT_U32  rateFactors[] = /* values in kilo (1000) bits per second */
                            {1,     10,     100,
                             1*1000,10*1000,100*1000};
    GT_U32  timeFactors[] = /* values in 1/x milliSeconds */
                             {  1/*N/A*/,       1,       1000/*micro*/,
                             1000*1000/*nano*/, 1000*1000*1000};
    GT_U32 timeFactor;
    GT_U32 bytesRateFactor;/* /8 from rateFactors[] */
    GT_U32 updatedTimeFactor;
    GT_U32 updatedRateFactor;
    GT_U32 bytesToAddToken;
    GT_U32 timeBetweenPackets;
    GT_U32 rateFactor;
    GT_U32 tmpValue;


    if(skernelUserDebugInfo.enhancedPolicerIfgTime.timeUnit == SKERNEL_TIME_UNITS_NOT_VALID_E)
    {
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("SIMULATION : support of filling of Tokens is disabled \n"));
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("if needed see simulation API : skernelPolicerInterFramGapInfoSet(...) \n"));

        *maxTokensToAddPtr = 0;

        return;
    }

    timeBetweenPackets = skernelUserDebugInfo.enhancedPolicerIfgTime.timeBetweenPackets;

    __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("time from the last packet in units of [%s] and value[%d] \n",
        timeUnitNames[skernelUserDebugInfo.enhancedPolicerIfgTime.timeUnit],
        timeBetweenPackets));

    rateFactor = rateFactors[rate_type];
    __LOG_PARAM_NO_LOCATION_META_DATA(rateFactor);

    timeFactor = timeFactors[skernelUserDebugInfo.enhancedPolicerIfgTime.timeUnit];
    __LOG_PARAM_NO_LOCATION_META_DATA(timeFactor);

    bytesRateFactor = (1000/*from Kbits*/ * rateFactor) / 8;
    __LOG_PARAM_NO_LOCATION_META_DATA(bytesRateFactor);

    reduceCommonDenominator(bytesRateFactor,timeFactor ,
            &updatedRateFactor,&updatedTimeFactor);
    __LOG_PARAM_NO_LOCATION_META_DATA(updatedRateFactor);

    /* 'max bytes' = (rate * factor) * (time * timeUnit) */
    /* (rate * factor) in units of 'Kbps' */
    /* (time * timeUnit) in units of 'milliSec' */
    tmpValue = (rate * updatedRateFactor)/(updatedTimeFactor);
    bytesToAddToken = (tmpValue * timeBetweenPackets) / 1000/*from millisec */;

    __LOG_PARAM_NO_LOCATION_META_DATA(bytesToAddToken);

    *maxTokensToAddPtr = bytesToAddToken;

    return;
}


/* sip5_15 : SrTCM decision for conformance level */
#define SIP5_15_SR_TCM_CONF_LEVEL_GET(initialDp,bTb0SignPos,bTb1SignPos)                     \
  (bTb0SignPos && (initialDp == SKERNEL_CONFORM_GREEN))         ? SKERNEL_CONFORM_GREEN :    \
  (bTb1SignPos && ((initialDp == SKERNEL_CONFORM_GREEN) ||                                   \
                   (initialDp == SKERNEL_CONFORM_YELLOW)))      ? SKERNEL_CONFORM_YELLOW :   \
                                                                  SKERNEL_CONFORM_RED

/* sip5_15 : TrTCM decision for conformance level */
#define SIP5_15_TR_TCM_CONF_LEVEL_GET(initialDp,bTb0SignPos,bTb1SignPos)                     \
  ((bTb1SignPos==0) || (initialDp == SKERNEL_CONFORM_RED))      ? SKERNEL_CONFORM_RED :      \
  ((bTb0SignPos==0) || (initialDp == SKERNEL_CONFORM_YELLOW))   ? SKERNEL_CONFORM_YELLOW :   \
                                                                  SKERNEL_CONFORM_GREEN

/* calc sign of bit in table 'Metering Conformance Level Sign Memory' (without byte count considerations)*/
#define SIP_5_15_CONF_SIGN_CALC(bucket_size,mru)  \
        ((bucket_size > mru) ? 1 : 0)

/* calc sign of bit in table 'Metering Conformance Level Sign Memory' , with byte count considerations */
#define SIP_5_15_CONF_SIGN_CALC_WITH_BYTE_COUNT(bucket_size,mru,byteCount)  \
        ((bucket_size > byteCount && bucket_size > mru) ? 1 : 0)


/*******************************************************************************
*   sip5_15_srTcm_calcUpdatedTokenBucket
*
* DESCRIPTION:
*       Sip5_15 : SrTCM : calculate updated values for token buckets 0,1.
*
* INPUTS:
*       policer_mode - one of SNET_LION3_POLICER_METERING_MODE_ENT
*       conformanceLevel - one of SKERNEL_CONFORMANCE_LEVEL_ENT
*       meteredValue - the byte count / packet
*       max_burst_size0 - from the entry
*       max_burst_size1 - from the entry
*       bucket_size0    - from the entry
*       bucket_size1    - from the entry
*       rate0           - from the entry
*       rate1           - from the entry
*       rate_type0      - from the entry
*       rate_type1      - from the entry
* OUTPUT
*       finalBucketSize0Ptr   - pointer to new bucket 0 size
*       finalBucketSize1Ptr   - pointer to new bucket 0 size
*
* RETURN:
*
*******************************************************************************/
static void sip5_15_srTcm_calcUpdatedTokenBucket(
    IN SKERNEL_CONFORMANCE_LEVEL_ENT conformanceLevel,
    IN GT_U32                       meteredValue,
    IN GT_U32                       max_burst_size0,
    IN GT_U32                       max_burst_size1,
    IN GT_U32                       bucket_size0,
    IN GT_U32                       bucket_size1,
    IN GT_U32                       rate0,
    IN GT_U32                       rate1,
    IN GT_U32                       rate_type0,
    IN GT_U32                       rate_type1,
    OUT GT_U32                       *finalBucketSize0Ptr,
    OUT GT_U32                       *finalBucketSize1Ptr
)
{
    GT_U32 maxTokensToAdd0,maxTokensToAdd1;

    __LOG_NO_LOCATION_META_DATA(("SrTcm calculation \n"));

    __LOG_NO_LOCATION_META_DATA(("calc max Tokens To Add bucket 0 \n"));
    snetLion3PolicerCalcNumByteAddToToken(rate0,rate_type0,&maxTokensToAdd0);

    __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd0);

    if (max_burst_size0 < (bucket_size0 + maxTokensToAdd0))
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 , till it's max value (and not possible[%d] tokens) \n",
            max_burst_size0 - bucket_size0 , maxTokensToAdd0));

        bucket_size0 = max_burst_size0;

        __LOG_NO_LOCATION_META_DATA(("max Tokens To Add bucket 1 derive from this of bucket 0 \n"));

        maxTokensToAdd1 = maxTokensToAdd0 - (max_burst_size0 - bucket_size0);
        __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd1);

        if((max_burst_size0 - bucket_size0) > maxTokensToAdd0)
        {
            /* we are getting 'negative' value ?! */
            skernelFatalError("sip5_15_srTcm_calcUpdatedTokenBucket : max Tokens To Add bucket 1 calculated with negative value [%d] ! \n",
                maxTokensToAdd1);
        }

        if (max_burst_size1 < (bucket_size1 + maxTokensToAdd1))
        {
            __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 , till it's max value (and not possible[%d] tokens) \n",
                max_burst_size1 - bucket_size1 , maxTokensToAdd1));

            bucket_size1 = max_burst_size1;
        }
        else
        {
            __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 \n",
                maxTokensToAdd1));
            bucket_size1 += maxTokensToAdd1;
        }
    }
    else
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 only \n",
            maxTokensToAdd0));
        bucket_size0 += maxTokensToAdd0;
    }

    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size0);
    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size1);

    if (conformanceLevel == SKERNEL_CONFORM_GREEN)
    {
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : reduce from token bucket 0 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize0Ptr = (bucket_size0 > meteredValue) ? bucket_size0 - meteredValue : 0;
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : do not update token bucket 1 (keep previous values) \n"));
        *finalBucketSize1Ptr = bucket_size1;
    }
    else if (conformanceLevel == SKERNEL_CONFORM_YELLOW)
    {
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : do not update token bucket 0 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : reduce from token bucket 1 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize1Ptr = (bucket_size1 > meteredValue) ? bucket_size1 - meteredValue : 0;
    }
    else /* SKERNEL_CONFORM_RED */
    {
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 0 (keep previous values) \n"));
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 1 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        *finalBucketSize1Ptr = bucket_size1;
    }
}

/*******************************************************************************
*   sip5_15_trTcm_calcUpdatedTokenBucket
*
* DESCRIPTION:
*       Sip5_15 : TrTCM : calculate updated values for token buckets 0,1.
*
* INPUTS:
*       policer_mode - one of SNET_LION3_POLICER_METERING_MODE_ENT
*       conformanceLevel - one of SKERNEL_CONFORMANCE_LEVEL_ENT
*       meteredValue - the byte count / packet
*       max_burst_size0 - from the entry
*       max_burst_size1 - from the entry
*       bucket_size0    - from the entry
*       bucket_size1    - from the entry
*       rate0           - from the entry
*       rate1           - from the entry
*       rate_type0      - from the entry
*       rate_type1      - from the entry
* OUTPUT
*       finalBucketSize0Ptr   - pointer to new bucket 0 size
*       finalBucketSize1Ptr   - pointer to new bucket 0 size
*
* RETURN:
*
*******************************************************************************/
static void sip5_15_trTcm_calcUpdatedTokenBucket(
    IN SKERNEL_CONFORMANCE_LEVEL_ENT conformanceLevel,
    IN GT_U32                       meteredValue,
    IN GT_U32                       max_burst_size0,
    IN GT_U32                       max_burst_size1,
    IN GT_U32                       bucket_size0,
    IN GT_U32                       bucket_size1,
    IN GT_U32                       rate0,
    IN GT_U32                       rate1,
    IN GT_U32                       rate_type0,
    IN GT_U32                       rate_type1,
    OUT GT_U32                       *finalBucketSize0Ptr,
    OUT GT_U32                       *finalBucketSize1Ptr
)
{
    GT_U32 maxTokensToAdd0,maxTokensToAdd1;

    __LOG_NO_LOCATION_META_DATA(("TrTcm calculation \n"));

    __LOG_NO_LOCATION_META_DATA(("calc max Tokens To Add bucket 0 \n"));
    snetLion3PolicerCalcNumByteAddToToken(rate0,rate_type0,&maxTokensToAdd0);

    __LOG_NO_LOCATION_META_DATA(("calc max Tokens To Add bucket 1 \n"));
    snetLion3PolicerCalcNumByteAddToToken(rate1,rate_type1,&maxTokensToAdd1);

    __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd0);
    __LOG_PARAM_NO_LOCATION_META_DATA(maxTokensToAdd1);

    if (max_burst_size0 < (bucket_size0 + maxTokensToAdd0))
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 , till it's max value (and not possible[%d] tokens) \n",
            max_burst_size0 - bucket_size0 , maxTokensToAdd0));

        bucket_size0 = max_burst_size0;
    }
    else
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 0 \n",
            maxTokensToAdd0));
        bucket_size0 += maxTokensToAdd0;
    }

    if (max_burst_size1 < (bucket_size1 + maxTokensToAdd1))
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 , till it's max value (and not possible[%d] tokens) \n",
            max_burst_size1 - bucket_size1 , maxTokensToAdd1));

        bucket_size1 = max_burst_size1;
    }
    else
    {
        __LOG_NO_LOCATION_META_DATA(("adding [%d] Tokens to bucket 1 \n",
            maxTokensToAdd1));
        bucket_size1 = bucket_size1 + maxTokensToAdd1;
    }

    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size0);
    __LOG_PARAM_NO_LOCATION_META_DATA(bucket_size1);


    if (conformanceLevel == SKERNEL_CONFORM_RED)
    {
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 0 (keep previous values) \n"));
        __LOG_NO_LOCATION_META_DATA(("For Red conformance : do not update token bucket 1 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        *finalBucketSize1Ptr = bucket_size1;
    }
    else if (conformanceLevel == SKERNEL_CONFORM_YELLOW)
    {
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : do not update token bucket 0 (keep previous values) \n"));
        *finalBucketSize0Ptr = bucket_size0;
        __LOG_NO_LOCATION_META_DATA(("For Yellow conformance : reduce from token bucket 1 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize1Ptr = (bucket_size1 > meteredValue) ? bucket_size1 - meteredValue : 0;
    }
    else /*SKERNEL_CONFORM_GREEN*/
    {
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : reduce from token bucket 0 the meter byte/packet count (until reach 0) \n"));
        __LOG_NO_LOCATION_META_DATA(("For Green conformance : reduce from token bucket 1 the meter byte/packet count (until reach 0) \n"));
        *finalBucketSize0Ptr = (bucket_size0 > meteredValue) ? bucket_size0 - meteredValue : 0;
        *finalBucketSize1Ptr = (bucket_size1 > meteredValue) ? bucket_size1 - meteredValue : 0;
    }
}

/*******************************************************************************
*   sip5_15_calcUpdatedTokenBucket
*
* DESCRIPTION:
*       Sip5_15 : calculate updated values for token buckets 0,1.
*
* INPUTS:
*       policer_mode - one of SNET_LION3_POLICER_METERING_MODE_ENT
*       conformanceLevel - one of SKERNEL_CONFORMANCE_LEVEL_ENT
*       meteredValue - the byte count / packet
*       max_burst_size0 - from the entry
*       max_burst_size1 - from the entry
*       bucket_size0    - from the entry
*       bucket_size1    - from the entry
*       rate0           - from the entry
*       rate1           - from the entry
*       rate_type0      - from the entry
*       rate_type1      - from the entry
* OUTPUT
*       finalBucketSize0Ptr   - pointer to new bucket 0 size
*       finalBucketSize1Ptr   - pointer to new bucket 0 size
*
* RETURN:
*
*******************************************************************************/
static void sip5_15_calcUpdatedTokenBucket(
    IN SNET_LION3_POLICER_METERING_MODE_ENT  policer_mode,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT conformanceLevel,
    IN GT_U32                       meteredValue,
    IN GT_U32                       max_burst_size0,
    IN GT_U32                       max_burst_size1,
    IN GT_U32                       bucket_size0,
    IN GT_U32                       bucket_size1,
    IN GT_U32                       rate0,
    IN GT_U32                       rate1,
    IN GT_U32                       rate_type0,
    IN GT_U32                       rate_type1,
    OUT GT_U32                       *finalBucketSize0Ptr,
    OUT GT_U32                       *finalBucketSize1Ptr
)
{
    GT_U32  unified_max_burst_size0;/* convert from rate_type0 and max_burst_size0 */
    GT_U32  unified_max_burst_size1;/* convert from rate_type1 and max_burst_size1 */
    GT_U32  bytesFactor0 , bytesFactor1;

    *finalBucketSize0Ptr = 0;
    *finalBucketSize1Ptr = 0;

    bytesFactor0 = 1 << (3*rate_type0);/*8^rate_type0;*/ /*1,8,64,512,4K,32K */
    bytesFactor1 = 1 << (3*rate_type1);/*8^rate_type1;*/ /*1,8,64,512,4K,32K */

    unified_max_burst_size0 = max_burst_size0 * bytesFactor0;
    unified_max_burst_size1 = max_burst_size1 * bytesFactor1;

    __LOG_PARAM_NO_LOCATION_META_DATA(unified_max_burst_size0);
    __LOG_PARAM_NO_LOCATION_META_DATA(unified_max_burst_size1);

    switch(policer_mode)
    {
        case SNET_LION3_POLICER_METERING_MODE_SrTCM_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF0_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF1_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF10_3_START_E:
        case SNET_LION3_POLICER_METERING_MODE_MEF10_3_NOT_START_E:
            sip5_15_srTcm_calcUpdatedTokenBucket(conformanceLevel,meteredValue,
                    unified_max_burst_size0,unified_max_burst_size1,
                    bucket_size0,bucket_size1,
                    rate0,rate1,rate_type0,rate_type1,
                    finalBucketSize0Ptr,finalBucketSize1Ptr);
            break;
        case SNET_LION3_POLICER_METERING_MODE_TrTCM_E:
            sip5_15_trTcm_calcUpdatedTokenBucket(conformanceLevel,meteredValue,
                    unified_max_burst_size0,unified_max_burst_size1,
                    bucket_size0,bucket_size1,
                    rate0,rate1,rate_type0,rate_type1,
                    finalBucketSize0Ptr,finalBucketSize1Ptr);
            break;
        default:
            __LOG_NO_LOCATION_META_DATA(("ERROR: policer mode [%d] was not implemented \n",
                policer_mode));
            break;
    }

}

/*******************************************************************************
*   snetLion3PolicerMeterSinglePacketTockenBucketApply
*
* DESCRIPTION:
*       Sip5 : Add logic for meter packet byte count compare and token bucket state.
*       The current state of the bucket is in the "Bucket Size0" and "Bucket Size1" fields.
*       Device updates these field automatically according to "Max Burst Size0" and "Max Burst Size1"
*       The logic is valid with assumption that single packet is used for testing.
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       direction       - ingress/egress policer direction
*       meteringDataPtr - related policer entries info pointer
*
* OUTPUT
*       qosProfileInfoPtr   - Set the value of qosProfileInfoPtr->cl
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetLion3PolicerMeterSinglePacketTokenBucketApply
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr,
    OUT SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetLion3PolicerMeterSinglePacketTokenBucketApply);

    GT_U32  entryIndex;
    GT_U32  byte_or_packet_counting_mode;
    GT_U32  bytesCount;
    GT_U32  bucket_size0,bucket_size1;
    GT_U32  rate0,rate1,rate_type0,rate_type1;
    GT_U32  max_burst_size0,max_burst_size1;
    GT_U32  policerMru;
    GT_BIT  conforming0,conforming1;
    GT_BIT  conformingFinally = 1;
    GT_U32  meteredValue;
    SNET_LION3_POLICER_METERING_MODE_ENT  policer_mode;
    GT_CHAR *conformanceNamesArr[3] = {"GREEN","YELLOW","RED"};
    GT_U32 regAddr;                     /* register address */
    GT_BIT doStatisticalMeter;/* sip 5_15 do we work with statistical metering */
    GT_U32  value;
    GT_BIT tokenBucket0MoreThanCount,tokenBucket1MoreThanCount;/* sip 5_15 : is token bucket 0,1 more than meter count for this packet */
    GT_U32  finalBucketSize0,finalBucketSize1;/* the updated value for token buckets 0,1 */
    GT_U32           *meterEntryPtr;

    /* for SIP5_15 buckets entry - not used */
    meterEntryPtr = meteringDataPtr->meterGreenBucketEntryPtr;

    if(qosProfileInfoPtr->initialDp > SKERNEL_CONFORM_RED)
    {
        skernelFatalError("snetXcatPolicerBillingCounterWrite: initialDp[%d] > [%d] \n",
            qosProfileInfoPtr->initialDp,SKERNEL_CONFORM_RED);
        return;
    }

    __LOG(("initialDp is [%s] \n",
        conformanceNamesArr[qosProfileInfoPtr->initialDp]));

    entryIndex = descrPtr->policerActuallAccessedIndex;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        policer_mode =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                entryIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E);
    }
    else
    {
        policer_mode =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,meterEntryPtr,entryIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_POLICER_MODE);
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        byte_or_packet_counting_mode  =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                entryIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE_E);
    }
    else
    {
        byte_or_packet_counting_mode  =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,meterEntryPtr,entryIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_BYTE_OR_PACKET_COUNTING_MODE);
    }

    if(byte_or_packet_counting_mode == 0/*bytes*/)
    {
        /* byte count will be calculated when needed */
        __LOG(("meter mode : working with bits per second \n"));

        __LOG(("Calc num bytes needed for [%s] purpose \n",
            "Metering Token Bucket"));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr,direction,
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_METER_ENTRY_E,
                                     meterEntryPtr,
                                     &bytesCount);

        meteredValue = bytesCount;
    }
    else
    {
        __LOG(("meter mode : working with packets per second \n"));
        meteredValue = 1;
    }

    regAddr = SMEM_XCAT_POLICER_MRU_REG(devObjPtr,descrPtr->policerCycle);
    smemRegFldGet(devObjPtr, regAddr, 0,
        SMEM_CHT_IS_SIP5_15_GET(devObjPtr) ? 32 : 16 ,
        &policerMru);

    __LOG_PARAM(policerMru);
    __LOG_PARAM(meteredValue);

    /* bucket size0-1 contain amount of allowed bytes                        */
    /* the conversion from max_bucket_size0-1 (using rate0-1 type/resolution */
    /* done at entry writing process                                         */
    bucket_size0  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1));
    bucket_size1  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1));

    rate0  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1));
    rate1  =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE1));

     rate_type0 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1));
     rate_type1 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_RATE_TYPE1));

     max_burst_size0 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1));
     max_burst_size1 =
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_MAX_BURST_SIZE1));

    __LOG_PARAM(bucket_size0);
    __LOG_PARAM(bucket_size1);

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        regAddr = SMEM_SIP5_15_POLICER_STATISTICAL_METERING_CONFIG_0_REG(devObjPtr,descrPtr->policerCycle);

        /*<Statistical_Metering_Disable>*/
        smemRegFldGet(devObjPtr, regAddr, 0 ,1 ,&value);

        doStatisticalMeter = value ? 0 : 1;

        if(doStatisticalMeter)
        {
            __LOG(("Working in statistical meter mode \n"));
            __LOG(("NOTE: 'current' conformance level is not depend on current packet count bytes/packet !!! \n"));
            __LOG(("      this is different than legacy devices \n"));

            /* 'current' conformance level is not depend on current
                packet count bytes/packet !!! */

            __LOG(("get the conformance level sign from the values restored in the memory (ignore bucket size and MRU !!!) \n"));
            tokenBucket0MoreThanCount = snetFieldValueGet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 0 ,1);
            tokenBucket1MoreThanCount = snetFieldValueGet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 1 ,1);

            __LOG(("Read Metering Conformance Level Sign Table cycle[%d] index[%d] more0[%d] more1[%d] addr[0x%X]\n",
                   descrPtr->policerCycle, descrPtr->policerActuallAccessedIndex,
                   tokenBucket0MoreThanCount, tokenBucket1MoreThanCount,
                   descrPtr->policerConformanceLevelSignEntryMemoryPtr));
        }
        else
        {
            __LOG(("Working in non statistical meter mode (BWC mode) \n"));

            __LOG(("calculate the conformance level sign according to current bucket size and MRU \n"));
            /* we need to take into account this packet count bytes/packet for
               'current' conformance level */
            tokenBucket0MoreThanCount = SIP_5_15_CONF_SIGN_CALC_WITH_BYTE_COUNT(bucket_size0,policerMru,meteredValue);
            tokenBucket1MoreThanCount = SIP_5_15_CONF_SIGN_CALC_WITH_BYTE_COUNT(bucket_size1,policerMru,meteredValue);
            __LOG_PARAM(tokenBucket0MoreThanCount);
            __LOG_PARAM(tokenBucket1MoreThanCount);
        }


        switch(policer_mode)
        {
            case SNET_LION3_POLICER_METERING_MODE_SrTCM_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF0_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF1_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF10_3_START_E:
            case SNET_LION3_POLICER_METERING_MODE_MEF10_3_NOT_START_E:
                qosProfileInfoPtr->cl =
                    SIP5_15_SR_TCM_CONF_LEVEL_GET(qosProfileInfoPtr->initialDp,
                                                    tokenBucket0MoreThanCount,
                                                    tokenBucket1MoreThanCount);
                break;
            case SNET_LION3_POLICER_METERING_MODE_TrTCM_E:
                qosProfileInfoPtr->cl =
                    SIP5_15_TR_TCM_CONF_LEVEL_GET(qosProfileInfoPtr->initialDp,
                                                    tokenBucket0MoreThanCount,
                                                    tokenBucket1MoreThanCount);
                break;
            default:
                qosProfileInfoPtr->cl = qosProfileInfoPtr->initialDp;
                __LOG(("ERROR: policer mode [%d] was not implemented \n",
                    policer_mode));
                break;
        }

        __LOG_PARAM(qosProfileInfoPtr->cl);
        __LOG(("Final Meter conformance level is [%s] \n",
            conformanceNamesArr[qosProfileInfoPtr->cl]));

        __LOG(("Calculate the needed update for the token buckets \n"));

        SCIB_SEM_TAKE;/* 'lock' for LOG purpose */

        sip5_15_calcUpdatedTokenBucket(policer_mode,
            qosProfileInfoPtr->cl,meteredValue,
            max_burst_size0,max_burst_size1,
            bucket_size0,bucket_size1,
            rate0,rate1,rate_type0,rate_type1,
            &finalBucketSize0,&finalBucketSize1);

        SCIB_SEM_SIGNAL;

        __LOG_PARAM(finalBucketSize0);
        __LOG_PARAM(finalBucketSize1);

        __LOG(("Update the meter entry with the new token buckets \n"));

        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,
            meteringDataPtr->meterGreenBucketEntryPtr,
            meteringDataPtr->meterGreenBucketEntryIndex,
            ((meteringDataPtr->meterGreenBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1),
            finalBucketSize0);

        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,
            meteringDataPtr->meterYellowBucketEntryPtr,
            meteringDataPtr->meterYellowBucketEntryIndex,
            ((meteringDataPtr->meterYellowBucketNumber == 0)
             ? SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0
             : SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1),
            finalBucketSize1);

        __LOG(("calculate updated values for entry of 'Metering Conformance Level Sign Memory' \n"));
        __LOG(("NOTE: 'Metering Conformance Level Sign Memory' token bucket compared to MRU only without current byte count \n"));
        tokenBucket0MoreThanCount = SIP_5_15_CONF_SIGN_CALC(finalBucketSize0,policerMru);
        tokenBucket1MoreThanCount = SIP_5_15_CONF_SIGN_CALC(finalBucketSize1,policerMru);

        snetFieldValueSet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 0 ,1 , tokenBucket0MoreThanCount);
        snetFieldValueSet(descrPtr->policerConformanceLevelSignEntryMemoryPtr, 1 ,1 , tokenBucket1MoreThanCount);

        __LOG(("Update Metering Conformance Level Sign Table cycle[%d] index[%d] more0[%d] more1[%d] addr[0x%X]\n",
               descrPtr->policerCycle, descrPtr->policerActuallAccessedIndex,
               tokenBucket0MoreThanCount, tokenBucket1MoreThanCount,
               descrPtr->policerConformanceLevelSignEntryMemoryPtr));

        return;
    }

    /*When the number of tokens in the bucket is less than or equal this value, a packet is marked as non-conforming.*/
    if(meteredValue >= bucket_size0)
    {
        /* to avoid (bucket_size0 - meteredValue) with negative value */
        conforming0 = 0;
    }
    else
    if(bucket_size0 > policerMru)
    {
        conforming0 = 1;
    }
    else
    {
        conforming0 = 0;
    }

    /*When the number of tokens in the bucket is less than  or equal this value, a packet is marked as non-conforming.*/
    if(meteredValue >= bucket_size1)
    {
        /* to avoid (bucket_size1 - meteredValue) with negative value */
        conforming1 = 0;
    }
    else
    if(bucket_size1 > policerMru)
    {
        conforming1 = 1;
    }
    else
    {
        conforming1 = 0;
    }

    __LOG_PARAM(conforming0);
    __LOG_PARAM(conforming1);

    /* implement the 'color blind' and the 'color aware' as single logic as the
       qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN for the 'color blind' */

    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;/* init for compiler only */
    switch(policer_mode)
    {
        case SNET_LION3_POLICER_METERING_MODE_SrTCM_E:
            __LOG(("metering mode : SrTCM \n"));
modeSrTCM_lbl:
            /* implement the 'color blind' and the 'color aware' as single logic as the
               qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN for the 'color blind' */

            /*TB (CIR, CBS) confirming AND initial color = Green?*/
            if(conforming0 &&
               qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN)
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
            }
            else
            /*TB (CIR, EBS) confirming AND initial color = Green/Yellow?*/
            if(conforming1  &&
               qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED)
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
            }
            else
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
            }

            conformingFinally = 1;

            break;
        case SNET_LION3_POLICER_METERING_MODE_TrTCM_E:
            __LOG(("metering mode : TrTCM \n"));

            /*TB (PIR, PBS) confirming AND initial color = GREEN/YELLOW?*/
            if(conforming1 &&
               qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED)
            {
                /*TB (CIR, CBS) confirming AND initial color = GREEN?*/
                if(conforming0 &&
                   qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN)
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
                }
                else
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
                }
            }
            else
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
            }

            conformingFinally = 0;

            break;
        case SNET_LION3_POLICER_METERING_MODE_MEF0_E:
            __LOG(("metering mode : MEF0 \n"));
modeMEF0_lbl:
            __LOG(("for simulation this is like SrTCM mode ! \n"));
            goto modeSrTCM_lbl;
        default:
            __LOG(("metering mode : MEF1 \n"));
            __LOG(("for simulation this is like MEF0 mode ! \n"));
            goto modeMEF0_lbl;
    }

    __LOG(("Final Meter conformance level is [%s] \n",
        conformanceNamesArr[qosProfileInfoPtr->cl]));

    /* update leaky buckets */
    if (conforming0 != 0 && (qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN))
    {
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,meterEntryPtr,entryIndex,
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE0,
            (bucket_size0 - meteredValue));
    }

    if ((conforming0 != conformingFinally) && (conforming1 != 0) &&
        (qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED))
    {
        SMEM_LION3_PLR_METERING_ENTRY_FIELD_SET(
            devObjPtr,meterEntryPtr,entryIndex,
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET_SIZE1,
            (bucket_size1 - meteredValue));
    }

    return;
}

/*******************************************************************************
*   snetXcatPolicerIpfixWaCheck
*
* DESCRIPTION:
*   32 bits counters wraparound indications and action
*
* INPUTS:
*       devObjPtr   - pointer to device object
*       descrPtr    - pointer to frame descriptor
*       counterType - IPFIX counter type
*       pcktsPtr    - pointer to 32 bit counter value
*       treshold    - 32 bit treshold value
*       action      - wrap around action: clear counter or no action
*
* OUTPUTS:
*       triggerPtr  - pointer wrap around trigger

* RETURN:
*
*******************************************************************************/
static GT_VOID snetXcatPolicerIpfixWaCheck
(
    SKERNEL_DEVICE_OBJECT * devObjPtr,
    SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    SNET_XCAT_POLICER_IPFIX_COUNT_E counterType,
    GT_U32 * pcktsPtr,
    GT_U32 treshold,
    GT_U32 action,
    GT_BOOL * triggerPtr
)
{
    DECLARE_FUNC_NAME(snetXcatPolicerIpfixWaCheck);

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        /* Save unchanged packets counter for use in workaround of erratum */
        __LOG(("Save unchanged packets counter for use in workaround of erratum"));
        descrPtr->ipfixErrataData.prevPckts[counterType] = *pcktsPtr;
    }

    /* Increment counter */
    *pcktsPtr += 1;
    /* Check treshold */
    __LOG(("Check treshold"));
    if(treshold) {
        if(*pcktsPtr >= treshold) {
           if(action) {
               /* Counter wraps around back to zero, and continues to be updated */
               __LOG(("Counter wraps around back to zero, and continues to be updated"));
               *pcktsPtr %= treshold;
           } else {
               /* Freeze the counter at the threshold value */
               __LOG(("Freeze the counter at the threshold value"));
               *pcktsPtr = treshold;

               if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
               {
                   descrPtr->ipfixErrataData.freezeCounter = counterType;
               }
           }

           *triggerPtr = GT_TRUE;
        }
    }
}

/*******************************************************************************
*   snetXcatPolicerIpfixWa64Check
*
* DESCRIPTION:
*   64 bits counters wraparound indications and action
*
* INPUTS:
*       devObjPtr   - pointer to device object
*       descrPtr    - pointer to frame descriptor
*       counterType - IPFIX counter type
*       bytesPtr    - pointer to 64 bit counter value
*       bytes       - increment value in bytes
*       tresholdPtr - pointer to 64 bit treshold value
*       action      - wrap around action: clear counter or no action
*
* OUTPUTS:
*       triggerPtr  - pointer wrap around trigger

* RETURN:
*
*******************************************************************************/
static GT_VOID snetXcatPolicerIpfixWa64Check
(
    SKERNEL_DEVICE_OBJECT * devObjPtr,
    SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    SNET_XCAT_POLICER_IPFIX_COUNT_E counterType,
    GT_U64 * bytesPtr,
    GT_U32 bytes,
    GT_U64 * tresholdPtr,
    GT_U32 action,
    GT_BOOL * triggerPtr
)
{
    DECLARE_FUNC_NAME(snetXcatPolicerIpfixWa64Check);

    GT_U64 bytes64;

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        /* Save unchanged bytes counter for use in workaround of erratum */
        __LOG(("Save unchanged bytes counter for use in workaround of erratum"));
        descrPtr->ipfixErrataData.prevBytesCnt = *bytesPtr;
    }

    CNV_U32_TO_U64(bytes, bytes64);
    /* Increment counter */
    *bytesPtr = prvSimMathAdd64(*bytesPtr, bytes64);

    /* Check treshold */
    if(tresholdPtr->l[0] || tresholdPtr->l[1]) {
        if(COMPARE_TWO_U64_VALUES_MAC(*bytesPtr, *tresholdPtr) >= 0) {
            if(action) {
                /* Low word less than subtracted one */
                __LOG(("Low word less than subtracted one"));
                if(bytesPtr->l[0] < tresholdPtr->l[0])
                {
                    /* Borrow 1 from Hi word */
                    bytesPtr->l[1] -= 1;
                    /* Subtract 1 from Lo word before inversion */
                    bytesPtr->l[0] -= 1;
                }
                bytesPtr->l[0] -= tresholdPtr->l[0];
                bytesPtr->l[1] -= tresholdPtr->l[1];

            }
            else {
                bytesPtr->l[0] = tresholdPtr->l[0];
                bytesPtr->l[1] = tresholdPtr->l[1];

                if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
                {
                    descrPtr->ipfixErrataData.freezeCounter = counterType;
                }
            }

            *triggerPtr = GT_TRUE;
        }
    }
}

/*******************************************************************************
*   snetXcatPolicerIpfixSampleValuesGet
*
* DESCRIPTION:
*       Get IPFIX sample value
*
* INPUTS:
*       entryPtr    - pointer to IPFix entry
*       dataPtr     - pointer to policer IPFix sampling related info
*
* OUTPUTS:
*       dataPtr     - pointer to policer IPFix sampling related info
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerIpfixSampleValuesGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    INOUT SNET_XCAT_POLICER_IPFIX_SAMPLE_STC * dataPtr
)
{
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        dataPtr->randomEnable =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_FLAG_E);

        dataPtr->sampleRange =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LOG_SAMPLING_RANGE_E);

        dataPtr->sampleAction =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_ACTION_E);

        dataPtr->cpuSubCode =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_CPU_SUB_CODE_E);

        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_WINDOW_E,
                    &dataPtr->sampleWindow64.l[0]);

        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E,
                    &dataPtr->lastSampleValue64.l[0]);

        dataPtr->randomOffset =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E);

    }
    else
    {
        dataPtr->randomEnable =
            SMEM_U32_GET_FIELD(entryPtr[2], 20, 1);
        dataPtr->sampleRange =
            SMEM_U32_GET_FIELD(entryPtr[2], 21, 6);
        dataPtr->sampleAction =
            SMEM_U32_GET_FIELD(entryPtr[2], 27, 1);
        dataPtr->cpuSubCode =
            SMEM_U32_GET_FIELD(entryPtr[2], 28, 2);
        dataPtr->sampleWindow64.l[0] =
            SMEM_U32_GET_FIELD(entryPtr[2], 30, 2) |
            SMEM_U32_GET_FIELD(entryPtr[3], 0, 30) << 2;
        dataPtr->sampleWindow64.l[1] =
            SMEM_U32_GET_FIELD(entryPtr[3], 30, 2) |
            SMEM_U32_GET_FIELD(entryPtr[4], 0, 2) << 2;
        dataPtr->lastSampleValue64.l[0] =
            SMEM_U32_GET_FIELD(entryPtr[4], 2, 30) |
            SMEM_U32_GET_FIELD(entryPtr[5], 0, 2) << 30;
        dataPtr->lastSampleValue64.l[1] =
            SMEM_U32_GET_FIELD(entryPtr[5], 2, 4);
        dataPtr->randomOffset =
            SMEM_U32_GET_FIELD(entryPtr[5], 6, 26) |
            SMEM_U32_GET_FIELD(entryPtr[6], 0, 6) << 26;
    }
}

/*******************************************************************************
*   snetXcatPolicerIpfixSampleValuesSet
*
* DESCRIPTION:
*       Set IPFix sampling data
*
* INPUTS:
*       entryPtr    - pointer to IPFix entry
*
* OUTPUTS:
*       dataPtr     - pointer to policer IPFix sampling related info
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerIpfixSampleValuesSet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    OUT SNET_XCAT_POLICER_IPFIX_SAMPLE_STC * dataPtr
)
{
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* only next field may actually changed */
        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_SET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_LAST_SAMPLED_VALUE_E,
                    &dataPtr->lastSampleValue64.l[0]);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,entryPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_RANDOM_OFFSET_E,
                    dataPtr->randomOffset);
    }
    else
    {
        SMEM_U32_SET_FIELD(entryPtr[2], 20, 1, dataPtr->randomEnable);
        SMEM_U32_SET_FIELD(entryPtr[2], 21, 6, dataPtr->sampleRange);
        SMEM_U32_SET_FIELD(entryPtr[2], 27, 1, dataPtr->sampleAction);
        SMEM_U32_SET_FIELD(entryPtr[2], 28, 2, dataPtr->cpuSubCode);
        SMEM_U32_SET_FIELD(entryPtr[2], 30, 2, dataPtr->sampleWindow64.l[0] & 0x3);
        SMEM_U32_SET_FIELD(entryPtr[3], 0, 30, dataPtr->sampleWindow64.l[0] >> 2);
        SMEM_U32_SET_FIELD(entryPtr[3], 30, 2, dataPtr->sampleWindow64.l[1] & 0x3);
        SMEM_U32_SET_FIELD(entryPtr[4], 0, 2,  dataPtr->sampleWindow64.l[1] >> 2);
        SMEM_U32_SET_FIELD(entryPtr[4], 2, 30, dataPtr->lastSampleValue64.l[0]);
        SMEM_U32_SET_FIELD(entryPtr[5], 0, 2,  dataPtr->lastSampleValue64.l[0] >> 30);
        SMEM_U32_SET_FIELD(entryPtr[5], 2, 4,  dataPtr->lastSampleValue64.l[1]);
        SMEM_U32_SET_FIELD(entryPtr[5], 6, 26, dataPtr->randomOffset);
        SMEM_U32_SET_FIELD(entryPtr[6], 0, 6,  dataPtr->randomOffset >> 26);
    }
}

/*******************************************************************************
*   snetXcatPolicerBillingCounterWrite
*
* DESCRIPTION:
*       Set packets/data units billing counter value
*
* INPUTS:
*       entryPtr    - pointer to policer billing counter entry
*       dp          - the packet's DP 0..2
*       dataPtr     - pointer to 64 bits increment
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerBillingCounterWrite
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    IN GT_U32   dp,
    IN GT_U64 * dataPtr
)
{
    GT_U32 startBit;

    if(dp > 2)
    {
        skernelFatalError("snetXcatPolicerBillingCounterWrite: dp[%d] > 2 \n",
            dp);
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_BILLING_ENTRY_LARGE_FIELD_SET(devObjPtr,entryPtr,
            descrPtr->countingActuallAccessedIndex,
            ((dp == 0)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E  :
             (dp == 1)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E :
                          SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E),
             &dataPtr->l[0]);
    }
    else
    {
        startBit = (dp * 42);

        snetFieldValueSet(entryPtr, startBit +  0, 32 , dataPtr->l[0]);
        snetFieldValueSet(entryPtr, startBit + 32, 10 , dataPtr->l[1]);
    }
}

/*******************************************************************************
*   snetXcatPolicerBillingCounterRead
*
* DESCRIPTION:
*       Get packets/data units billing counter value
*
* INPUTS:
*       entryPtr    - pointer to policer billing counter entry
*       dp          - the packet's DP  0..2
*       dataPtr     - pointer to 64 bits increment
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerBillingCounterRead
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * entryPtr,
    IN GT_U32 dp,
    OUT GT_U64 * dataPtr
)
{
    GT_U32 startBit;

    if(dp > 2)
    {
        skernelFatalError("snetXcatPolicerBillingCounterRead: dp[%d] > 2 \n",
            dp);
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_BILLING_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
            descrPtr->countingActuallAccessedIndex,
            ((dp == 0)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_E  :
             (dp == 1)  ? SMEM_LION3_PLR_BILLING_TABLE_FIELDS_YELLOW_COUNTER_E :
                          SMEM_LION3_PLR_BILLING_TABLE_FIELDS_RED_COUNTER_E),
             &dataPtr->l[0]);
    }
    else
    {
        startBit = (dp * 42);

        dataPtr->l[0] = snetFieldValueGet(entryPtr, startBit +  0, 32);
        dataPtr->l[1] = snetFieldValueGet(entryPtr, startBit + 32, 10);
    }
}

/*******************************************************************************
*   snetXcatPolicerMngCounterRead
*
* DESCRIPTION:
*       Get data units management counter value
*
* INPUTS:
*       entryPtr    - pointer to policer billing counter entry
*       dp          - the packet's DP
*       dataPtr     - pointer to 64 bits increment
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerMngCounterRead
(
    IN GT_U32 * entryPtr,
    IN GT_U32 dp,
    OUT GT_U64 * dataPtr
)
{
    GT_U32 startBit;
    GT_U32 multiplier = 0;

    if(dp == SKERNEL_CONFORM_GREEN){
        multiplier = 0;
    } else if(dp == SKERNEL_CONFORM_YELLOW){
        multiplier = 1;
    } else if(dp == SKERNEL_CONFORM_RED){
        multiplier = 2;
    } else if(dp == SKERNEL_CONFORM_DROP){
        multiplier = 3;
    }

    startBit = 0 + (multiplier * 128); /* 128 bits alignment */
    dataPtr->l[0] = snetFieldValueGet(entryPtr, startBit +  0, 32);
    dataPtr->l[1] = snetFieldValueGet(entryPtr, startBit + 32, 10);
}


/*******************************************************************************
*   snetXcatPolicerMngCounterWrite
*
* DESCRIPTION:
*       Set data units management counter value
*
* INPUTS:
*       entryPtr    - pointer to policer billing counter entry
*       dp          - the packet's DP
*       dataPtr     - pointer to 64 bits increment
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerMngCounterWrite
(
    IN GT_U32 * entryPtr,
    IN GT_U32 dp,
    IN GT_U64 * dataPtr
)
{
    GT_U32 startBit;
    GT_U32 multiplier = 0;

    if(dp == SKERNEL_CONFORM_GREEN){
        multiplier = 0;
    } else if(dp == SKERNEL_CONFORM_YELLOW){
        multiplier = 1;
    } else if(dp == SKERNEL_CONFORM_RED){
        multiplier = 2;
    } else if(dp == SKERNEL_CONFORM_DROP){
        multiplier = 3;
    }

    startBit = 0 + (multiplier * 128); /* 128 bits alignment */

    snetFieldValueSet(entryPtr, startBit +  0, 32 , dataPtr->l[0]);
    snetFieldValueSet(entryPtr, startBit + 32, 10 , dataPtr->l[1]);
}

/*******************************************************************************
*   snetXcatPolicerMngCounterPktIncrement
*
* DESCRIPTION:
*       Increment packets management counter value
*
* INPUTS:
*       entryPtr    - pointer to policer billing counter entry
*       dp          - the packet's DP
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerMngCounterPktIncrement
(
    IN GT_U32 *entryPtr,
    IN GT_U32 dp
)
{
    GT_U32 data;
    GT_U32 startBit;
    GT_U32 multiplier = 0;

    if(dp == SKERNEL_CONFORM_GREEN){
        multiplier = 0;
    } else if(dp == SKERNEL_CONFORM_YELLOW){
        multiplier = 1;
    } else if(dp == SKERNEL_CONFORM_RED){
        multiplier = 2;
    } else if(dp == SKERNEL_CONFORM_DROP){
        multiplier = 3;
    }

    startBit = 42 + (multiplier * 128); /* 128 bits alignment */

    data = snetFieldValueGet(entryPtr,  startBit, 32);
    data ++;/* increment the counter */
    snetFieldValueSet(entryPtr,  startBit, 32, data);
}

/*******************************************************************************
*   snetXcatPolicerIpfixCounterRead
*
* DESCRIPTION:
*       Get packets/data units IPFix counter value
*
* INPUTS:
*       entryPtr    - pointer to policer billing counter entry
*
* OUTPUTS:
*       bytesCntPtr - pointer to bytes counter value
*       packetsPtr  - pointer to good packets value
*       stampPtr    - pointer to time stamp value
*       dropsPtr    - pointer to drop packets value
*
* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerIpfixCounterRead
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32   * entryPtr,
    OUT GT_U64 * bytesCntPtr,
    OUT GT_U32 * packetsPtr,
    OUT GT_U32 * stampPtr,
    OUT GT_U32 * dropsPtr
)
{

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E,
                        &bytesCntPtr->l[0]);

        *packetsPtr = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E);

        *stampPtr = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E);

        *dropsPtr = SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,entryPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E);
    }
    else
    {
        bytesCntPtr->l[0] = entryPtr[0];
        bytesCntPtr->l[1] = SMEM_U32_GET_FIELD(entryPtr[1], 0, 4);
        *packetsPtr =
            SMEM_U32_GET_FIELD(entryPtr[1], 4, 28) |
            SMEM_U32_GET_FIELD(entryPtr[2], 0, 2) << 28;
        *stampPtr = SMEM_U32_GET_FIELD(entryPtr[2], 2, 16);
        *dropsPtr =
            SMEM_U32_GET_FIELD(entryPtr[6], 6, 26) |
            SMEM_U32_GET_FIELD(entryPtr[7], 0, 4) << 26;
    }
}

/*******************************************************************************
*   snetXcatPolicerPortPointerIndexGet
*
* DESCRIPTION:
*       devObjPtr   - pointer to device object.
*       Storm type port metering index
*
* INPUTS:
*       regValue    - value of register relate to 'port' - see Port%p and Packet Type Translation Table
*       pcktType    - packet type
*       port        - port
*
* OUTPUTS:
*
* RETURN:
*       Storm type port metering index
*
*******************************************************************************/
static GT_U32 snetXcatPolicerPortPointerIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 regValue,
    IN SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType,
    GT_U32 port
)
{
    GT_U32  offset = (pcktType*2);
    if((!SMEM_CHT_IS_SIP5_20_GET(devObjPtr)) && (port & 1))
    {
        offset += 12;
    }

    return   SMEM_U32_GET_FIELD(regValue, offset, 2);
}

/*******************************************************************************
*   snetXCatPolicerMngCounterIncrement
*
* DESCRIPTION:
*        Increment Management Counters
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       address     - billing entry address
*       dp          - counter
*       increment   - counter increment
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetXCatPolicerMngCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 address,
    IN GT_U32 dp,
    IN GT_U32 increment
)
{
    GT_U32 *regPtr;
    GT_U64 val64, increment64;

    regPtr = smemMemGet(devObjPtr, address);

    /* Increment data units counter */
    snetXcatPolicerMngCounterRead(regPtr, dp, &val64);
    CNV_U32_TO_U64(increment, increment64);
    val64 = prvSimMathAdd64(val64, increment64);
    snetXcatPolicerMngCounterWrite(regPtr, dp, &val64);

    /* Increment packets counter */
    snetXcatPolicerMngCounterPktIncrement(regPtr, dp);
}

/*******************************************************************************
*   snetXCatEgressPolicerTriggeringCheck
*
* DESCRIPTION:
*        Check if need to do policer
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       egressPort     - local egress port (not global).
*
* OUTPUT:
*       policerMeterEntryPtr  - policer metering entry pointer
*
* RETURN:
*
*******************************************************************************/
static GT_BOOL snetXCatEgressPolicerTriggeringCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 egressPort,
    OUT GT_U32 ** policerMeterEntryPtrPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerTriggeringCheck);

    GT_U32 regAddr;                     /* register address */
    GT_U32 fldValue;                    /* register entry field */
    GT_U32 policerIdx = 0;              /* policer entry offset */
    GT_U32 meterBaseAddr;               /* metering table base address */
    GT_BOOL skipPhysicalPort = GT_FALSE;

    /* initialize the trigger mode */
    __LOG(("initialize the trigger mode"));
    descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_NONE_E;
    __LOG_PARAM(descrPtr->policerTriggerMode);

    /* All packets are processed by Egress Policer for SIP5 devices */
    if(!SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if (descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
            descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
        {
            return GT_FALSE;
        }
    }

    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                descrPtr->policerCycle/*2*/);
    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fldValue);
    /* Metering Disabled */
    if(fldValue == 0)
    {
        __LOG(("Metering Globally Disabled \n"));
        return GT_FALSE;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if(GT_TRUE == snetLion2PolicerEArchIndexGet(devObjPtr, descrPtr,
                                      SMAIN_DIRECTION_EGRESS_E, 0 , &policerIdx))
        {
            /* the eport/evlan/ flow needs metering/counting */
            if (descrPtr->policerTriggerMode == SKERNEL_POLICER_TRIGGER_MODE_NONE_E)
            {
                /* although eport/evlan used , still forced 'no merer' */
                __LOG(("when eArch (eport/evlan metering is used , then the per physical port registers are not used"));
                return GT_FALSE;
            }

            if(descrPtr->policerActuallAccessedIndex == SMAIN_NOT_VALID_CNS)
            {
                /* restore to 0 , so no indication in the LOG */
                descrPtr->policerActuallAccessedIndex = 0;
                __LOG(("Counting only , Metering not needed \n"));

                return GT_FALSE;
            }

            /* from here we need to check the 'physical port' logic */
            skipPhysicalPort = GT_TRUE;
        }

        descrPtr->policerActuallAccessedIndex = 0;
    }

    if(skipPhysicalPort == GT_FALSE)
    {
        regAddr = SMEM_CHT3_POLICER_PORT_METER_REG(devObjPtr,
            descrPtr->policerCycle/*2*/ ,egressPort);
        smemRegFldGet(devObjPtr, regAddr, egressPort % 32, 1, &fldValue);
        if (fldValue)
        {
            /* state the trigger was by 'port mode' */
            __LOG(("state the trigger was by 'port mode'"));
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_PORT_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);

            /* Per port - First 28 policers can be triggered per port configuration */
            __LOG(("Per port - First 28 policers can be triggered per port configuration"));
            policerIdx = egressPort;
        }
        else
        {
            /* PCL trigger */
            __LOG(("PCL trigger"));
            if (descrPtr->policerEgressEn == 0)
            {
                return GT_FALSE;
            }

            /* state the trigger was by 'flow mode' */
            __LOG(("state the trigger was by 'flow mode'"));
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_FLOW_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
        }

        snetXCatPolicerOverrideMeterIndex(devObjPtr, descrPtr,
                                          SMAIN_DIRECTION_EGRESS_E, &policerIdx);
    }

    if (descrPtr->policerTriggerMode == SKERNEL_POLICER_TRIGGER_MODE_NONE_E)
    {
        return GT_FALSE;
    }

    descrPtr->policerActuallAccessedIndex = policerIdx;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        /* metering base address is used to get absolute index in memory starting from SIP 5.15 (BobK).*/

        /* read metering base address */
        smemRegFldGet(devObjPtr,
                      SMEM_LION3_POLICER_METERING_BASE_ADDR_REG(devObjPtr, descrPtr->policerCycle),
                      0, 24, &meterBaseAddr);

         policerIdx += meterBaseAddr;
         __LOG(("Use metering memory of EPLR index %d\n", policerIdx));
    }

    regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM(devObjPtr,SMAIN_DIRECTION_EGRESS_E,
                descrPtr->policerCycle/*2*/ ,policerIdx);

    /* Copy Policer Table entry to buffer */
    (*policerMeterEntryPtrPtr) = smemMemGet(devObjPtr, regAddr);

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(devObjPtr, descrPtr->policerCycle/*2*/, policerIdx);
        /* Get Policer config Table entry to buffer */
        descrPtr->policerMeterConfigEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

        regAddr = SMEM_SIP5_15_POLICER_METERING_CONFORMANCE_LEVEL_SIGN_TBL_MEM(devObjPtr, descrPtr->policerCycle/*2*/, policerIdx);
        /* Get Policer Metering Conformance Level Sign Table entry to buffer */
        descrPtr->policerConformanceLevelSignEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);
    }


    return GT_TRUE;
}

/*******************************************************************************
*   snetXCatCommonPolicerMeteringEnvelopeDataGet
*
* DESCRIPTION:
*        Get metering data for envelope of entries
*        Relevant for both ingeress and egress policer.
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       policerMeterEntryPtr - pointer to Policers Metering Entry
*
* OUTPUT:
*       meteringDataPtr  - (pointer to) metering data
*
* RETURN:
*
*
*******************************************************************************/
GT_STATUS snetXCatCommonPolicerMeteringEnvelopeDataGet
(
    IN  SKERNEL_DEVICE_OBJECT                *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC      *descrPtr,
    IN  GT_U32                               *policerMeterEntryPtr,
    OUT SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatCommonPolicerMeteringEnvelopeDataGet);

    GT_U32 regAddr;
    GT_U32 policerIndex;
    GT_U32 policerStep;
    GT_U32 *policerBase;
    GT_U32 priorityAccessBase;
    GT_U32 flowBaseMask;
    GT_U32 envelopeBaseIndex;
    GT_U32 packetRank; /*rank range 0-7*/
    GT_U32 qosProfileIndex;
    GT_U32 val;
    GT_U32 *meterCfgEntryPtr;
    GT_U32 *meterBucketEntryPtr;
    GT_U32 policer_mode;
    GT_U32 envelopeSize;
    GT_U32 i, bucketColor, bucketRank;
    GT_BOOL greenFound, yellowFound;
    GT_U32 meterMemoryCycle;            /* policer stage for meter tables access */


    /* init to be overriden */
    memset(meteringDataPtr, 0, sizeof(SNET_LION3_POLICER_METERING_DATA_STC));
    meteringDataPtr->valid = GT_FALSE;

    if(! SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        __LOG(("device in not SIP5_15\n"));
        return GT_FAIL;
    }
    if (policerMeterEntryPtr == NULL)
    {
        __LOG(("Trigger for metering not found: policerMeterConfigEntryMemoryPtr == NULL\n"));
        return GT_FAIL;
    }

    /*  Meter memories became shared between IPLR0 and IPLR1 starting from SIP 5.15 (BobK).
        Direct access done through IPLR0.
        Use IPLR0 unit for meter memories access for IPLR1 processing */
    meterMemoryCycle = (descrPtr->policerCycle == 1) ? 0 : descrPtr->policerCycle;
    __LOG(("Use metering memory of PLR[%d]\n", meterMemoryCycle));

    regAddr =
        SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
            devObjPtr, meterMemoryCycle, 0 /*policerIdx*/);
    policerBase = (GT_U32*)smemMemGet(devObjPtr, regAddr);
    regAddr =
        SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
            devObjPtr, meterMemoryCycle, 1 /*policerIdx*/);
    policerStep = /* address difference in words */
        (GT_U32*)smemMemGet(devObjPtr, regAddr) - (GT_U32*)policerBase;
    policerIndex =
        (policerMeterEntryPtr - policerBase) / policerStep;

    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->
        PLR[descrPtr->policerCycle].meteringAddressingModeConfiguration0;
    smemRegGet(devObjPtr, regAddr, &val);
    priorityAccessBase = (val & 0x1FFFF);

    regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->
        PLR[descrPtr->policerCycle].meteringAddressingModeConfiguration1;
    smemRegGet(devObjPtr, regAddr, &val);
    flowBaseMask = (val & 0x1FFFF);

    if (policerIndex < priorityAccessBase)
    {
        /* flow based access */
        envelopeBaseIndex = policerIndex & flowBaseMask;
        packetRank        = policerIndex - envelopeBaseIndex;
    }
    else
    {
        /* priority based access */
        envelopeBaseIndex = policerIndex;
        regAddr = SMEM_CHT_MAC_REG_DB_SIP5_GET(devObjPtr)->PLR[descrPtr->policerCycle].
            qosProfileToPriority_tab;
        qosProfileIndex = descrPtr->qos.qosProfile;
        smemRegGet(devObjPtr, (regAddr + (4 * (qosProfileIndex / 8))), &val);
        packetRank = ((val >> (qosProfileIndex % 8)) & 0x0F);
    }
    meteringDataPtr->envelopeBaseIndex = envelopeBaseIndex;
    meteringDataPtr->packetRank = packetRank;
    regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(
        devObjPtr, meterMemoryCycle, envelopeBaseIndex);
    meterCfgEntryPtr = smemMemGet(devObjPtr, regAddr);

    regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(
        devObjPtr, meterMemoryCycle, (envelopeBaseIndex + packetRank));
    meteringDataPtr->meterCfgEntryPtr = smemMemGet(devObjPtr, regAddr);

    policer_mode =
        SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
            meterCfgEntryPtr,
            envelopeBaseIndex,
            SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E);
    if (policer_mode != SNET_LION3_POLICER_METERING_MODE_MEF10_3_START_E)
    {
        __LOG(("Base metering CFG entry mode is not MEF10_3_START\n"));
        return GT_FAIL;
    }

    envelopeSize =
        SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
            meterCfgEntryPtr,
            envelopeBaseIndex,
            SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MEF_10_3_ENV_SIZE_E);
    meteringDataPtr->envelopeSize = (envelopeSize + 1);
    if (envelopeSize < packetRank)
    {
        __LOG(("Packet runk more then envelope size\n"));
        return GT_FAIL;
    }

    if (packetRank != 0)
    {
        policer_mode =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                meteringDataPtr->meterCfgEntryPtr,
                (envelopeBaseIndex + packetRank),
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_POLICER_MODE_E);
        if (policer_mode != SNET_LION3_POLICER_METERING_MODE_MEF10_3_NOT_START_E)
        {
            __LOG(("Packet rank!= 0 metering CFG entry mode is not MEF10_3_NOT_START\n"));
            return GT_FAIL;
        }
    }

    /* each PLR unit has it's own instance of the sign table */
    regAddr = SMEM_SIP5_15_POLICER_METERING_CONFORMANCE_LEVEL_SIGN_TBL_MEM(
        devObjPtr, descrPtr->policerCycle, (envelopeBaseIndex + packetRank));
    meteringDataPtr->meterConformSignLevelPtr = smemMemGet(devObjPtr, regAddr);

    greenFound  = GT_FALSE;
    yellowFound = GT_FALSE;
    for (i = 0; (i <= envelopeSize); i++)
    {
        regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
            devObjPtr, meterMemoryCycle, (envelopeBaseIndex + i));
        meterBucketEntryPtr = smemMemGet(devObjPtr, regAddr);

        /* bucket 0 */
        bucketRank = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_RANK);
        if (bucketRank == packetRank)
        {
            bucketColor = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
                devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET0_COLOR);
            if (bucketColor == 0)
            {
                /* green */
                if (greenFound != GT_FALSE)
                {
                    __LOG(("duplicate green bucket of the same range, ignored\n"));
                }
                else
                {
                    greenFound = GT_TRUE;
                    meteringDataPtr->meterGreenBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterGreenBucketNumber = 0;
                    meteringDataPtr->meterGreenBucketEntryPtr = meterBucketEntryPtr;
                }
            }
            else
            {
                /* yellow */
                if (yellowFound != GT_FALSE)
                {
                    __LOG(("duplicate yellow bucket of the same range, ignored"));
                }
                else
                {
                    yellowFound = GT_TRUE;
                    meteringDataPtr->meterYellowBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterYellowBucketNumber = 0;
                    meteringDataPtr->meterYellowBucketEntryPtr = meterBucketEntryPtr;
                }
            }
        }

        /* bucket 1 */
        bucketRank = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
            devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
            SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_RANK);
        if (bucketRank == packetRank)
        {
            bucketColor = SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(
                devObjPtr, meterBucketEntryPtr, (envelopeBaseIndex + i),
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_BUCKET1_COLOR);
            if (bucketColor == 0)
            {
                /* green */
                if (greenFound != GT_FALSE)
                {
                    __LOG(("duplicate green bucket of the same range, ignored"));
                }
                else
                {
                    greenFound = GT_TRUE;
                    meteringDataPtr->meterGreenBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterGreenBucketNumber = 1;
                    meteringDataPtr->meterGreenBucketEntryPtr = meterBucketEntryPtr;
                }
            }
            else
            {
                /* yellow */
                if (yellowFound != GT_FALSE)
                {
                    __LOG(("duplicate yellow bucket of the same range, ignored"));
                }
                else
                {
                    yellowFound = GT_TRUE;
                    meteringDataPtr->meterYellowBucketEntryIndex = (envelopeBaseIndex + i);
                    meteringDataPtr->meterYellowBucketNumber = 1;
                    meteringDataPtr->meterYellowBucketEntryPtr = meterBucketEntryPtr;
                }
            }
        }

        if ((greenFound != GT_FALSE) && (yellowFound != GT_FALSE))
        {
            break;
        }
    }

    if ((greenFound == GT_FALSE) || (yellowFound == GT_FALSE))
    {
        __LOG(("Not both buckets for packet rank found\n"));
        return GT_FAIL;
    }

    meteringDataPtr->valid = GT_TRUE;

    __LOG(("---meteringData: cycle[%d]", descrPtr->policerCycle));
    __LOG(("---meteringData: envelop size[%d] base[%d] packetRank[%d] greenBucket[%d/%d] yellowBucket[%d/%d]\n",
           meteringDataPtr->envelopeSize, meteringDataPtr->envelopeBaseIndex,
           meteringDataPtr->packetRank,
           meteringDataPtr->meterGreenBucketEntryIndex, meteringDataPtr->meterGreenBucketNumber,
           meteringDataPtr->meterYellowBucketEntryIndex, meteringDataPtr->meterYellowBucketNumber));

    __LOG(("---meteringData: descrPtr->policerMeterConfigEntryMemoryPtr old[0x%X] new[0x%X]\n",
           descrPtr->policerMeterConfigEntryMemoryPtr,
           meteringDataPtr->meterCfgEntryPtr));
    __LOG(("---meteringData: descrPtr->policerConformanceLevelSignEntryMemoryPtr old[0x%X] new[0x%X]\n",
           descrPtr->policerConformanceLevelSignEntryMemoryPtr,
           meteringDataPtr->meterConformSignLevelPtr));
    __LOG(("---meteringData: descrPtr->policerActuallAccessedIndex old[%d] new[%d]\n",
           descrPtr->policerActuallAccessedIndex,
           (meteringDataPtr->envelopeBaseIndex + meteringDataPtr->packetRank)));

    return GT_OK;
}

/*******************************************************************************
*   snetXCatCommonPolicerMeteringSingleDataGet
*
* DESCRIPTION:
*        Get metering data for single entry.
*        Relevant for both ingeress and egress policer.
*
* INPUTS:
*       devObjPtr            - pointer to device object.
*       descrPtr             - frame data buffer Id
*       policerMeterEntryPtr - pointer to Policers Metering Entry
*
* OUTPUT:
*       meteringDataPtr  - (pointer to) metering data
*
* RETURN:
*
*
*******************************************************************************/
GT_VOID snetXCatCommonPolicerMeteringSingleDataGet
(
    IN  SKERNEL_DEVICE_OBJECT                *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC      *descrPtr,
    IN  GT_U32                               *policerMeterEntryPtr,
    OUT SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatCommonPolicerMeteringSingleDataGet);
    GT_U32 meterMemoryCycle;            /* policer stage for meter tables access */
    GT_U32 regAddr;
    GT_U32 policerIndex;
    GT_U32 policerStep;
    GT_U32 *policerBase;

    __LOG(("Building metering data for single entry\n"));

    memset(meteringDataPtr, 0, sizeof(SNET_LION3_POLICER_METERING_DATA_STC));
    if (policerMeterEntryPtr == NULL)
    {
        meteringDataPtr->valid = GT_FALSE;
        return;
    }
    meteringDataPtr->valid = GT_TRUE;

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        /*  Meter memories became shared between IPLR0 and IPLR1 starting from SIP 5.15 (BobK).
            Direct access done through IPLR0.
            Use IPLR0 unit for meter memories access for IPLR1 processing */
         meterMemoryCycle = (descrPtr->policerCycle == 1) ? 0 : descrPtr->policerCycle;
    }
    else
    {
        meterMemoryCycle = descrPtr->policerCycle;
    }
    __LOG(("Use metering memory of PLR[%d]\n", meterMemoryCycle));

    regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
        devObjPtr, meterMemoryCycle, 0 /*policerIdx*/);
    policerBase = smemMemGet(devObjPtr, regAddr);
    regAddr = SMEM_XCAT_POLICER_METER_ENTRY_TBL_MEM_ANY(
        devObjPtr, meterMemoryCycle, 1 /*policerIdx*/);
    policerStep = /* address difference in words */
        (GT_U32*)smemMemGet(devObjPtr, regAddr) - (GT_U32*)policerBase;
    policerIndex =
        (policerMeterEntryPtr - (GT_U32*)policerBase)
        / policerStep;

    meteringDataPtr->envelopeSize = 1;
    meteringDataPtr->envelopeBaseIndex = policerIndex;
    meteringDataPtr->packetRank = 0;
    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        regAddr = SMEM_SIP5_15_POLICER_METERING_CONFORMANCE_LEVEL_SIGN_TBL_MEM(
            devObjPtr, descrPtr->policerCycle, policerIndex);
        meteringDataPtr->meterConformSignLevelPtr = smemMemGet(devObjPtr, regAddr);
        regAddr = SMEM_SIP5_15_POLICER_CONFIG_ENTRY_TBL_MEM(
            devObjPtr, meterMemoryCycle, policerIndex);
        meteringDataPtr->meterCfgEntryPtr = smemMemGet(devObjPtr, regAddr);
    }
    else
    {
        meteringDataPtr->meterConformSignLevelPtr = NULL;
        meteringDataPtr->meterCfgEntryPtr = NULL;
    }
    meteringDataPtr->meterGreenBucketNumber = 0;
    meteringDataPtr->meterGreenBucketEntryIndex = policerIndex;
    meteringDataPtr->meterGreenBucketEntryPtr = policerMeterEntryPtr;
    meteringDataPtr->meterYellowBucketNumber = 1;
    meteringDataPtr->meterYellowBucketEntryIndex = policerIndex;
    meteringDataPtr->meterYellowBucketEntryPtr = policerMeterEntryPtr;
}

/*******************************************************************************
*   snetXCatPolicerMeterExecute
*
* DESCRIPTION:
*        Execute metering algorithm and get conformance level
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       descrPtr            - frame data buffer Id
*       policerMeterEntryPtr      - policer entry pointer
*
* OUTPUT:
*       qosProfileInfoPtr   - pointer to qos profile info
*                             for out-of-profile traffic
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerMeterExecute
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * policerMeterEntryPtr,
    OUT SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerMeterExecute);

    GT_U32 colorMode;                   /* Color Mode:
                                           0 = Color Blind, 1 = Color Aware */
    GT_U32 meteringAlgorithm;           /* Metering Algorithm:
                                           0 = SrTCM, 1 = TrTCM*/

    /*NOTE : sip5 not reach here*/
    colorMode = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 2, 1);
    meteringAlgorithm = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 3, 1);

    if (meteringAlgorithm)
    {
        __LOG(("Two-rate Three Color Marking \n"));
        if (colorMode)
        { /* Color Aware */
            /* TB (PIR, EBS) confirming AND initial color = GREEN/YELLOW?*/
            if ((skernelUserDebugInfo.policerConformanceLevel != SKERNEL_CONFORM_RED) &&
                (qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED))
            {
                /* TB (CIR, CBS) confirming AND initial color = GREEN? */
                if ((skernelUserDebugInfo.policerConformanceLevel == SKERNEL_CONFORM_GREEN) &&
                    (qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN))
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
                }
                else
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
                }
            }
            else
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
            }
        }
        else
        { /* Color Blind */
            qosProfileInfoPtr->cl = skernelUserDebugInfo.policerConformanceLevel;
        }
    }
    else
    {
        __LOG(("Single-rate Three Color Marking \n"));
        if (colorMode)
        { /* Color Aware */
            /* TB (CIR, CBS) confirming Mark GREEN AND initial color = GREEN? */
            if ((skernelUserDebugInfo.policerConformanceLevel == SKERNEL_CONFORM_GREEN) &&
                (qosProfileInfoPtr->initialDp == SKERNEL_CONFORM_GREEN))
            {
                qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;
            }
            else
            {
                /* TB (CIR, EBS) confirming AND initial color = GREEN/YELLOW? */
                if ((skernelUserDebugInfo.policerConformanceLevel == SKERNEL_CONFORM_YELLOW) &&
                    (qosProfileInfoPtr->initialDp != SKERNEL_CONFORM_RED))
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_YELLOW;
                }
                else
                {
                    qosProfileInfoPtr->cl = SKERNEL_CONFORM_RED;
                }
            }
        }
        else
        { /* Color Blind */
            qosProfileInfoPtr->cl = skernelUserDebugInfo.policerConformanceLevel;
        }
    }

    if(colorMode)
    {
        __LOG(("Color Aware \n"));
        __LOG_PARAM(qosProfileInfoPtr->initialDp);
    }
    else
    {
        __LOG(("Color Blind \n"));
    }
    __LOG_PARAM(skernelUserDebugInfo.policerConformanceLevel);

    __LOG(("Final Conformance level decision: \n"));
    __LOG_PARAM(qosProfileInfoPtr->cl);

}

/*******************************************************************************
*   snetXCatEgressPolicerConformanceLevelGet
*
* DESCRIPTION:
*        Get conformance level and QoSProfile for out-of-profile traffic
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       descrPtr            - frame data buffer Id
*       meteringDataPtr     - related policer entries info pointer
*
* OUTPUT:
*       qosProfileInfoPtr   - pointer to qos profile info
*                             for out-of-profile traffic
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatEgressPolicerConformanceLevelGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SNET_LION3_POLICER_METERING_DATA_STC *meteringDataPtr,
    OUT SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerConformanceLevelGet);

    GT_U32 fldValue;                    /* register's entry field */
    GT_U32 regAddr;                     /* register's address */
    GT_U32 * regPtr;                    /* register's entry pointer */
    GT_U32 word, offset;
    GT_U32 * policerMeterEntryPtr;      /* pointer to metering entry */

    /* for SIP5_15 buckets entry - not used */
    policerMeterEntryPtr = meteringDataPtr->meterGreenBucketEntryPtr;

    /* Set init values */
    memset(qosProfileInfoPtr, 0, sizeof(SNET_CHT3_POLICER_QOS_INFO_STC));

    /* check QoS model of EPLR in the Policer Control0, bit 21 Qos Model */
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                 descrPtr->policerCycle/*2*/);
    smemRegFldGet(devObjPtr, regAddr, 21, 1, &fldValue);
    if(fldValue != 0)
    {   /* the ERLR must work with Full QoS parameters */
        skernelFatalError("snetXCatEgressPolicerConformanceLevelGet: QoS Model is wrong");
        return;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if(descrPtr->qos.ingressExtendedMode)
        {
            __LOG(("EPLR QoS profile to initial DP table is skipped in extended QoS mode"));
            qosProfileInfoPtr->initialDp = descrPtr->dp;
            qosProfileInfoPtr->tc        = descrPtr->tc;
        }
        else
        {
            /* Intial DP */
            regAddr =
                SMEM_CHT3_POLICER_INITIAL_DP_REG(devObjPtr, descrPtr->policerCycle , 0);
            regPtr = smemMemGet(devObjPtr, regAddr);
            /* get the 2 bits that associated with the QOS profile index */
            qosProfileInfoPtr->initialDp = snetFieldValueGet(regPtr, 2 * descrPtr->qos.qosProfile, 2);
            /* logic for TC unknown yet */
            qosProfileInfoPtr->tc = 0;
        }
    }
    else
    {
        /* ERLR gets DP from EPCL, EPCL get DP from QosProfile to DP Register<%n> */
        regAddr = SMEM_XCAT_HA_QOS_PROFILE_TO_DP_REG(devObjPtr);
        regPtr = smemMemGet(devObjPtr, regAddr);
        word = descrPtr->qos.qosProfile / 16;
        offset = descrPtr->qos.qosProfile % 16;

        qosProfileInfoPtr->initialDp =
            SMEM_U32_GET_FIELD(regPtr[word], 2 * offset, 2);

        descrPtr->dp = qosProfileInfoPtr->initialDp;
        /* ERLR gets TC from EPCL, but EPCL use constant 0.
           The Egress remarking by TC does not works. */
        qosProfileInfoPtr->tc = 0;
    }

    /* set conformance level to be green for not metered packets */
    __LOG(("set conformance level to be green for not metered packets"));
    qosProfileInfoPtr->cl = SKERNEL_CONFORM_GREEN;

    if(policerMeterEntryPtr == NULL)
    {
        return;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_COLOR_MODE_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_COLOR_MODE);

    }
    else
    {
        fldValue = SNET_CHT3_POLICER_COLOR_MODE_GET_MAC(devObjPtr, policerMeterEntryPtr);
    }

    if (fldValue == 0)
    {
        /* When color blind we are always GREEN */
        __LOG(("Color Mode : BLIND : When color blind we are always GREEN \n"));
        qosProfileInfoPtr->initialDp = SKERNEL_CONFORM_GREEN;
    }
    else
    {
        __LOG(("Color Mode : AWARE \n"));
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* do simple 'Token bucket' for current packet , without considering
           time/other previous packets */
        snetLion3PolicerMeterSinglePacketTokenBucketApply(devObjPtr, descrPtr,
                                      SMAIN_DIRECTION_EGRESS_E,
                                      meteringDataPtr,
                                      qosProfileInfoPtr);
    }
    else
    {
        /* execute metering and get final conformance level */
        __LOG(("execute metering and get final conformance level"));
        snetXCatPolicerMeterExecute(devObjPtr, descrPtr, policerMeterEntryPtr,
                                    qosProfileInfoPtr);
    }
}

/*******************************************************************************
*   snetXCatEgressPolicerCountersUpdate
*
* DESCRIPTION:
*        Count the bytes of packets in the policer
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       descrPtr            - frame data buffer Id
*       policerMeterEntryPtr      - policer entry pointer
*       forward                   - GT_TRUE - forward, GT_FALSE - drop packet
*       qosProfileInfoPtr         - QoS info pointer
*       egressPort          - egress port.
*
*
* OUTPUT:
*       mngCountDataPtr     - management counters data pointer
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatEgressPolicerCountersUpdate
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_BOOL forward,
    IN SNET_CHT3_POLICER_QOS_INFO_STC   * qosProfileInfoPtr,
    IN GT_U32 egressPort,
    OUT SNET_CHT3_POLICER_MNG_COUNT_STC * mngCountDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerCountersUpdate);

    GT_U32 fldValue;                    /* register's entry field */
    GT_U32 fldOffset;                   /* register field offset */
    GT_U32 regAddr;                     /* register's address */
    GT_U32 bytesCount = 0;              /* number of bytes in packet */
    GT_U32 unitSizeCount;               /* number of unit size to add to counter */
    GT_U32 * policerCtrlRegPtr;         /* egress policer control data */
    GT_U32 mngCntrDp;                   /* management counter dp */

    policerCtrlRegPtr =
        smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle/*2*/));

    /* Increment Policer Billing/Policy/VLAN Counters */
    __LOG(("Increment Policer Billing/Policy/VLAN Counters"));
    snetXCatPolicerCounterIncrement(devObjPtr, descrPtr,
                                SMAIN_DIRECTION_EGRESS_E,
                                policerCtrlRegPtr, policerMeterEntryPtr,
                                egressPort,
                                qosProfileInfoPtr->cl,
                                &bytesCount);

    if(policerMeterEntryPtr == 0)
    {
        return;
    }

    /* Set number 0-2 and enable of the Management Counters */
    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        mngCountDataPtr->countSet =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_MG_COUNTERS_SET_EN_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        mngCountDataPtr->countSet =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_MG_COUNTERS_SET_EN);
    }
    else
    {
        mngCountDataPtr->countSet = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 4, 2);
    }

    if (mngCountDataPtr->countSet != SNET_CHT3_MNG_SET_DISABLE_E)
    {
        fldOffset =
            SNET_CHT3_POLICER_MNG_COUNT_FLD_OFFSET_GET_MAC(mngCountDataPtr->countSet);

        mngCountDataPtr->countScale =
            SMEM_U32_GET_FIELD(*policerCtrlRegPtr, fldOffset, 1);

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* byte count will be calculated when needed */
            __LOG(("Calc num bytes needed for [%s] purpose \n",
                "Management counters"));
            snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr,SMAIN_DIRECTION_EGRESS_E,
                                         SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E,
                                         NULL,
                                         &bytesCount);
        }

        mngCountDataPtr->countByteSize = bytesCount;

        /* Convert byte size to acceptable counter resolution 1 byte/16 byte */
        __LOG(("Convert byte size to acceptable counter resolution 1 byte/16 byte"));
        unitSizeCount = SNET_CHT3_PCKT_SIZE_RESOLVE(mngCountDataPtr->countByteSize,
                                                    mngCountDataPtr->countScale);
        /* Update management counter table */
        __LOG(("Update management counter table"));
        regAddr = SMEM_XCAT_POLICER_MNG_CNT_TBL_MEM(devObjPtr,descrPtr->policerCycle/*2*/,
                                                        mngCountDataPtr->countSet);
        if (forward == GT_FALSE)
        {
            mngCntrDp = SKERNEL_CONFORM_DROP;
        }
        else
        {
            /* Increment Green/Yellow/Red counters based on packets
              conformance level or DP. Selection between DP and CL is based
              on a <Counter Color Mode> configuration in the Policer Control0
              Register */
            fldValue = SNET_XCAT_POLICER_COUNT_COLOR_MODE_GET_MAC(policerCtrlRegPtr);
            mngCntrDp = (fldValue) ? descrPtr->dp : qosProfileInfoPtr->cl;
        }

        snetXCatPolicerMngCounterIncrement(devObjPtr, regAddr, mngCntrDp,
                                           unitSizeCount);
    }
}

/*******************************************************************************
*   snetXCatEgressPolicerQosRemark
*
* DESCRIPTION:
*        remark QoS parameters - only for out-of-profile traffic !!!
*        Out-of-profile packets are subject to out-of-profile commands
*        and may be discarded or have their packet QoS information remarked.
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       descrPtr            - frame data buffer Id
*       policerMeterEntryPtr      - policer entry pointer
*       qosProfileInfoPtr   - qos profile (index) for out-of-profile traffic
*       mngCountDataPtr     - management counters data pointer
*
* RETURN:
*      GT_TRUE  - do not drop packet
*      GT_FALSE - meter decision is Drop packet
*
*******************************************************************************/
static GT_BOOL snetXCatEgressPolicerQosRemark
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * policerMeterEntryPtr,
    IN SNET_CHT3_POLICER_QOS_INFO_STC * qosProfileInfoPtr,
    IN SNET_CHT3_POLICER_MNG_COUNT_STC * mngCountDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicerQosRemark);

    GT_U32 fldValue;                    /* register's entry field */
    GT_U32 regAddr;                     /* Register address */
    GT_U32 *regPtr;                     /* pointer to memory of register */
    GT_U32 entryIndex;                  /* remarking table entry index */
    GT_U32 startBit;                    /* start bit of entry in the memory */
    GT_U32 entry;                       /* remarking entry */
    struct _TMP_REMARK_STC{
        GT_U32  tc;
        GT_U32  dp;
        GT_U32  dscp;
        GT_U32  up;
        GT_U32  exp;
    }remark;

    /* make remarking for metered packets only */
    if(policerMeterEntryPtr == 0)
    {
        __LOG(("no remarking for non metered packets \n"));
        return GT_TRUE;
    }

    /* check remarking for Green packet */
    __LOG(("check remarking for Green packet"));
    if (qosProfileInfoPtr->cl == SKERNEL_CONFORM_GREEN)
    {
        /* check Enable Qos updated for conforming packets */
        smemRegFldGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle/*2*/),
                      31, 1, &fldValue);
        if (fldValue == 0)
        {
            /* there is no remarking for conforming packets */
            __LOG(("there is no remarking for conforming packets \n"));
            return GT_TRUE;
        }
        __LOG(("there is remarking for conforming packets \n"));
    }
    else
    {
         /* check Drop Red in the MX Non Conforming Packet Command */
        if (qosProfileInfoPtr->cl == SKERNEL_CONFORM_RED)
        {
            if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
            {
                fldValue =
                    SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                        descrPtr->policerMeterConfigEntryMemoryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_DROP_RED_E);
            }
            else
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                fldValue =
                    SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_DROP_RED);
            }
            else
            {
                fldValue = (SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 23, 1));
            }


            if (fldValue)
            {
                __LOG(("Drop Red in the Non Conforming Packet Command"));
                return GT_FALSE;
            }
        }
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_REMARK_MODE_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_REMARK_MODE);
    }
    else
    {
        fldValue = SMEM_U32_GET_FIELD(policerMeterEntryPtr[6], 22, 1);
    }


    /* select remarking table */
    /* Is packet IP or MPLS  AND <IP/MPLS RemarkMode> == L3*/
    if ((descrPtr->isIp || descrPtr->mpls) &&
        (fldValue))
    {
        /* Is packet IP?*/
        if (descrPtr->isIp)
        {
            /* use {DSCP,CL} remarking table */
            entryIndex = descrPtr->dscp;
            __LOG(("packet IP use DSCP[%d] \n",
                entryIndex));
        }
        else
        {
            /* use {EXP,CL} remarking table */
            entryIndex = descrPtr->exp1 + 64;
            __LOG(("packet MPLS use exp1[%d]+ 64 = [%d] \n",
                descrPtr->exp1,
                entryIndex));
        }
    }
    else
    {
        /* check <L2RemarkModel> in the Policer Control0 Register */
        smemRegFldGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,descrPtr->policerCycle/*2*/),
                      18, 1, &fldValue);

        if (fldValue == 0)
        {
            /* Access to L2 remarking table is based on
             {Conformance Level, Traffic Class}.*/
            entryIndex = qosProfileInfoPtr->tc + 72;
            __LOG(("use tc[%d]+ 72 = [%d] \n",
                qosProfileInfoPtr->tc,
                entryIndex));
        }
        else
        {
            /* Access to L2 remarking table is based on
             {Conformance Level, User Priority}.*/
            entryIndex = descrPtr->up + 72;
            __LOG(("use up[%d]+ 72 = [%d] \n",
                descrPtr->up,
                entryIndex));
        }
    }

    /* get remarking entry for conformance level */
    __LOG(("get remarking entry for conformance level"));
    regAddr = SMEM_CHT_POLICER_QOS_TBL_MEM(devObjPtr,descrPtr->policerCycle/*2*/,entryIndex);
    regPtr = smemMemGet(devObjPtr, regAddr);
    startBit = qosProfileInfoPtr->cl * SNET_XCAT_POLICER_EGR_REMARK_ENTRY_SIZE_CNS;
    entry = snetFieldValueGet(regPtr, startBit,
                              SNET_XCAT_POLICER_EGR_REMARK_ENTRY_SIZE_CNS);

    remark.tc   = (entry >> 8) & 0x7;
    remark.dp   = (entry >> 6) & 0x3;
    remark.dscp = entry & 0x3f;
    remark.up   = (entry >> 11) & 0x7;
    remark.exp  = (entry >> 14) & 0x7;


    /* DSCP for IP packets only and if MX En Modify DSCP is 1 */
    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DSCP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 217, 1);
    }

    if (fldValue)
    {
        /* perform remarking of DSCP, UP and DP */
        __LOG(("Enable modify DSCP , new DSCP[%d]\n ",
            remark.dscp));

        descrPtr->eplrAction.dscp = remark.dscp;
        descrPtr->eplrAction.modifyDscp = fldValue;

        descrPtr->dscp = descrPtr->eplrAction.dscp;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_UP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_UP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 219, 1);
    }

    if (fldValue)
    {
        /* UP if MX En Modify UP is 1 */
        __LOG(("Enable modify UP mode [%d] , new UP[%d]\n ",
            fldValue,remark.up));

        descrPtr->eplrAction.up = remark.up;
        descrPtr->eplrAction.modifyUp = fldValue;

        descrPtr->up = descrPtr->eplrAction.up;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_DP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_DP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 220, 1);
    }

    if (fldValue)
    {
        /* DP if MX En Modify DP is 1 */
        __LOG(("Enable modify DP , new DP[%d]\n ",
            remark.dp));

        descrPtr->eplrAction.dp = remark.dp;
        descrPtr->eplrAction.modifyDp = 1;

        descrPtr->dp = descrPtr->eplrAction.dp;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_TC_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_TC);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 218, 1);
    }

    if (fldValue)
    {
        /* DP if MX En Modify TC is 1 */
        __LOG(("Enable modify TC , new TC[%d]\n ",
            remark.tc));

        descrPtr->eplrAction.tc = remark.tc;
        descrPtr->eplrAction.modifyTc = 1;

        descrPtr->tc = descrPtr->eplrAction.tc;
    }

    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        fldValue =
            SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                descrPtr->policerMeterConfigEntryMemoryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP_E);
    }
    else
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        fldValue =
            SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                descrPtr->policerActuallAccessedIndex,
                SMEM_LION3_PLR_METERING_TABLE_FIELDS_EGRESS_EN_MODIFY_EXP);
    }
    else
    {
        fldValue = snetFieldValueGet(policerMeterEntryPtr, 216, 1);
    }

    if (fldValue)
    {
        /* DP if MX En Modify EXP is 1 */
        __LOG(("Enable modify EXP , new EXP[%d]\n ",
            remark.exp));
        descrPtr->eplrAction.exp = remark.exp;
        descrPtr->eplrAction.modifyExp = 1;

        descrPtr->exp1 = descrPtr->eplrAction.exp;
    }

    if(descrPtr->qos.ingressExtendedMode &&
      (descrPtr->eplrAction.modifyTc || descrPtr->eplrAction.modifyDp))
    {
        __LOG(("ingress Extended Mode : when EPLR modifies TC and/or DP, update the value of outDesc<QoS Profile> with {5b0, TC, DP} \n"));
        descrPtr->qos.qosProfile = (descrPtr->tc << 2) | descrPtr->dp;
        __LOG_PARAM(descrPtr->qos.qosProfile);
    }

    return GT_TRUE;
}

/*******************************************************************************
*   snetXCatEgressPolicer
*
* DESCRIPTION:
*        Egress Policer Processing, Policer Counters updates
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*       localEgressPort     - local egress port (not global).
*
* RETURN:
*
*******************************************************************************/
void snetXCatEgressPolicer
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 localEgressPort
)
{
    DECLARE_FUNC_NAME(snetXCatEgressPolicer);

    GT_U32 * policerMeterEntryPtr = NULL;   /* Policers Metering Entry Pointer */
    SNET_CHT3_POLICER_QOS_INFO_STC qosProfileInfo;
                                    /* Initial conformance level,
                                       qos profile (index) for out-of-profile
                                       traffic */

    SNET_CHT3_POLICER_MNG_COUNT_STC mngCountData;
                                    /* Management counters data for dropped  packets */
    GT_BOOL forward;                /* GT_TRUE - forward, GT_FALSE - drop packet */
    GT_BOOL retVal;
    GT_U32  eplrTargetPort;          /* target port for EPLR processing */
    GT_U32  regAddr;                 /* register address */
    GT_U32  fieldVal;                /* field's value */
    GT_BIT  skipEplr = 0;            /* skip metering and counting for specific traffic */
    SNET_LION3_POLICER_METERING_DATA_STC meteringData;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* EPLR physical port is global one. */
        /* For SIP5 the "local egress port" is the global. */
        __LOG(("EPLR physical port is global one"));
        eplrTargetPort = localEgressPort;
    }
    else
    {
        /* EPLR physical port is 6 bits of global one */
        __LOG(("EPLR physical port is 6 bits of global one"));
        eplrTargetPort = (SMEM_CHT_GLOBAL_PORT_FROM_LOCAL_PORT_MAC(devObjPtr, localEgressPort) & 0x3F);
    }

    /* Egress policer - is named 'cycle' 2 */
    descrPtr->policerCycle = 2;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* Egress OAM processing */
        __LOG(("Egress OAM processing \n"));
        snetLion2EOamProcess(devObjPtr, descrPtr);

        if(SMEM_CHT_IS_SIP5_10_GET(devObjPtr))
        {
            regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr,descrPtr->policerCycle);

            if (descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_CPU_E)
            {
                /* En To Cpu Meter And Count  */
                smemRegFldGet(devObjPtr, regAddr, 10, 1, &fieldVal);
                if (fieldVal == 0)
                {
                    skipEplr = 1;
                    __LOG(("TO CPU: Skip EPLR Meter and Count\n"));
                }
            }
            else if (descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E)
            {
                /* En To Analyzer Meter And Count  */
                smemRegFldGet(devObjPtr, regAddr, 11, 1, &fieldVal);
                if (fieldVal == 0)
                {
                    skipEplr = 1;
                    __LOG(("TO ANALYZER: Skip EPLR Meter and Count\n"));
                }
            }
        }
    }

    if (!skipEplr)
    {
        /* Check if policer needed */
        __LOG(("Check if policer needed \n"));
        retVal = snetXCatEgressPolicerTriggeringCheck(devObjPtr, descrPtr,
                                                      eplrTargetPort,
                                                      &policerMeterEntryPtr);

        if(retVal == GT_FALSE)
        {
            policerMeterEntryPtr = NULL;
        }

        retVal = snetXCatCommonPolicerMeteringEnvelopeDataGet(
            devObjPtr, descrPtr, policerMeterEntryPtr, &meteringData);
        if (retVal == GT_OK)
        {
            /* for SIP5_15 policerMeterEntryPtr not relevant for any algorithm */
            /* it points buckets entry only                                    */
            /* for metering MEF10.3 envelope fields below should be updated    */
            descrPtr->policerMeterConfigEntryMemoryPtr          =
                meteringData.meterCfgEntryPtr;
            descrPtr->policerConformanceLevelSignEntryMemoryPtr =
                meteringData.meterConformSignLevelPtr;
            descrPtr->policerActuallAccessedIndex =
                (meteringData.envelopeBaseIndex + meteringData.packetRank);
        }
        else
        {
            snetXCatCommonPolicerMeteringSingleDataGet(
                devObjPtr, descrPtr, policerMeterEntryPtr, &meteringData);
        }

        /* Get conformance level and qos profile for out-of-profile traffic */
        __LOG(("Get conformance level and qos profile for out-of-profile traffic \n"));
        snetXCatEgressPolicerConformanceLevelGet(devObjPtr, descrPtr,
                                                 &meteringData,
                                                 &qosProfileInfo);

        /* Remark out-of-profile traffic */
        __LOG(("Remark out-of-profile traffic \n"));
        forward = snetXCatEgressPolicerQosRemark(devObjPtr, descrPtr, policerMeterEntryPtr,
                                       &qosProfileInfo, &mngCountData);

        /* Update policer counters */
        __LOG(("Update policer counters \n"));
        snetXCatEgressPolicerCountersUpdate(devObjPtr, descrPtr,
                                            policerMeterEntryPtr, forward,
                                            &qosProfileInfo,
                                            eplrTargetPort,
                                            &mngCountData);

        if(forward == GT_FALSE)
        {
            /* will cause to drop the packet */
            __LOG(("will cause to drop the packet \n"));
            descrPtr->eplrAction.drop = SKERNEL_EXT_PKT_CMD_HARD_DROP_E;
        }
    }

    descrPtr->policerCounterGlobalNumBytes = 0;

    return ;
}

/*******************************************************************************
*   snetXCatPolicerIPFixCntWrapCheck
*
* DESCRIPTION:
*       Check counters wraparounds for configurable pre-wraparound threshold.
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - packet descriptor
*       wrapAction  - wrap around action
*       goodPcktsPtr   - pointer to good packets.
*       dropPcktsPtr   - pointer to drop packets value.
*       bytesCntPtr    - pointer to bytes counter value.
*       bytes          - bytes increment
*
* OUTPUT:
*       goodPcktsPtr   - pointer to incremented good packets.
*       dropPcktsPtr   - pointer to incremented drop packets value.
*       bytesCntPtr    - pointer to incremented bytes counter value.
*
* RETURN:
*       GT_TRUE - wrap around has triggered
*       GT_FALSE - no wrap around on current counters set
*
*******************************************************************************/
static GT_BOOL snetXCatPolicerIPFixCntWrapCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U32 * goodPcktsPtr,
    INOUT GT_U32 * dropPcktsPtr,
    INOUT GT_U64 * bytesCntPtr,
    IN GT_U32 bytes
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixCntWrapCheck);

    GT_U32 regAddr;                         /* Register address */
    GT_U32 * regPtr;                        /* Register pointer */
    GT_U32 treshold;                        /* Wrap around treshold */
    GT_U64 treshold64;                      /* Wrap around treshold - 64 Bits */
    GT_BIT wrapAction;                      /* Wrap around action freeze/clear */
    GT_BOOL wrapTriggered;                  /* Wrap around trigger */
    GT_BIT dropCountEn;                     /* Enable dropped packets counting */

    wrapTriggered = GT_FALSE;

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        descrPtr->ipfixErrataData.freezeCounter = SNET_XCAT_POLICER_IPFIX_UNKNOWN_COUNT_E;
    }

    /* IPFIX Control */
    __LOG(("IPFIX Control"));
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr,
                                                   descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    wrapAction = SNET_XCAT_POLICER_IPFIX_WA_ACTION_GET_MAC(regPtr);
    dropCountEn = SNET_XCAT_POLICER_IPFIX_DROP_COUNT_EN_GET_MAC(regPtr);

    /* Drop packet wrap around treshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_DROP_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Drop packet wrap around threshold \n"));
    __LOG_PARAM(treshold);

    /* Wrap around check - DROP packets counter */
    __LOG(("Wrap around check - DROP packets counter"));
    snetXcatPolicerIpfixDropWaCheck(devObjPtr, descrPtr,
                                    dropCountEn, dropPcktsPtr, treshold,
                                    wrapAction, &wrapTriggered);

    /* Good packet wrap around treshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_PCKT_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Good packet wrap around threshold \n"));
    __LOG_PARAM(treshold);

    /* Wrap around check - GOOD packets counter */
    __LOG(("Wrap around check - GOOD packets counter"));
    snetXcatPolicerIpfixGoodPcktWaCheck(devObjPtr, descrPtr,
                                              goodPcktsPtr, treshold,
                                        wrapAction, &wrapTriggered);

    /* Byte count wrap around threshold LSB */
    regAddr = SMEM_XCAT_POLICER_IPFIX_BYTE_CNT_LSB_WA_TRESH_REG(devObjPtr,
                                                                    descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold64.l[0] = regPtr[0];
    treshold64.l[1] = regPtr[1];
    __LOG(("Byte count wrap around threshold \n"));
    __LOG_PARAM(treshold64.l[0]);
    __LOG_PARAM(treshold64.l[1]);

    /* Wrap around check - BYTES counter */
    __LOG(("Wrap around check - BYTES counter"));
    snetXcatPolicerIpfixBytesWaCheck(devObjPtr, descrPtr,
                                     bytesCntPtr, bytes, &treshold64,
                                     wrapAction, &wrapTriggered);

    if (devObjPtr->errata.ipfixWrapArroundFreezeMode)
    {
        switch (descrPtr->ipfixErrataData.freezeCounter)
        {
            case SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E:
                *goodPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E];
                *bytesCntPtr =
                    descrPtr->ipfixErrataData.prevBytesCnt;
                break;
            case SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E:
                *bytesCntPtr =
                    descrPtr->ipfixErrataData.prevBytesCnt;
                *dropPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E];
                break;
            case SNET_XCAT_POLICER_IPFIX_BYTES_COUNT_E:
                *goodPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E];
                *dropPcktsPtr =
                    descrPtr->ipfixErrataData.prevPckts[SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E];
                break;
            default:
                break;
        }
    }

    return wrapTriggered;
}

/*******************************************************************************
*   snetXcatPolicerIPFixSampleLogSet
*
* DESCRIPTION:
*       IPFIX entries that have triggered Alarm events are stored in
*       IPFIX Sample Entry Log
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       sampleLogPtr - pointer to IPFIX Sample Entry Log
*       policerCntIndex - policer IPFix entry index
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXcatPolicerIPFixSampleLogSet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 * sampleLogPtr,
    IN GT_U32 policerCntIndex
)
{
    DECLARE_FUNC_NAME(snetXcatPolicerIPFixSampleLogSet);

    GT_U32 i;
    GT_U32 entryArr[4];
    GT_U32 firstNonUsedIndex = SMAIN_NOT_VALID_CNS;
    GT_U32 updatedIndex;
    GT_U32 startBit;

    /* NOTE:
        word 0 bits  0..15 --> index 0 (most recent)
        word 1 bits 16..31 --> index 1
        word 2 bits  0..15 --> index 2
        word 3 bits 16..31 --> index 3 (least recent)
    */

    /* Loop over 4 Sample Log entries and find first invalid entry */
    for(i = 0; i < 4; i++)
    {
        startBit = 16*i;
        entryArr[i] = snetFieldValueGet(sampleLogPtr,startBit,16);

        if(entryArr[i] == 0 && firstNonUsedIndex == SMAIN_NOT_VALID_CNS)
        {
            /* first non used index */
            firstNonUsedIndex = i;
        }
    }

    if(firstNonUsedIndex < 4)
    {
        updatedIndex = firstNonUsedIndex;

        startBit = 16*updatedIndex;

        /*set the empty index */
        snetFieldValueSet(sampleLogPtr, 0 + startBit,15,policerCntIndex);
        /*valid bit*/
        snetFieldValueSet(sampleLogPtr,15 + startBit, 1,      1);

        __LOG(("wrote new info to index[%d] about policerCntIndex[0x%x]\n",
            updatedIndex , policerCntIndex));
    }
    else
    {
        /* push the 3 existing values : 0-->1 , 1-->2 , 2-->3 */
        for(updatedIndex = 1 ; updatedIndex < 4 ; updatedIndex++)
        {
            startBit = 16*updatedIndex;
            snetFieldValueSet(sampleLogPtr, startBit,16,entryArr[updatedIndex-1]);
        }

        updatedIndex = 0;
        startBit = 16*updatedIndex;
        /*set the first index */
        snetFieldValueSet(sampleLogPtr, 0 + startBit,15,policerCntIndex);
        /*valid bit*/
        snetFieldValueSet(sampleLogPtr,15 + startBit, 1,      1);

        __LOG(("wrote new info to index[%d] about policerCntIndex[0x%x] (and pushed 3 others) \n",
            updatedIndex , policerCntIndex));
    }
}

/*******************************************************************************
*   snetXCatPolicerIPFixSampleAlarm
*
* DESCRIPTION:
*         IPFIX Sampling Alarm action
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - packet descriptor
*       policerCntIndex - policer IPFix entry index
*
* OUTPUTS:
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerIPFixSampleAlarm
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixSampleAlarm);

    GT_U32 regAddr;                 /* Register address */
    GT_U32 * sampleLogPtr;          /* pointer to IPFIX Sample Entry Log */

    /* Sample Entry Log0 */
    regAddr =
        SMEM_XCAT_POLICER_IPFIX_SAMPLE_LOG0_REG(devObjPtr,
                                                    descrPtr->policerCycle);
    sampleLogPtr = smemMemGet(devObjPtr, regAddr);

    /* The index of the IPFIX entry that triggered the alarm is stored in a CPU-readable register */
    __LOG(("The index of the IPFIX entry that triggered the alarm is stored in a CPU-readable register"));
    snetXcatPolicerIPFixSampleLogSet(devObjPtr, sampleLogPtr, policerCntIndex);

    /* Interrupt is sent to the CPU */
    __LOG(("Interrupt is sent to the CPU \n"));
    snetChetahDoInterrupt(devObjPtr,
          SMEM_XCAT_POLICER_IPFIX_INT_CAUSE_REG(devObjPtr,  descrPtr->policerCycle),
          SMEM_XCAT_POLICER_IPFIX_INT_MASK_REG(devObjPtr, descrPtr->policerCycle),
          SNET_XCAT_POLICER_INTR_IPFIX_ALARM_E,
          (descrPtr->policerCycle == 0) ?
                          SNET_XCAT_INGR_POLICER0_INTR_SUM_E(devObjPtr) :
                          SNET_XCAT_INGR_POLICER1_INTR_SUM_E(devObjPtr));
}

/*******************************************************************************
*   snetXCatPolicerIPFixSampleActionApply
*
* DESCRIPTION:
*         IPFIX Sampling action apply
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - packet descriptor
*       policerCntIndex - policer IPFix entry index
*       sampleMode - sampling mode
*       ipFixSampleDataPtr - pointer to IPFix sampling related data
*
* OUTPUTS:
*       ipFixSampleDataPtr - pointer to IPFix sampling related data
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerIPFixSampleActionApply
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex,
    IN SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT sampleMode,
    INOUT SNET_XCAT_POLICER_IPFIX_SAMPLE_STC * ipFixSampleDataPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixSampleActionApply);

    GT_U32 regAddr;                 /* Register address */
    GT_U32 * ipfixCtrlRegPtr;       /* IPFIX control register data */
    GT_U32 ipFixTimeStampValue;     /* IPFIX time stamp value */

    __LOG(("IPFIX Sampling action apply : start \n"));

    /* Get current time stamp value */
    ipFixTimeStampValue =
        SNET_XCAT_IPFIX_TOD_CLOCK_GET_MAC(devObjPtr, descrPtr->policerCycle);

    /* IPFIX Control */
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr,
                                                   descrPtr->policerCycle);
    ipfixCtrlRegPtr = smemMemGet(devObjPtr, regAddr);

    switch(ipFixSampleDataPtr->sampleAction)
    {
        case SNET_XCAT_POLICER_IPFIX_SAMPLE_ALARM_E:
            __LOG(("IPFIX_SAMPLE_ALARM_E : start \n"));
            snetXCatPolicerIPFixSampleAlarm(devObjPtr, descrPtr, policerCntIndex);
            __LOG(("IPFIX_SAMPLE_ALARM_E : end \n"));
            break;
        case SNET_XCAT_POLICER_IPFIX_SAMPLE_MIRROR_E:
            if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E)
            {
                __LOG(("IPFIX_SAMPLE_MIRROR_E : modify packet command from 'FORWARD' to 'MIRROR_TO_CPU' \n"));
                descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E;
            }
            else
            if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_SOFT_DROP_E)
            {
                __LOG(("IPFIX_SAMPLE_MIRROR_E : modify packet command from 'SOFT_DROP' to 'TRAP_TO_CPU' \n"));
                descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E;
            }
            else
            {
                /* don't change command */
                __LOG(("IPFIX_SAMPLE_MIRROR_E : don't change command \n"));
                break;
            }
            /* CPU code for sampled packets */
            descrPtr->cpuCode = ipFixSampleDataPtr->cpuSubCode |
                (SNET_XCAT_POLICER_IPFIX_CPU_CODE_GET_MAC(ipfixCtrlRegPtr) << 2);
            /* Timestamp of the last reception of a packet from the corresponding flow */
            descrPtr->ipFixTimeStampValue = ipFixTimeStampValue;
            break;
        default:
            break;
    }

    if(ipFixSampleDataPtr->randomEnable)
    {
        /* Updated every time a packet is marked for sampling */
        ipFixSampleDataPtr->randomOffset =
            rand() % ipFixSampleDataPtr->sampleRange;
    }

    if (sampleMode == SNET_XCAT_POLICER_SAMPLE_MODE_TIME_E)
    {
        /* First time last sample value updated by current time stamp */
        if (ipFixSampleDataPtr->lastSampleValue64.l[0] == 0)
        {
            ipFixSampleDataPtr->lastSampleValue64.l[0] = ipFixTimeStampValue;
        }
    }

    /* Updated every time a packet is marked for sampling */
    ipFixSampleDataPtr->lastSampleValue64 =
            prvSimMathAdd64(ipFixSampleDataPtr->lastSampleValue64,
                            ipFixSampleDataPtr->sampleWindow64);


    __LOG(("IPFIX Sampling action apply : end \n"));

}

/*******************************************************************************
*   snetXCatPolicerIPFixSampling
*
* DESCRIPTION:
*         IPFIX Per-Flow Packet Sampling
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - packet descriptor
*       policerIpfixRegPtr - IPFix entry pointer
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerIPFixSampling
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixSampling);

    SNET_XCAT_POLICER_IPFIX_SAMPLE_MODE_ENT sampleMode; /* Sampling mode */
    GT_U64 currSampleValue64;                   /* Current Sampled Value */
    GT_U64 refSampleValue64;                    /* Reference Sampled Value */
    GT_U64 bytesCnt;                            /* bytes counter value */
    GT_U32 goodPckts, timeStamp, dropPckts;     /* good packets, drop packets value */
    GT_32 retVal;                               /* return value */
    GT_U32 * policerIpfixRegPtr;                /* pointer to IPFix entry */
    SNET_XCAT_POLICER_IPFIX_SAMPLE_STC  ipFixSampleData; /* Policer IPFix Sampling related info */

    /* Billing counter entry pointer */
    policerIpfixRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        sampleMode =
            SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_GET(devObjPtr,policerIpfixRegPtr,
                        descrPtr->countingActuallAccessedIndex,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_SAMPLING_MODE_E);
    }
    else
    {
        sampleMode = SMEM_U32_GET_FIELD(policerIpfixRegPtr[2], 18, 2);
    }

    if(sampleMode == SNET_XCAT_POLICER_SAMPLE_MODE_DISABLE_E)
    {
        /* Policer IPFix Sampling mode disabled */
        __LOG(("Policer IPFix Sampling mode disabled"));
        return;
    }

    currSampleValue64.l[0] = currSampleValue64.l[1] = 0;

    /* Read IPFIX flow counters: packet counter, byte counter, drop counter */
    snetXcatPolicerIpfixCounterRead(devObjPtr,descrPtr,policerIpfixRegPtr,
                             &bytesCnt, &goodPckts, &timeStamp, &dropPckts);

    switch(sampleMode)
    {
        case SNET_XCAT_POLICER_SAMPLE_MODE_PCKT_E:
            currSampleValue64.l[0] = goodPckts;
            break;
        case SNET_XCAT_POLICER_SAMPLE_MODE_BYTE_E:
            currSampleValue64.l[0] = bytesCnt.l[0];
            currSampleValue64.l[1] = bytesCnt.l[1];
            break;
        case SNET_XCAT_POLICER_SAMPLE_MODE_TIME_E:
            currSampleValue64.l[0] = timeStamp;
            break;
        default:
            /* Illegal Sampling Counting Mode */
            __LOG(("Illegal Sampling Counting Mode [%d] \n",
                sampleMode));
            return;

    }
    /* Get all sampling relevant fields from IPFIX entry */
    __LOG(("Get all sampling relevant fields from IPFIX entry"));
    snetXcatPolicerIpfixSampleValuesGet(devObjPtr,descrPtr,policerIpfixRegPtr, &ipFixSampleData);

    /* Calculate reference sample value */
    __LOG(("Calculate reference sample value"));
    refSampleValue64 = prvSimMathAdd64(ipFixSampleData.lastSampleValue64,
                                       ipFixSampleData.sampleWindow64);
    if(ipFixSampleData.randomOffset)
    {
        GT_U64 val64;
        CNV_U32_TO_U64(ipFixSampleData.randomOffset, val64);
        refSampleValue64 = prvSimMathAdd64(refSampleValue64, val64);
    }

    /* Compare current sample and reference sample values */
    __LOG(("Compare current sample and reference sample values"));
    retVal = COMPARE_TWO_U64_VALUES_MAC(currSampleValue64, refSampleValue64);
    if(retVal > 0)
    {
        snetXCatPolicerIPFixSampleActionApply(devObjPtr, descrPtr,
                                              policerCntIndex,
                                              sampleMode,
                                              &ipFixSampleData);
    }
    /* Set sampling relevant fields to IPFIX entry */
    __LOG(("Set sampling relevant fields to IPFIX entry"));
    snetXcatPolicerIpfixSampleValuesSet(devObjPtr,descrPtr,policerIpfixRegPtr, &ipFixSampleData);
}

/*******************************************************************************
*   snetXCatPolicerIPFixCounterIncrement
*
* DESCRIPTION:
*        Increment Policer IPFix Counters
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - packet descriptor
*       policerCntIndex -  policer counter index
*       bytes       - counter increment in bytes
*
* RETURN:
*       GT_TRUE     - counter successfully incremented
*       GT_FALSE    - wrap around has triggered
*
*******************************************************************************/
static GT_BOOL snetXCatPolicerIPFixCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 policerCntIndex,
    IN GT_U32 bytes
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixCounterIncrement);

    GT_U64 bytesCnt;                        /* bytes counter value */
    GT_U32 goodPckts, timeStamp, dropPckts; /* good packets, time stamp, drop packets value */
    GT_BOOL wrapTriggered;                  /* wrap around has(not) been triggered */
    GT_U32 regAddr;                         /* register address */
    GT_U32 * regPtr;                        /* register pointer */
    GT_U32 fieldVal;                        /* register field value */
    GT_U32 * policerIpfixRegPtr;            /* pointer to IPFix entry */
    GT_U32 clockVal;                        /* number of clock ticks */
    GT_BIT aging;                           /* IPfix aging enable bit */


    /* Policers Counters Table Entry */
    policerIpfixRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    /* Read IPFIX flow counters: packet counter, byte counter, drop counter */
    __LOG(("Read IPFIX flow counters: packet counter, byte counter, drop counter"));
    snetXcatPolicerIpfixCounterRead(devObjPtr,descrPtr,policerIpfixRegPtr,
                             &bytesCnt, &goodPckts, &timeStamp, &dropPckts);

    clockVal = SNET_XCAT_IPFIX_TOD_CLOCK_GET_MAC(devObjPtr, descrPtr->policerCycle);

    /* Convert clock value in ticks to time stamp format */
    __LOG(("Convert clock value in ticks to time stamp format"));
    snetXcatIpfixTimestampFormat(devObjPtr, clockVal, &timeStamp);

    /* Check counters wraparounds for configurable pre-wraparound threshold */
    __LOG(("Check counters wraparounds for configurable pre-wraparound threshold"));
    wrapTriggered = snetXCatPolicerIPFixCntWrapCheck(devObjPtr, descrPtr,
                                                     &goodPckts,
                                                     &dropPckts,
                                                     &bytesCnt, bytes);

    /* When the wrap around indication is set (by any of the three counters),
    there is no IPFix Sampling/Alarm */
    if (wrapTriggered)
    {
        /* IPFIX wrap around alert Memory */
        __LOG(("IPFIX wrap around alert Memory"));
        regAddr =
            SMEM_XCAT_POLICER_IPFIX_WA_ALERT_TBL_MEM(devObjPtr,
                                                     descrPtr->policerCycle,
                                                     policerCntIndex);
        regPtr = smemMemGet(devObjPtr, regAddr);
        /* Check wraparound indication bit */
        __LOG(("Check wraparound indication bit"));
        fieldVal = SMEM_U32_GET_FIELD(regPtr[0], (policerCntIndex % 32), 1);
        if(fieldVal == 0)
        {
            snetChetahDoInterrupt(devObjPtr,
                SMEM_XCAT_POLICER_IPFIX_INT_CAUSE_REG(devObjPtr,  descrPtr->policerCycle),
                SMEM_XCAT_POLICER_IPFIX_INT_MASK_REG(devObjPtr,  descrPtr->policerCycle),
                SNET_XCAT_POLICER_INTR_IPFIX_WRAP_E,
                (descrPtr->policerCycle == 0) ?
                              SNET_XCAT_INGR_POLICER0_INTR_SUM_E(devObjPtr) :
                              SNET_XCAT_INGR_POLICER1_INTR_SUM_E(devObjPtr));
            /* Set wraparound indication bit */
            __LOG(("Set wraparound indication bit"));
            SMEM_U32_SET_FIELD(regPtr[0], (policerCntIndex % 32), 1, 1);
        }
    }

    /* Write IPFIX flow counters: packet counter, byte counter, drop counter */
    snetXcatIpfixCounterWrite(devObjPtr, descrPtr , policerIpfixRegPtr, &bytesCnt, goodPckts,
                              timeStamp, dropPckts);

    /* Ingress/Egress Policer Control0 address */
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    aging =
        SNET_XCAT_POLICER_IPFIX_AGE_ENABLE_GET_MAC(regPtr);

    /* Enables the activation of aging for IPfix */
    if(aging)
    {
        /* IPFIX aging alert Memory */
        __LOG(("IPFIX aging alert Memory"));
        regAddr =
            SMEM_XCAT_POLICER_IPFIX_AGING_ALERT_TBL_MEM(devObjPtr,
                                                        descrPtr->policerCycle,
                                                        policerCntIndex);
        regPtr = smemMemGet(devObjPtr, regAddr);
        fieldVal = SMEM_U32_GET_FIELD(regPtr[0], (policerCntIndex % 32), 1);
        /* Check aging indication bit */
        __LOG(("aging indication bit [%d] \n",
            fieldVal));
        if(fieldVal == 0)
        {
            /* Set aging indication bit */
            __LOG(("Set aging indication bit \n"));
            SMEM_U32_SET_FIELD(regPtr[0], (policerCntIndex % 32), 1, 1);
        }
        else
        {
            __LOG(("Aging indication bit already '1' \n"));
        }
    }

    return !(wrapTriggered);
}

/*******************************************************************************
*   snetXCatPolicerIPFixCountersFreezeCheck
*
* DESCRIPTION:
*        Check IPFix counters freeze state
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*
* RETURN:
*       GT_FALSE    - IPFix counter in freeze mode
*       GT_TRUE     - Otherwise
*
*******************************************************************************/
static GT_BOOL snetXCatPolicerIPFixCountersFreezeCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerIPFixCountersFreezeCheck);

    GT_U64 bytesCnt;                        /* bytes counter value */
    GT_U32 goodPckts, timeStamp, dropPckts; /* good packets, time stamp, drop packets value */
    GT_U32 treshold;                        /* wrap around treshold */
    GT_U64 treshold64;                      /* wrap around treshold - 64 Bits */
    GT_U32 regAddr;                         /* register address */
    GT_U32 * regPtr;                        /* register pointer */
    GT_BIT wrapAction;                      /* wrap around action freeze/clear */

    /* IPFIX Control */
    regAddr = SMEM_XCAT_POLICER_IPFIX_CTRL_REG(devObjPtr,
                                                   descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    wrapAction = SNET_XCAT_POLICER_IPFIX_WA_ACTION_GET_MAC(regPtr);
    /* Wrap around action NOT in freeze mode */
    if(wrapAction)
    {
        return GT_TRUE;
    }

    /* Read IPFIX flow counters: packet counter, byte counter, drop counter */
    __LOG(("Read IPFIX flow counters: packet counter, byte counter, drop counter"));
    snetXcatPolicerIpfixCounterRead(devObjPtr,descrPtr,descrPtr->policerCounterEntryMemoryPtr,
                             &bytesCnt, &goodPckts, &timeStamp, &dropPckts);

    /* Drop packet wrap around threshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_DROP_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Drop packet wrap around threshold \n"));
    __LOG_PARAM(treshold);
    if(treshold && (treshold == dropPckts))
    {
        return GT_FALSE;
    }
    /* Good packet wrap around threshold */
    regAddr = SMEM_XCAT_POLICER_IPFIX_PCKT_CNT_WA_TRESH_REG(devObjPtr,
                                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold = regPtr[0];
    __LOG(("Good packet wrap around threshold \n"));
    __LOG_PARAM(treshold);
    if(treshold && (treshold == goodPckts))
    {
        return GT_FALSE;
    }

    /* Byte count wrap around threshold LSB */
    regAddr = SMEM_XCAT_POLICER_IPFIX_BYTE_CNT_LSB_WA_TRESH_REG(devObjPtr,
                                                                    descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    treshold64.l[0] = regPtr[0];
    treshold64.l[1] = regPtr[1];
    __LOG(("Byte count wrap around threshold \n"));
    __LOG_PARAM(treshold64.l[0]);
    __LOG_PARAM(treshold64.l[1]);

    if(treshold64.l[0] || treshold64.l[1])
    {
        if((treshold64.l[0] == bytesCnt.l[0]) &&
           (treshold64.l[1] == bytesCnt.l[1]))
        {
            return GT_FALSE;
        }
    }

    return GT_TRUE;
}

/*******************************************************************************
*   snetLion3PolicerBillingFlowBaseIndexGet
*
* DESCRIPTION:
*        get the index for 'flow based' (from descrPtr->policerPtr or descrPtr->flowId(sip5))
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       oldIndex        - the IPCL/TTI/EPCL or by the index from the Metering table
* OUTPUT:
*       none
*
* RETURN:
*        the new counting index.
*
*******************************************************************************/
static GT_U32 snetLion3PolicerBillingFlowBaseIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32                   oldIndex
)
{
    DECLARE_FUNC_NAME(snetLion3PolicerBillingFlowBaseIndexGet);

    GT_U32  newIndex;
    GT_U32  regAddr;/* register address */
    GT_U32  regValue;
    GT_U32  billingBaseIndexForFlowIdAccess,billingMaxFlowId,billingMinFlowId;

    regAddr = SMEM_LION3_POLICER_GLOBAL_BILLING_CNTR_INDEXING_MODE_CONFIG_0_REG(devObjPtr,
                                                 descrPtr->policerCycle);

    smemRegGet(devObjPtr, regAddr,&regValue);

    if(0 == SMEM_U32_GET_FIELD(regValue, 0, 1))
    {
        __LOG(("Billing Index Mode : Standard: The Billing index is determined by the <Policer Index> from "
            "the IPCL/TTI/EPCL or by the index from the Metering table \n"));

        return oldIndex;
    }

    __LOG(("Billing Index Mode : FlowID: If the Flow-ID is in the configured range, the Billing index is "
        "determined by the packets Flow-ID. Otherwise, the index is determined in the standard way \n"));

    billingBaseIndexForFlowIdAccess = SMEM_U32_GET_FIELD(regValue, 16, 16);
    __LOG_PARAM(billingBaseIndexForFlowIdAccess);

    regAddr = SMEM_LION3_POLICER_GLOBAL_BILLING_CNTR_INDEXING_MODE_CONFIG_1_REG(devObjPtr,
                                                 descrPtr->policerCycle);
    smemRegGet(devObjPtr, regAddr,&regValue);

    billingMaxFlowId = SMEM_U32_GET_FIELD(regValue, 16, 16);
    billingMinFlowId = SMEM_U32_GET_FIELD(regValue,  0, 16);
    __LOG_PARAM(billingMaxFlowId);
    __LOG_PARAM(billingMinFlowId);
    __LOG_PARAM(descrPtr->flowId);

    if(descrPtr->flowId >= billingMinFlowId && (descrPtr->flowId < billingMaxFlowId))
    {
        /*Index to Billing =  <Billing-Base-Index-Flow-ID> + <Flow-ID> - <Billing-Min-Flow-ID>*/
        newIndex =  (descrPtr->flowId - billingMinFlowId) + billingBaseIndexForFlowIdAccess;

        __LOG(("New billing index [0x%x](%d) \n",
            newIndex,newIndex));
    }
    else
    {
        /* keep using the 'Standard mode' */
        newIndex = oldIndex;

        if(descrPtr->flowId < billingMinFlowId)
        {
            __LOG(("NOTE: not use flowId because: descrPtr->flowId[0x%x] < billingMinFlowId[0x%x] \n" ,
                descrPtr->flowId , billingMinFlowId));
        }
        else
        {
            __LOG(("NOTE: not use flowId because: descrPtr->flowId[0x%x] >= billingMaxFlowId[0x%x] \n" ,
                descrPtr->flowId , billingMaxFlowId));
        }
    }

    return newIndex;
}


/*******************************************************************************
*   snetXCatPolicerBillingCounterIncrement
*
* DESCRIPTION:
*        Increment Billing Policer Counters
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*       direction   - ingress/egress policer direction
*       policerMeterEntryPtr  - policer entry pointer
*       egressPort     - local egress port (not global).
*       cl             -  conformance level
*       bytesCount       - counter increment in bytes
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetXCatPolicerBillingCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 egressPort,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT cl,
    IN GT_U32 bytesCount
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerBillingCounterIncrement);

    GT_U32 *policerBillingCounterRegPtr;    /* register pointer */
    GT_U32 regAddr;                         /* register address */
    GT_U32 countMode;                       /* Billing Counters Mode: 1 Byte/16 Bytes/1 Packet */
    GT_U64 val64, increment64;              /* counter 64 bits increment */
    GT_U32 fieldVal;                        /* register entry field */
    GT_U32 increment;                       /* counter 32 bits increment */
    GT_U32 policerCntIndex;                 /* policer counter index */
    GT_BOOL retVal;                         /* return value */
    GT_U32  enableCountingTriggerByPort;
    GT_U32  countingEntryFormat;            /* Long or Short counting entry format */
    GT_U32  portNum;                        /* local source or global target port number */
    GT_U32  cntIndexType;                   /* 0 - Conformance level, 1 - Drop Precedence */
    GT_U32  cntIndex;                       /* counter index in billing entry             */
    GT_U32  *policerCtrlRegPtr;             /* register pointer                           */


    policerCntIndex = 0;

    /* when eArch (eport/evlan metering is used , then the per physical port registers are not used */
    if(descrPtr->policerEArchCounterEnabled == GT_TRUE)
    {
        policerCntIndex = descrPtr->policerEArchPointer;
    }
    else
    {
        /* check billing/IPFIX trigger */
        if (devObjPtr->policerSupport.supportPolicerEnableCountingTriggerByPort)
        {
            /* Ingress/Egress Policer Control0 */
            regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                         descrPtr->policerCycle);
            /*<Enable Counting Trigger by Port>*/
            smemRegFldGet(devObjPtr, regAddr, 3, 1, &enableCountingTriggerByPort);

            /* If "Enable Counting Trigger by Port" in "Hierarchical Policer control Register"
               is disabled, then count only packets triggered by PCL */
            if (enableCountingTriggerByPort == 0)
            {
                /* if reg disabled, count only PCL triggered packets */
                __LOG(("Counting Trigger by Port is disabled, (allow count only PCL triggered packets) \n"));
                if(GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction))
                {
                    return;
                }
            }
            else
            {
                /* The device ignores PCL counting trigger in this mode.
                   The device checks metering by port condition. And billing is done
                   only if metering by port is enabled. But metering may be done
                   by PCL Policer index in this case too.
                   Therefore check metering by port state in register but not actual
                   descrPtr->policerTriggerMode. */
                if (direction == SMAIN_DIRECTION_EGRESS_E)
                {
                    portNum = egressPort;
                }
                else
                {
                    portNum = descrPtr->localDevSrcPort;
                }

                regAddr = SMEM_CHT3_POLICER_PORT_METER_REG(devObjPtr,
                                                                descrPtr->policerCycle,
                                                                portNum);

                smemRegFldGet(devObjPtr, regAddr, portNum % 32, 1, &fieldVal);
                if (fieldVal == 0)
                {
                    /* there is NO billing/IPFIX in this case */
                    __LOG(("Billing/IPFIX disabled per port[%d] \n",
                        portNum));
                    return;
                }

                /* according to HW design :The Errata :
                    billing enable in flow mode is conditioned by,
                    ( stg1_desc_en_billing == TRUE) &&
                    (rf_counting_trigger_by_rf_en == FALSE ) &&
                    (rf_meter_mode == METER_FLOW_MODE) */
                if(devObjPtr->errata.iplrPolicerBillingForPerPhysicalPortMeteringDoesNotWorksInFlowMode)
                {
                    /* Ingress/Egress Policer Control0 */
                    regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                                 descrPtr->policerCycle);
                    /* <Policer Meter Mode> */
                    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
                    if(fieldVal == SNET_XCAT_POLICER_METER_FLOW_E)
                    {
                        __LOG(("WARNING : ERRATA : no counting(billing) performed , because Policer Billing for Per Physical Port metering does not works in FLOW MODE \n"));

                        return;
                    }
                }

            }
        }
        else
        {
            /* count only packets triggered by PCL */
            __LOG(("count only packets triggered by PCL"));
            if(GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction))
            {
                return;
            }
        }

        /* billing/IPFIX entry index is taken from meter entry if metering
           is enabled. Otherwise index is taken from PCL/TTI Policer pointer. */
        if (policerMeterEntryPtr == NULL)
        {
            /* Check policy counting trigger */
            __LOG(("Check policy counting trigger"));
            if (GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(
                devObjPtr, descrPtr, direction))
            {
                /* this case may be only when (see check billing/IPFIX trigger code):
                   devObjPtr->supportPolicerEnableCountingTriggerByPort device AND
                   enableCountingTriggerByPort == 1 AND
                   metering by port is enabled AND
                   policerMeterEntryPtr == NULL
                   This means that simulation has bug in the policerMeterEntryPtr
                   resolution logic. */
                 skernelFatalError("snetXCatPolicerBillingCounterIncrement: NULL policerMeterEntryPtr\n");
            }
            else
            {
                /* Policy Counter Index extracted in PCL action  */
                __LOG(("Policy Counter Index extracted in PCL action"));
                policerCntIndex = descrPtr->policerPtr;
            }
        }
        else
        {
            /* Policy Counter Index extracted from meter entry */
            __LOG(("Policy Counter Index extracted from meter entry"));
            if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
            {
                policerCntIndex =
                    SMEM_SIP5_15_PLR_METERING_CONFIG_ENTRY_FIELD_GET(devObjPtr,
                        descrPtr->policerMeterConfigEntryMemoryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_SIP5_15_PLR_METERING_CONFIG_TABLE_FIELDS_BILLING_PTR_E);
            }
            else
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                policerCntIndex =
                    SMEM_LION3_PLR_METERING_ENTRY_FIELD_GET(devObjPtr,policerMeterEntryPtr,
                        descrPtr->policerActuallAccessedIndex,
                        SMEM_LION3_PLR_METERING_TABLE_FIELDS_BILLING_PTR);
            }
            else
            {
                policerCntIndex = snetFieldValueGet(policerMeterEntryPtr, 198, 16);
            }
        }

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* check flowId use instead of 'the IPCL/TTI/EPCL or by the index from the Metering table' */
            policerCntIndex =
                snetLion3PolicerBillingFlowBaseIndexGet(devObjPtr,descrPtr,policerCntIndex);
        }
    }

    /* Billing counter entry pointer */
    __LOG(("Access the Counting memory : Get the Billing counter entry index [0x%x]\n",
        policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);
    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

    descrPtr->countingActuallAccessedIndex = policerCntIndex;
    __LOG_PARAM(descrPtr->countingActuallAccessedIndex);
    policerBillingCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    countingEntryFormat =
        snetXCatPolicerCountingEntryFormatGet(devObjPtr, direction, descrPtr->policerCycle);
    if (countingEntryFormat)    /* Short entry format */
    {
        fieldVal = 0;  /* set Billing mode in "short" format, IPFix not supported */
    }
    else    /* Full entry format */
    {
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            fieldVal =
                SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
                    descrPtr->countingActuallAccessedIndex,
                    SMEM_LION3_PLR_BILLING_TABLE_FIELDS_COUNTER_MODE_E);
        }
        else
        {
            /* Counter Mode */
            fieldVal = snetFieldValueGet(policerBillingCounterRegPtr, 228, 1);
        }
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* we only now how to calc the byte count for the billing/ipfix calculation */
        __LOG(("Calc num bytes needed for [%s] purpose , index[0x%x] \n",
            fieldVal ? "IPFIX" : "BILLING",
            policerCntIndex));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr, direction,
                                     fieldVal ?
                                     /*IPfix*/ SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E :
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_BILLING_ENTRY_E,
                                     policerBillingCounterRegPtr,
                                     &bytesCount);
    }


    /* IPfix */
    if(fieldVal)
    {
        __LOG(("The Counter entry is 'IPFIX' format \n"));

        /* Check IPFix counters state  */
        retVal = snetXCatPolicerIPFixCountersFreezeCheck(devObjPtr, descrPtr);
        /* IPFix counters in freeze state */
        if(retVal == GT_FALSE)
        {
            return;
        }

        /* IPFIX Per-Flow Packet Counters */
        retVal = snetXCatPolicerIPFixCounterIncrement(devObjPtr, descrPtr,
                                                      policerCntIndex,
                                                      bytesCount);

        /* IPFix counters successfully incremented */
        if(retVal == GT_TRUE)
        {
            /* IPFIX Per-Flow Packet Sampling */
            snetXCatPolicerIPFixSampling(devObjPtr, descrPtr,
                                         policerCntIndex);
        }


        return;
    }

    __LOG(("The Counter entry is 'Billing' format \n"));


    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        countMode =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_BILLING_COUNTERS_MODE_E);
    }
    else
    {
        /* Billing Counters Mode: 1 Byte/16 Bytes/1 Packet */
        if (countingEntryFormat)    /* Short entry format */
        {
            countMode = snetFieldValueGet(policerBillingCounterRegPtr, 126, 2);
        }
        else
        {
            countMode = snetFieldValueGet(policerBillingCounterRegPtr, 140, 2);
        }
    }

    /* Increment Policer Billing Counters */
    increment = SNET_CHT3_PCKT_SIZE_RESOLVE(bytesCount, countMode);
    CNV_U32_TO_U64(increment, increment64);

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        retVal = snetLion2PolicerOamLmCounterIncrement(devObjPtr, descrPtr,
                                                       direction, policerCntIndex,
                                                       increment64);
        if(retVal == GT_TRUE)
        {
            return;
        }
    }

    policerCtrlRegPtr =
        smemMemGet(devObjPtr, SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr, descrPtr->policerCycle/*2*/));

    cntIndexType = SNET_XCAT_POLICER_COUNT_COLOR_MODE_GET_MAC(policerCtrlRegPtr);

    if (cntIndexType == 0)
    {
        cntIndex = cl;
    }
    else
    {
        cntIndex = descrPtr->dp;
    }

    snetXcatPolicerBillingCounterRead(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                       cntIndex, &val64);

    val64 = prvSimMathAdd64(val64, increment64);

    snetXcatPolicerBillingCounterWrite(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                        cntIndex, &val64);
}

/*******************************************************************************
*   snetXCatPolicerCountingEntryFormatGet
*
* DESCRIPTION:
*       Return format of counting entry - Full or Short.
*       If device do not support counting entry format select - this mean "Full" format.
*       See Policer Control1 register, "Counting Entry Format Select" field
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       direction   - ingress/egress policer direction
*       cycle       - ingress policer cycle

*
* OUTPUT
*       None
*
* RETURN:
*       0 - entry format is "Full" (Long)
*       1 - entry format is "Compressed" (short)
*
*******************************************************************************/
GT_U32 snetXCatPolicerCountingEntryFormatGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 cycle
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerCountingEntryFormatGet);

    GT_U32  countingEntryFormat;

    if (devObjPtr->policerSupport.supportCountingEntryFormatSelect)
    {
        /* read countingEntryFormat - control1 reg, bits 4:4 */
        smemRegFldGet(devObjPtr,
                      SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr, cycle),
                      4, 1, &countingEntryFormat);

        if ( (countingEntryFormat == 0) &&
             (devObjPtr->policerSupport.supportOnlyShortCountingEntryFormat) )
        {
            skernelFatalError("snetXCatPolicerCountingEntryFormatGet: Full counting entry format is not supported!\n"
                              "Check Policer Control1 register, 'Counting Entry Format Select' field\n");
        }
    }
    else
    {
        countingEntryFormat = 0; /* Full entry format */
    }

    if(countingEntryFormat)
    {
        __LOG(("global config : the counter entry format is 'Compressed' (short) \n"));
    }
    else
    {
        __LOG(("global config : the counter entry format is 'Full' (Long) \n"));
    }


    return countingEntryFormat;
}

/*******************************************************************************
*   snetXCatPolicerCounterIncrement
*
* DESCRIPTION:
*       Increment Policer Billing/Policy/VLAN Counters
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*       direction   - ingress/egress policer direction
*       policerCtrlRegPtr - pointer to policer global control register
*       policerMeterEntryPtr - pointer to policer metering entry
*       egressPort     -  egress port.
*       cl             -  conformance level
*       bytes       - counter increment in bytes
*
* OUTPUT
*       bytesCountPtr  - counter increment in bytes
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetXCatPolicerCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerCtrlRegPtr,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 egressPort,
    IN SKERNEL_CONFORMANCE_LEVEL_ENT cl,
    OUT GT_U32 * bytesCountPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerCounterIncrement);

    SNET_XCAT_POLICER_COUNTING_MODE_ENT counterMode;  /* counting mode */
    GT_U32 bytesCount;

    ASSERT_PTR(bytesCountPtr);

    /* Get Policer Counting mode */
    counterMode = SNET_XCAT_POLICER_COUNTING_MODE_GET_MAC(policerCtrlRegPtr);

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* will be calculated when needed */
        bytesCount = 0;
    }
    else
    {
        /* Get packet size based on packet size mode.
          byteCount is used for management counters too.
          Need to evaluate it if counting is disabled also. */
        snetCht3PolicerPacketSizeGet(devObjPtr, descrPtr,
                                     direction,
                                     policerCtrlRegPtr, &bytesCount);
    }

    *bytesCountPtr = bytesCount;

    if(counterMode == SNET_XCAT_POLICER_COUNTING_DISABLE_E)
    {
        /* Policer counting in disabled mode */
        __LOG(("Policer counting in disabled mode"));
        return;
    }

    switch(counterMode)
    {
        case SNET_XCAT_POLICER_COUNTING_BILLING_E:
            snetXCatPolicerBillingCounterIncrement(devObjPtr, descrPtr, direction,
                                                   policerMeterEntryPtr,
                                                   egressPort,
                                                   cl,
                                                   bytesCount);
            break;
        case SNET_XCAT_POLICER_COUNTING_POLICY_E:
            if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
            {
                __LOG(("ERROR : the device not supports the 'policy' counting mode in PLR unit \n"));
                return;
            }
            snetXCatPolicerPolicyCounterIncrement(devObjPtr, descrPtr, direction,
                                                  policerMeterEntryPtr,
                                                  bytesCount);
            break;
        case SNET_XCAT_POLICER_COUNTING_VLAN_E:
            if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
            {
                __LOG(("ERROR : the device not supports the 'vlan' counting mode in PLR unit \n"));
                return;
            }
            snetXCatPolicerVlanCounterIncrement(devObjPtr, descrPtr, direction,
                                                policerMeterEntryPtr,
                                                bytesCount);
            break;
        default:
            /* Illegal Policer Counting mode */
            __LOG(("Illegal Policer Counting mode"));
            return;
    }
}

/*******************************************************************************
*   snetXCatPolicerPolicyCounterIncrement
*
* DESCRIPTION:
*        Increment Policer Policy Counters
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*       direction   - ingress/egress policer direction
*       policerMeterEntryPtr - pointer to policer metering entry
*       bytes       - counter increment in bytes
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerPolicyCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytes
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerPolicyCounterIncrement);

    GT_U32 regAddr;
    GT_U32 * policerPolicyCounterRegPtr;
    GT_U32 policerCntIndex;
    GT_U32 pcktCnt;
    GT_U32 countingEntryFormat; /* Full or short counting entry format */

    /* Check policy counting trigger */
    if(GT_FALSE == SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(
        devObjPtr, descrPtr, direction))
    {
        return;
    }

    /* policerMeterEntryPtr not used - metering table contents */
    /* ignored in SNET_XCAT_POLICER_COUNTING_POLICY_E mode     */
    /* Policy Counter Index extracted in PCL action            */
    policerCntIndex = descrPtr->policerPtr;

    /* Policer counter entry pointer */
    __LOG(("Access the Counting memory : Get the Policer counter entry index [0x%x]\n",
        policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);
    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

    descrPtr->countingActuallAccessedIndex = policerCntIndex;
    __LOG_PARAM(descrPtr->countingActuallAccessedIndex);
    policerPolicyCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    countingEntryFormat =
        snetXCatPolicerCountingEntryFormatGet(devObjPtr, direction, descrPtr->policerCycle);

    pcktCnt = policerCntIndex & 0x7;
    if (pcktCnt > (GT_U32)(countingEntryFormat ? 3 : 5) )
    {
        skernelFatalError("snetXCatPolicerPolicyCounterIncrement: Policer Policy counter index is not valid.\n"
                          "Check PCL/TTI action configuration\n");
    }
    /* Increment Policer Policy Counter */
    policerPolicyCounterRegPtr[pcktCnt]++;
    __LOG(("Counter increment from [%d] \n",
        policerPolicyCounterRegPtr[pcktCnt]));
}

/*******************************************************************************
*   snetXCatPolicerVlanCounterIncrement
*
* DESCRIPTION:
*        Increment Policer VLAN Counters
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*       direction   - ingress/egress policer direction
*       policerMeterEntryPtr - pointer to policer metering entry
*       bytesCount       - counter increment in bytes
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerVlanCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 * policerMeterEntryPtr,
    IN GT_U32 bytesCount
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerVlanCounterIncrement);

    GT_U32 regAddr;
    GT_U32 fldValue;
    GT_U32 *regPtr;
    GT_U32 * policerPolicyCounterRegPtr;
    GT_U32 policerCntIndex, pcktCnt;
    GT_U32 cntMode;
    SKERNEL_EXT_PACKET_CMD_ENT packetCommand;

    /* Ingress/Egress Policer Control0 */
    regAddr = SMEM_CHT_POLICER_GLB_CONF_REG(devObjPtr,
                                                descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);

    /* VLAN Counting Mode */
    cntMode = SNET_XCAT_POLICER_VLAN_COUNT_MODE_GET_MAC(regPtr);

    if (direction == SMAIN_DIRECTION_EGRESS_E)
    {
        /* egress PLR don't get packet command from EPCL so use 'forward'
           ??? do we need to use : descrPtr->epclAction.drop || descrPtr->haAction.drop
        */
        __LOG(("NOTE: For trigger purpose : don't get packet command from EPCL , so treat as FORWARD (for trigger purpose) \n"));
        packetCommand = SKERNEL_EXT_PKT_CMD_FORWARD_E;
    }
    else
    {
        packetCommand = descrPtr->packetCmd;
    }


    /* VLAN Counting Trigger */
    switch(packetCommand)
    {
        case SKERNEL_EXT_PKT_CMD_FORWARD_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 25, 1))
            {
                __LOG(("VLAN Counting : not enable for FORWARD command \n"));
                return;
            }
            break;
        case SKERNEL_EXT_PKT_CMD_HARD_DROP_E:
        case SKERNEL_EXT_PKT_CMD_SOFT_DROP_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 26, 1))
            {
                __LOG(("VLAN Counting : not enable for DROP(soft/hard) command \n"));
                return;
            }
            break;
        case SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 27, 1))
            {
                __LOG(("VLAN Counting : not enable for TRAP_TO_CPU command \n"));
                return;
            }
            break;
        case SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E:
            /* check if the counter trigger not set for current packet command */
            if(0 == SMEM_U32_GET_FIELD(regPtr[0], 28, 1))
            {
                __LOG(("VLAN Counting : not enable for MIRROR_TO_CPU command \n"));
                return;
            }
            break;
    default:
            /* packet command that is not supported for counting */
            __LOG(("VLAN Counting : packet command[%d] that is not supported for counting  \n",
                packetCommand));
            return;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) && cntMode/*bytes*/)
    {
        __LOG(("Calc num bytes needed for [%s] purpose \n",
            "COUNTING_VLAN"));
        snetLion3PolicerPacketSizeGet(devObjPtr, descrPtr, direction,
                                     SNET_LION3_POLICER_PACKET_SIZE_FROM_GLOBAL_CONFIG_E,
                                     NULL, &bytesCount);
    }

    /* Policer Counter entry Index */
    policerCntIndex = descrPtr->eVid >> 2;

    /* Policer counter entry pointer */
    __LOG(("Access the Counting memory : Get the VLAN counter entry index [0x%x] (4 vlans in entry) \n",
        policerCntIndex));

    regAddr = SMEM_XCAT_POLICER_CNT_ENTRY_TBL_MEM(devObjPtr, direction,
                                                  descrPtr->policerCycle,
                                                  policerCntIndex);
    descrPtr->policerCounterEntryMemoryPtr = smemMemGet(devObjPtr, regAddr);

    descrPtr->countingActuallAccessedIndex = policerCntIndex;
    __LOG_PARAM(descrPtr->countingActuallAccessedIndex);
    policerPolicyCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    pcktCnt = (descrPtr->eVid)/*policerCntIndex*/ & 0x3;

    /* Increment Policer Policy Counter */
    fldValue = policerPolicyCounterRegPtr[pcktCnt];
    fldValue += (cntMode == 0) ? 1 : bytesCount;

    __LOG(("Counter increment from [%d] to [%d] \n",
        policerPolicyCounterRegPtr[pcktCnt],
        fldValue));

    policerPolicyCounterRegPtr[pcktCnt] = fldValue;

}


/*******************************************************************************
* eplrEPortEntryGet
*
* DESCRIPTION:
*       function of the EPLR unit
*       get index to EPLR - ePort trigger table
*
* INPUTS:
*        devObjPtr - pointer to device object.
*        descrPtr  - Cht frame descriptor
*        localEgressPort - physical egress port -- local port number (port 0..15) !!!
*                    (referred as <LocalDevTrgPhyPort> in documentation ,
*                     but it is not part of the 'descriptor' !)
*
* OUTPUTS:
*
*   RETURN: index to access the EPLR - ePort trigger table
*
*
* COMMENTS :
*
*******************************************************************************/
static GT_U32 eplrEPortTriggerEntryGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32    localEgressPort
)
{
    DECLARE_FUNC_NAME(eplrEPortTriggerEntryGet);

    GT_U32  index;/* table index*/

    if ((descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_FORWARD_E ||
         descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_FROM_CPU_E) &&
        (descrPtr->useVidx == 0 &&
            ((SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->trgDev, descrPtr->ownDev,
                            devObjPtr->dualDeviceIdEnable.ha)) ||
                descrPtr->eArchExtInfo.assignTrgEPortAttributesLocally)))
    {
        index =  descrPtr->trgEPort;
        __LOG(("use descrPtr->trgEPort[0x%x] (useVidx == 0 , to 'own device' , FORWARD/FROM_CPU)\n",
            index));
    }
    else if ((descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_CPU_E) &&
             (descrPtr->useVidx == 0 &&
                (SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->trgDev, descrPtr->ownDev,
                                            devObjPtr->dualDeviceIdEnable.ha))))
    {
        index =  descrPtr->trgEPort;
        __LOG(("use descrPtr->trgEPort[0x%x] (useVidx == 0 , to 'own device' , TO_CPU)\n",
            index));
    }
    else if ((descrPtr->outGoingMtagCmd == SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E) &&
             (descrPtr->useVidx == 0 &&
                (SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->sniffTrgDev, descrPtr->ownDev,
                                            devObjPtr->dualDeviceIdEnable.ha))))
    {
        index =  descrPtr->eArchExtInfo.toTargetSniffInfo.sniffTrgEPort;
        __LOG(("use descrPtr->eArchExtInfo.toTargetSniffInfo.sniffTrgEPort[0x%x] (useVidx == 0 , to 'own device' , TO_SNIFFER)\n",
            index));
    }
    else
    {
        /* make global port from the local port */
        index =  SMEM_CHT_GLOBAL_PORT_FROM_LOCAL_PORT_MAC(devObjPtr,localEgressPort);
        __LOG(("use global egress port[0x%x] \n",
            index));
    }

    return index;
}

#define LION3_NUM_TRAFFIC_TYPES_CNS (SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E - SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E + 1)
#define LION3_TRAFFIC_TYPES_NOT_VALID_CNS   7
/*******************************************************************************
*   policerEArchIndexGet
*
* DESCRIPTION:
*        check if ePort/eVlan entry used for meter/counting ,get meter/count index
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       pcktType       - policer packet type
*       direction       - direction of PLR (ingress/Egress)
*       egressPort     - local egress port (not global) - relevant only for EPLR
*       useEport        - GT_TRUE - ePort using
*                         GT_FALSE - eVlan using
*       entryIndexPtr   - pointer to meter entry index
*
* OUTPUT:
*       entryIndexPtr   - pointer to (new) meter entry index
*
* RETURN:
*       GT_TRUE  - eVlan/ePort meter/counting index used
*       GT_FALSE - eVlan/ePort meter/counting index not used
*
*******************************************************************************/
static GT_BOOL policerEArchIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32       egressPort,
    IN GT_BOOL      useEport,
    INOUT GT_U32 * entryIndexPtr
)
{
    DECLARE_FUNC_NAME(policerEArchIndexGet);

    GT_U32  regAddr;                        /* register address */
    GT_U32  *memPtr;                        /* pointer to memory */
    GT_U32  fieldVal;                       /* register's field value */
    E_ARCH_POLICER_METER_MODE_ENT  eArchMeteringMode;/*ePort/eVlan meter mode*/
    GT_U32 entryIndex, trafficTypeOffset;    /* metering pointer index */
    GT_U32  ePort;/*eport for IPLR/EPLR metering*/
    GT_U32  meterEn,countEn;
    GT_U32  trafficTypeOffsetArr[LION3_NUM_TRAFFIC_TYPES_CNS];
    GT_U32  ii;

    regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr,descrPtr->policerCycle);

    /* ePort/eVlan Metering Mode */
    smemRegFldGet(devObjPtr, regAddr, 8, 2, &fieldVal);
    __LOG(("ePort/eVlan Metering Mode[%d] \n",
        fieldVal));

    eArchMeteringMode = fieldVal;

    __LOG(("PLR[%d] : EPort/EVlan Policer Meter mode [%s]\n",
        descrPtr->policerCycle,
        (eArchMeteringMode == E_ARCH_POLICER_METER_DISABLED_E       ? "DISABLED":
         eArchMeteringMode == E_ARCH_POLICER_METER_EPORT_USED_E     ? "EPORT_USED":
         eArchMeteringMode == E_ARCH_POLICER_METER_EVLAN_USED_E     ? "EVLAN_USED":
                                                                      "NOT_SUPPORTED")
         ));

    if(eArchMeteringMode != E_ARCH_POLICER_METER_EPORT_USED_E &&
       eArchMeteringMode != E_ARCH_POLICER_METER_EVLAN_USED_E)
    {
        return GT_FALSE;
    }
    else if(useEport == GT_TRUE && eArchMeteringMode != E_ARCH_POLICER_METER_EPORT_USED_E)
    {
        __LOG(("ePORT check , but global mode is eVLAN \n"));
        return GT_FALSE;
    }
    else if(useEport == GT_FALSE && eArchMeteringMode != E_ARCH_POLICER_METER_EVLAN_USED_E)
    {
        __LOG(("eVLAN check , but global mode is ePORT \n"));
        return GT_FALSE;
    }

    if(useEport == GT_TRUE)
    {
        if(SMAIN_DIRECTION_INGRESS_E == direction)
        {
            /* the Ingress Policer, ePort metering is done per packet's
                source ePort if it is an ePort of the local device.
                Otherwise, it is done per local source port.*/
            ePort =  descrPtr->eArchExtInfo.localDevSrcEPort;
            __LOG(("use descrPtr->eArchExtInfo.localDevSrcEPort[0x%x] (eport mode)\n",
                ePort));
        }
        else
        {
            /* EPLR special logic */
            ePort =  eplrEPortTriggerEntryGet(devObjPtr,descrPtr,egressPort);
        }
        entryIndex = ePort;
    }
    else
    {
        entryIndex = descrPtr->eVid;
        __LOG(("use descrPtr->eVid[0x%x] (evlan mode)\n",
            entryIndex));
    }

    memPtr = smemMemGet(devObjPtr,
        SMEM_LION2_POLICER_EPORT_EVLAN_TRIGGER_TBL_MEM(devObjPtr,entryIndex,descrPtr->policerCycle));

    meterEn =
        SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
            SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_METERING_ENABLE_E);
    countEn =
        SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
            SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_COUNTING_ENABLE_E);

    if(countEn)
    {
        descrPtr->policerEArchCounterEnabled = GT_TRUE;
        __LOG(("eArch : counting Enabled \n"));
    }
    else
    {
        descrPtr->policerEArchCounterEnabled = GT_FALSE;
        __LOG(("eArch : counting Disabled \n"));
    }

    /*Metering Disabled / Counting Disabled */
    if(0 == meterEn && 0 == countEn)
    {
        __LOG(("eArch : Metering and Counting Disabled \n"));
        return GT_FALSE;
    }

    if(0 == meterEn)
    {
        /* indication the meter not needed */
        descrPtr->policerActuallAccessedIndex = SMAIN_NOT_VALID_CNS;
    }

    if(SMAIN_DIRECTION_INGRESS_E == direction)
    {
        ii = 0;
        trafficTypeOffsetArr[ii++]/*0*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_KNOWN_UNICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*1*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNKNOWN_UNICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*2*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_REGISTERED_MULTICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*3*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_UNREGISTERED_MULTICAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*4*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_BROADCAST_OFFSET_E);
        trafficTypeOffsetArr[ii++]/*5*/ =
            SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
                SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_TCP_SYN_OFFSET_E);


        for(ii = 0 ; ii < LION3_NUM_TRAFFIC_TYPES_CNS ; ii++)
        {
            if(trafficTypeOffsetArr[ii] != LION3_TRAFFIC_TYPES_NOT_VALID_CNS)
            {
                break;
            }
        }

        if(ii == LION3_NUM_TRAFFIC_TYPES_CNS)
        {
            /* In ePort based metering and eVLAN based metering, metering/counting is performed only if the
               following statement is true: (<Metering Enable>==Enabled || <Counting Enable>==Enabled) &&
               metering/counting is enabled for at least one of the six traffic types.
               I.e., if all traffic types are configured to 0x7 in the relevant ePort or eVLAN entry, then
               metering/counting is not performed */
            __LOG(("eArch : Metering and Counting Disabled , on all [%d] traffic types \n",
                LION3_NUM_TRAFFIC_TYPES_CNS));

            descrPtr->policerEArchCounterEnabled = GT_FALSE;

            return GT_FALSE;
        }

        trafficTypeOffset = trafficTypeOffsetArr[pcktType];

        if(trafficTypeOffset == LION3_TRAFFIC_TYPES_NOT_VALID_CNS)
        {
            /* A value of 0x7 means that metering / counting is
                disabled for this traffic type */
            __LOG(("eArch : Metering and Counting Disabled , for current packet type[%d] \n",
                pcktType));

            __LOG(("NOTE: eArch choose NOT to count/meter \n"));

            descrPtr->policerEArchCounterEnabled = GT_FALSE;

            return GT_TRUE;/*return TRUE to state that eArch choose not to count/meter*/
        }
    }
    else
    {
        __LOG(("The egress Policer perform policing on all the traffic. thus, the traffic type offset is ignored and the offset if always 0 \n"));
        trafficTypeOffset = 0;
    }

    descrPtr->policerEArchPointer =
        SMEM_LION3_PLR_E_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,memPtr,entryIndex,
            SMEM_LION3_PLR_E_ATTRIBUTES_TABLE_FIELDS_POLICER_PTR_E);
    descrPtr->policerEArchPointer += trafficTypeOffset;


    __LOG_PARAM(descrPtr->policerEArchPointer);
    *entryIndexPtr = descrPtr->policerEArchPointer;

    if(0 == meterEn)/*Metering Disabled*/
    {
        __LOG(("eArch : Metering Disabled and counting enabled \n"));
    }
    else
    if(countEn == 0)
    {
        __LOG(("eArch : Metering enabled and counting disabled \n"));
    }
    else
    {
        __LOG(("eArch : Metering enabled and counting enabled \n"));
    }

    if(useEport == GT_TRUE)
    {
        __LOG(("eArch : Metering/Counting Enabled - ePort mode \n"));
        descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_E_PORT_E;
    }
    else
    {
        __LOG(("eArch : Metering/Counting Enabled - eVlan mode \n"));
        descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_E_VLAN_E;
    }
    __LOG_PARAM(descrPtr->policerTriggerMode);

    /* indication the eport/evlan logic used */
    return GT_TRUE;

}

/*******************************************************************************
*   snetLion2PolicerEArchIndexGet
*
* DESCRIPTION:
*        Override if need index to policer entry
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       direction       - direction of PLR (ingress/Egress)
*       egressPort     - local egress port (not global) - relevant only for EPLR
*       entryIndexPtr   - pointer to meter entry index
*
* OUTPUT:
*       entryIndexPtr   - pointer to (new) meter entry index
*
* RETURN:
*        GT_TRUE - eArch (ePort/eVlan) metering/counting used
*        GT_FALSE - eArch (ePort/eVlan) metering and counting NOT used
*
*******************************************************************************/
GT_BOOL snetLion2PolicerEArchIndexGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32       egressPort,
    INOUT GT_U32 * entryIndexPtr
)
{
    DECLARE_FUNC_NAME(snetLion2PolicerEArchIndexGet);

    GT_U32  regAddr;                        /* register address */
    GT_U32  fieldVal;                       /* register's field value */
    SNET_XCAT_POLICER_METER_MODE_ENT meterMode;
    SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType;
    GT_BIT meterEnable;
    GT_BIT countEnable;

    if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        return GT_FALSE;
    }

    /* Ingress/Egress Policer Control0 */
    regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                 descrPtr->policerCycle);
    /* Policer Meter mode */
    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
    meterMode = fieldVal;

    /* Get storm rate type */
    snetXCatPolicerStormRateTypeGet(devObjPtr, descrPtr, &pcktType);
    __LOG_PARAM(pcktType);

    /* use SKERNEL_POLICER_TRIGGER_MODE_EARCH_NOT_INITIALIZED_E that
       is not SKERNEL_POLICER_TRIGGER_MODE_NONE_E , to know that
       policerEVlanIndexGet(...) / policerEPortIndexGet(...) may set
       SKERNEL_POLICER_TRIGGER_MODE_NONE_E inside the function */

    descrPtr->policerEArchCounterEnabled = GT_FALSE;

    if(meterMode == SNET_XCAT_POLICER_METER_FLOW_E)
    {
        __LOG(("meterMode = 'FLOW mode' \n"));
        /* In FLOW mode, PCL trigger can override triggering for PORT mode */
        meterEnable = direction == SMAIN_DIRECTION_INGRESS_E ? descrPtr->policerEn : descrPtr->policerEgressEn;
        countEnable = SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction);

        if (meterEnable || countEnable)
        {
            __LOG(("policerTriggerMode = 'flow mode' \n"));
            /* Metering/Counters entry index */
            *entryIndexPtr = descrPtr->policerPtr;
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_FLOW_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
            /* the indication that we need meterring depends on the 'policerEn' */
            if(meterEnable)
            {
                if(countEnable)
                {
                    __LOG(("Flow based : metering and counting used \n"));
                }
                else
                {
                    __LOG(("Flow based : only metering used and counting disabled \n"));
                }
            }
            else
            /*if(countEnable)*/
            {
                /* indication the meter not needed */
                descrPtr->policerActuallAccessedIndex = SMAIN_NOT_VALID_CNS;
                __LOG(("Flow based : metering disabled and only counting used \n"));
            }

            return GT_TRUE;
        }
        else
        {
            /* eVlan Metering Mode */
            if(GT_TRUE == policerEArchIndexGet(devObjPtr, descrPtr,pcktType,direction,egressPort,GT_FALSE/*eVlan*/,entryIndexPtr))
            {
                __LOG(("eVlan metering used \n"));
                return GT_TRUE;
            }
        }
    }
    else
    {
        __LOG(("meterMode = 'port mode' \n"));
    }

    /* ePort Metering Mode */
    if(GT_TRUE == policerEArchIndexGet(devObjPtr, descrPtr,pcktType,direction,egressPort,GT_TRUE/*ePort*/,entryIndexPtr))
    {
        __LOG(("ePort metering used \n"));
        return GT_TRUE;
    }

    __LOG(("ePort/eVlan metering NOT used \n"));
    return GT_FALSE;
}

/*******************************************************************************
*   snetXCatPolicerOverrideMeterIndex
*
* DESCRIPTION:
*        Override if need index to policer entry
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       direction       - direction of PLR (ingress/Egress)
*       entryIndexPtr   - pointer to meter entry index
*
* OUTPUT:
*       entryIndexPtr   - pointer to (new) meter entry index
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetXCatPolicerOverrideMeterIndex
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    INOUT GT_U32 * entryIndexPtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerOverrideMeterIndex);

    GT_U32  regAddr;                        /* register address */
    GT_U32  regValue;                        /* register's value */
    GT_U32  fieldVal;                        /* register's field value */
    SNET_XCAT_POLICER_METER_MODE_ENT meterMode;
    GT_U32 entryIndex, trafficTypeOffset;    /* metering pointer index */
    SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT pcktType;
    GT_BOOL doPortMode;                    /* perform PORT mode logic */
    GT_U32  trafficTypeFirstBit;           /* first bit in index for traffic type value */
    GT_U32 portModeAddressSelect;   /* Full(0) or compressed(1) mode of metering entry
                                       address calculation in Port Mode */

    ASSERT_PTR(entryIndexPtr);

    /* Initial policer metering entry index */
    entryIndex = *entryIndexPtr;

    /* Ingress/Egress Policer Control0 */
    regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr,
                                                 descrPtr->policerCycle);
    /* Policer Meter mode */
    smemRegFldGet(devObjPtr, regAddr, 0, 1, &fieldVal);
    meterMode = fieldVal;

    doPortMode = GT_TRUE;
    if(meterMode == SNET_XCAT_POLICER_METER_FLOW_E)
    {
        __LOG(("meterMode = SNET_XCAT_POLICER_METER_FLOW_E \n"));

        /* In FLOW mode, PCL trigger can override triggering for PORT mode */
        if (SNET_XCAT_POLICER_POLICY_COUNT_ENABLE_GET_MAC(devObjPtr,descrPtr, direction))
        {
            /* Metering/Counters entry index */
            entryIndex = descrPtr->policerPtr;
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_FLOW_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
            doPortMode = GT_FALSE;
        }

        /* SIP5 devices checks PORT mode (traffic type checks) triggering if
          other (PCL/TTI, ePort/eVlan) triggers are not set.
          SIP4 devices do not performs PORT mode triggering in FLOW mode. */
        if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            doPortMode = GT_FALSE;
        }
    }
    else
    {
        __LOG(("meterMode = SNET_XCAT_POLICER_METER_PORT_E \n"));
    }


    if(doPortMode)
    {
        if((descrPtr->policerTriggerMode != SKERNEL_POLICER_TRIGGER_MODE_PORT_E) ||
           ((SMAIN_DIRECTION_EGRESS_E == direction) && (!devObjPtr->policerSupport.supportEplrPerPort)))
        {
            /* there was no trigger by the 'per port'
               in devices before xCat2, ERLR per port does not works too */
            descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_NONE_E;
            __LOG_PARAM(descrPtr->policerTriggerMode);
            return;
        }

        /* PORT mode */
        descrPtr->policerTriggerMode = SKERNEL_POLICER_TRIGGER_MODE_PORT_E;
        __LOG_PARAM(descrPtr->policerTriggerMode);

        if ((SMAIN_DIRECTION_EGRESS_E == direction) && SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* Egress Policer of SIP5 device use Unknown Unicast packet type
               regardless of real packet type */
            pcktType = SNET_XCAT_POLICER_METER_UNK_UCAST_E;
        }
        else
        {
            /* Get storm rate type */
            snetXCatPolicerStormRateTypeGet(devObjPtr, descrPtr, &pcktType);
        }
        __LOG_PARAM(pcktType);

        /* Ingress/Egress Policer Port metering pointer index */
        regAddr = SMEM_XCAT_POLICER_PORT_METER_POINTER_TBL_MEM(devObjPtr,
                                                           descrPtr->policerCycle,
                                                           entryIndex);
        smemRegGet(devObjPtr, regAddr,&regValue);

        /* Storm type port metering index */
        trafficTypeOffset =
            snetXcatPolicerPortPointerIndexGet(devObjPtr,regValue, pcktType, entryIndex);

        __LOG_PARAM(trafficTypeOffset);

        if (devObjPtr->policerSupport.supportPortModeAddressSelect)
        {
            regAddr = SMEM_XCAT_PLR_HIERARCHICAL_POLICER_CTRL_REG(devObjPtr, descrPtr->policerCycle);
            smemRegFldGet(devObjPtr, regAddr, 4, 1, &portModeAddressSelect);
        }
        else
        {
            portModeAddressSelect = 0;  /* full mode */
        }

        /* calculate Metering/Counters entry index */
        if (portModeAddressSelect)
        {
            /* Compressed mode: The address is {port_num,index} - xCat2 and above*/
            __LOG(("Compressed mode: The address isport_num,index} - xCat2 and above"));
            entryIndex = (entryIndex << 2) | trafficTypeOffset;
        }
        else
        {
            /* Full mode: The address is {index,port_num} */
            __LOG(("Full mode: The address isindex,port_num}"));
            if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                /* SIP4 support 6 bits for port number.
                 Traffic type is in bits 6..7  */
                trafficTypeFirstBit = 6;
            }
            else
            {
                /* SIP5 support 8 bits for port number.
                   Traffic type is in bits 8..9 */
                trafficTypeFirstBit = 8;
            }

            entryIndex |= trafficTypeOffset << trafficTypeFirstBit;
        }
    }

    /* Final policer metering entry index */
    *entryIndexPtr = entryIndex;

    __LOG(("Final policer metering entry index[%d] " ,
        entryIndex));

}

/*******************************************************************************
*   snetXCatPolicerStormRateTypeGet
*
* DESCRIPTION:
*        Get storm rate type
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - frame data buffer Id
*       pcktTypePtr     - pointer policer storm rate type
*
* OUTPUT:
*       pcktTypePtr     - pointer policer storm rate type
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetXCatPolicerStormRateTypeGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT SNET_XCAT_POLICER_METER_PACKET_TYPE_ENT * pcktTypePtr
)
{
    DECLARE_FUNC_NAME(snetXCatPolicerStormRateTypeGet);

    GT_U32 fldVal;

    if ((descrPtr->isIp && (descrPtr->ipProt == SNET_TCP_PROT_E))
        && descrPtr->l4StartOffsetPtr != NULL)
    {
        fldVal = descrPtr->l4StartOffsetPtr[13] & 0x3f;
        /* Packet is a TCP SYN */
        if (fldVal == 0x10)
        {
            __LOG(("packet type : SNET_XCAT_POLICER_METER_TCP_SYN_E \n"));
            *pcktTypePtr = SNET_XCAT_POLICER_METER_TCP_SYN_E;
            return;
        }
    }

    switch (descrPtr->macDaType)
    {
        case SKERNEL_UNICAST_MAC_E:
            *pcktTypePtr = (descrPtr->egressFilterRegistered) ?
                SNET_XCAT_POLICER_METER_UCAST_E : SNET_XCAT_POLICER_METER_UNK_UCAST_E;
            if(descrPtr->egressFilterRegistered)
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_UCAST_E \n"));
            }
            else
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_UNK_UCAST_E \n"));
            }
            break;
        case SKERNEL_MULTICAST_MAC_E:
            *pcktTypePtr = (descrPtr->egressFilterRegistered) ?
                SNET_XCAT_POLICER_METER_REG_MCAST_E : SNET_XCAT_POLICER_METER_UNREG_MCAST_E;
            if(descrPtr->egressFilterRegistered)
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_REG_MCAST_E \n"));
            }
            else
            {
                __LOG(("packet type : SNET_XCAT_POLICER_METER_UNREG_MCAST_E \n"));
            }
            break;
        default:    /* BC,ARP-BC*/
            *pcktTypePtr = SNET_XCAT_POLICER_METER_BCAST_E;
            __LOG(("packet type : SNET_XCAT_POLICER_METER_BCAST_E \n"));
            break;
    }
}

/*******************************************************************************
*   snetXcatIpfixTimestampFormat
*
* DESCRIPTION:
*       Convert tick clocks to time stamp format
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       clock           - clock value in ticks
*
* OUTPUT:
*       timestampPtr    - pointer to timestamp format value
*
* RETURN:
*
* COMMENTS:
*       Time stamp format:
*           [15:8] The eight least significant bits of the seconds field
*           [7:0] The eight most significant bits of the nanoseconds field
*
*******************************************************************************/
GT_VOID snetXcatIpfixTimestampFormat
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 clock,
    OUT GT_U32 * timeStampPtr
)
{
    GT_U32 nanoSeconds = 0;     /* IPfix nano timer value */
    GT_U32 seconds = 0;         /* IPfix second timer */

    SNET_TOD_CLOCK_FORMAT_MAC(clock, seconds, nanoSeconds);
    *timeStampPtr = (((nanoSeconds >> 22) & 0xff) | ((seconds & 0xff) << 8));
}


/*******************************************************************************
*   snetXcatIpfixCounterWrite
*
* DESCRIPTION:
*       Set packets/data units billing counter value
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       descrPtr            - packet descriptor (ignored when NULL)
*       ipFixCounterRegPtr  - pointer to IPFix counter register write memory
*       bytes               - byte counter write value
*       packets             - packets counter write value
*       stamps              - stamps counter write value
*       drops               - drops counter write value
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
GT_VOID snetXcatIpfixCounterWrite
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * ipFixCounterRegPtr,
    IN GT_U64 * bytesCntPtr,
    IN GT_U32 packets,
    IN GT_U32 stamps,
    IN GT_U32 drops
)
{
    DECLARE_FUNC_NAME(snetXcatIpfixCounterWrite);

    GT_U32  index = descrPtr ?  descrPtr->countingActuallAccessedIndex : SMAIN_NOT_VALID_CNS;

    if(descrPtr == NULL)
    {
        __LOG(("CPU trigger modification in the counters \n"));
    }


    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        SMEM_LION3_PLR_IPFIX_ENTRY_LARGE_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_BYTE_COUNT_E,
                        &bytesCntPtr->l[0]);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_PACKET_COUNT_E,
                        packets);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_TIME_STAMP_E,
                        stamps);

        SMEM_LION3_PLR_IPFIX_ENTRY_FIELD_SET(devObjPtr,ipFixCounterRegPtr,
                        index,
                        SMEM_LION3_PLR_IPFIX_TABLE_FIELDS_DROP_COUNTER_E,
                        drops);
    }
    else
    {
        snetFieldValueSet(ipFixCounterRegPtr,   0, 32, bytesCntPtr->l[0]);
        snetFieldValueSet(ipFixCounterRegPtr,  32,  4, bytesCntPtr->l[1]);
        snetFieldValueSet(ipFixCounterRegPtr,  36, 30, packets);
        snetFieldValueSet(ipFixCounterRegPtr,  66, 16, stamps);
        snetFieldValueSet(ipFixCounterRegPtr, 198, 30, drops);
    }
}

/*******************************************************************************
*   snetXcatPolicerIpfixDropWaCheck
*
* DESCRIPTION:
*   IPFIX drop counters wraparound indications and action
*
* INPUTS:
*       devObjPtr   - pointer to device object
*       descrPtr    - pointer to frame descriptor
*       dropCountEn - drop counter enable/disable
*       dropPcktsPtr - pointer to drop packets counter
*       treshold    - treshold value
*       wrapAction  - wrap around action: clear counter or no action
*
* OUTPUTS:
*       wrapTriggeredPtr - pointer to wrap around trigger

* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerIpfixDropWaCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_BIT dropCountEn,
    IN GT_U32 * dropPcktsPtr,
    GT_U32 treshold,
    GT_BIT wrapAction,
    GT_BOOL * wrapTriggeredPtr
)
{
    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_HARD_DROP_E ||
       descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_SOFT_DROP_E)
    {
        if(dropCountEn ||
          (descrPtr->meterDp == SKERNEL_CONFORM_RED ||
           descrPtr->meterDp == SKERNEL_CONFORM_DROP))
        {
            snetXcatPolicerIpfixWaCheck(devObjPtr, descrPtr,
                                        SNET_XCAT_POLICER_IPFIX_DROP_PKTS_COUNT_E,
                                        dropPcktsPtr, treshold, wrapAction, wrapTriggeredPtr);
        }
    }
}

/*******************************************************************************
*   snetXcatPolicerIpfixGoodPcktWaCheck
*
* DESCRIPTION:
*   IPFIX good packets wraparound indications and action
*
* INPUTS:
*       devObjPtr   - pointer to device object
*       descrPtr    - pointer to frame descriptor
*       goodPcktsPtr - pointer to good packets counter
*       treshold    - treshold value
*       wrapAction  - wrap around action: clear counter or no action
*
* OUTPUTS:
*       wrapTriggeredPtr - pointer to wrap around trigger

* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerIpfixGoodPcktWaCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * goodPcktsPtr,
    IN GT_U32 treshold,
    IN GT_BIT wrapAction,
    INOUT GT_BOOL * wrapTriggeredPtr
)
{
    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E ||
       descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
    {
        snetXcatPolicerIpfixWaCheck(devObjPtr, descrPtr,
                                    SNET_XCAT_POLICER_IPFIX_GOOD_PKTS_COUNT_E,
                                    goodPcktsPtr, treshold, wrapAction, wrapTriggeredPtr);
    }
}

/*******************************************************************************
*   snetXcatPolicerIpfixBytesWaCheck
*
* DESCRIPTION:
*   IPFIX bytes wraparound indications and action
*
* INPUTS:
*       devObjPtr   - pointer to device object
*       descrPtr    - pointer to frame descriptor
*       bytesCntPtr - pointer to byte counter
*       bytes       - 64 bit counter value
*       treshold64Ptr - 64 bit treshold value
*       wrapAction  - wrap around action: clear counter or no action
*
* OUTPUTS:
*       wrapTriggeredPtr - pointer to wrap around trigger

* RETURN:
*
*******************************************************************************/
static void snetXcatPolicerIpfixBytesWaCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U64 * bytesCntPtr,
    IN GT_U32 bytes,
    IN GT_U64 * treshold64Ptr,
    IN GT_BIT wrapAction,
    OUT GT_BOOL * wrapTriggeredPtr
)
{
    if(descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
    {
        return;
    }

    snetXcatPolicerIpfixWa64Check(devObjPtr, descrPtr,
                                  SNET_XCAT_POLICER_IPFIX_BYTES_COUNT_E,
                                  bytesCntPtr, bytes, treshold64Ptr,
                                  wrapAction, wrapTriggeredPtr);
}

/*******************************************************************************
*   snetLion2PolicerOamLmCounterIncrement
*
* DESCRIPTION:
*        Packet counting for OAM loss measurement (LM).
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       descrPtr    - frame data buffer Id
*       direction   - ingress/egress policer direction
*       policerCntIndex - billing counter index
*       increment64 - 64 bit counter increment value
*
* RETURN:
*       GT_TRUE     - Billing is not performed after OAM LM counter update.
*       GT_FALSE    - Perform billing for this packet after OAM LM counter update.
*
*******************************************************************************/
static GT_BOOL snetLion2PolicerOamLmCounterIncrement
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SMAIN_DIRECTION_ENT direction,
    IN GT_U32 policerCntIndex,
    GT_U64 increment64
)
{
    DECLARE_FUNC_NAME(snetLion2PolicerOamLmCounterIncrement);

    GT_U32 regAddr;                         /* register address */
    GT_U32 * regPtr;                        /* register data pointer */
    GT_U32 *policerBillingCounterRegPtr;    /* pointer to billing table entry */
    GT_U64 val64;                           /* counter 64 bits increment */
    GT_U32 fieldVal;                        /* register entry field */
    GT_U32 lmCaptureMode;                   /* LM counter capture mode: copy/insert */

    if(devObjPtr->oamSupport.plrSupportOamLmCapture == 0)
    {
        /* LM OAM packet capturing is not supported */
        __LOG(("LM OAM packet capturing is not supported"));
        return GT_FALSE;
    }

    if(descrPtr->oamInfo.lmCounterCaptureEnable == 0)
    {
        /* Policer Counter Capture disabled */
        __LOG(("Policer Counter Capture disabled"));
        return GT_FALSE;
    }

    regAddr = SMEM_XCAT_POLICER_GLB1_CONF_REG(devObjPtr, descrPtr->policerCycle);
    regPtr = smemMemGet(devObjPtr, regAddr);
    fieldVal = SMEM_U32_GET_FIELD(regPtr[0], 7, 1);
    if(fieldVal == 0)
    {
        /* Counter Capture for LM disabled */
        __LOG(("Counter Capture for LM disabled"));
        return GT_TRUE;
    }

    /* Billing counter entry pointer */
    policerBillingCounterRegPtr = descrPtr->policerCounterEntryMemoryPtr;

    /* LM Counter Capture Mode */
    lmCaptureMode =
        SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
            descrPtr->countingActuallAccessedIndex,
            SMEM_LION3_PLR_BILLING_TABLE_FIELDS_LM_COUNTER_CAPTURE_MODE_E);

    snetXcatPolicerBillingCounterRead(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                       SKERNEL_CONFORM_GREEN, &val64);
    val64 = prvSimMathAdd64(val64, increment64);

    /* Update billing entry */
    snetXcatPolicerBillingCounterWrite(devObjPtr, descrPtr,policerBillingCounterRegPtr,
                                        SKERNEL_CONFORM_GREEN, &val64);


    if(lmCaptureMode == 0)/* LM Counter Capture Mode - Copy  */
    {
        __LOG(("LM Counter Capture Mode - Copy \n"));
        /*Green Counter Snapshot Valid*/
        fieldVal =
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_GET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E);

        /* Green Counter Snapshot Valid */
        __LOG(("Green Counter Snapshot Valid[%d] \n",
            fieldVal));
        if(fieldVal)
        {
            if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E ||
               descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E)
            {
                regAddr = SMEM_LION3_POLICER_OAM_REG(devObjPtr,
                                                     descrPtr->policerCycle);
                regPtr = smemMemGet(devObjPtr, regAddr);
                /* Failed Capture CPU Code */
                descrPtr->cpuCode = SMEM_U32_GET_FIELD(regPtr[0], 0, 8);
                __LOG(("Failed Capture CPU Code : descrPtr->cpuCode[%d] \n"));
            }
            else
            {
                __LOG(("The 'Failed Capture CPU Code' : not relevant as this is not FORWARD/MIRROR_TO_CPU \n"));
            }
        }
        else
        {
            __LOG(("Update 'Snapshot of the green traffic counter' , and set valid bit \n"));
            /* Write to snapshot of the green traffic counter
            after billing counter update */
            SMEM_LION3_PLR_BILLING_ENTRY_LARGE_FIELD_SET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_E,
                 &val64.l[0]);

            /* When the policer copies the Green Counter, it sets the valid bit.
            When the CPU reads the snapshot, the CPU clears the valid bit. */
            SMEM_LION3_PLR_BILLING_ENTRY_FIELD_SET(devObjPtr,policerBillingCounterRegPtr,
                descrPtr->countingActuallAccessedIndex,
                SMEM_LION3_PLR_BILLING_TABLE_FIELDS_GREEN_COUNTER_SNAPSHOT_VALID_E,
                1);
        }
    }
    else
    {
        __LOG(("LM Counter Capture Mode - Insert \n"));
        /* In Insert case Billing is not performed for this packet even if desc<BillingEn>==SET !!! */
        __LOG(("In Insert case Billing is not performed for this packet even if desc<BillingEn>==SET !!!"));
        descrPtr->oamInfo.lmCounter = val64.l[0];
        descrPtr->oamInfo.lmCounterInsertEnable = 1;
    }

    return GT_TRUE;
}

/*******************************************************************************
* snetPlrTablesFormatInit
*
* DESCRIPTION:
*        init the format of PLR tables.(IPLR0,1 and EPLR)
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*
* OUTPUTS:
*       None.
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
void snetPlrTablesFormatInit(
    IN SKERNEL_DEVICE_OBJECT            * devObjPtr
)
{
    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_E,
        lion3PlrMeteringTableFieldsFormat, lion3PlrMeteringFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_E_ATTRIBUTES_E,
        lion3PlrEAttributesTableFieldsFormat, lion3PlrEAttributesFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_BILLING_E,
        lion3PlrBillingTableFieldsFormat, lion3PlrBillingFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_IPFIX_E,
        lion3PlrIpfixTableFieldsFormat, lion3PlrIpfixFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_PLR_HIERARCHICAL_E,
        lion3PlrHierarchicalTableFieldsFormat, lion3PlrHierarchicalFieldsTableNames);


    if(SMEM_CHT_IS_SIP5_15_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_CONFIG_E,
            sip5_15PlrMeteringConfigTableFieldsFormat, sip5_15PlrMeteringConfigFieldsTableNames);

        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_BILLING_E,
            sip5_15PlrBillingTableFieldsFormat, lion3PlrBillingFieldsTableNames);
    }

    if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_PLR_METERING_CONFIG_E,
            sip5_20PlrMeteringConfigTableFieldsFormat, sip5_15PlrMeteringConfigFieldsTableNames);
    }


}

