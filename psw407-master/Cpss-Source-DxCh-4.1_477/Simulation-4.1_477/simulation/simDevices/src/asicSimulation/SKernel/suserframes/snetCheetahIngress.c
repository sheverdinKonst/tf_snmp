/*******************************************************************************
*              (c), Copyright 2001, Marvell International Ltd.                 *
* THIS CODE CONTAINS CONFIDENTIAL INFORMATION OF MARVELL SEMICONDUCTOR, INC.   *
* NO RIGHTS ARE GRANTED HEREIN UNDER ANY PATENT, MASK WORK RIGHT OR COPYRIGHT  *
* OF MARVELL OR ANY THIRD PARTY. MARVELL RESERVES THE RIGHT AT ITS SOLE        *
* DISCRETION TO REQUEST THAT THIS CODE BE IMMEDIATELY RETURNED TO MARVELL.     *
* THIS CODE IS PROVIDED "AS IS". MARVELL MAKES NO WARRANTIES, EXPRESSED,       *
* IMPLIED OR OTHERWISE, REGARDING ITS ACCURACY, COMPLETENESS OR PERFORMANCE.   *
********************************************************************************
* snetCheetahIngress.c
*
* DESCRIPTION:
*   This is a external API definition for snetChtIngress module of SKernel.
*
* DEPENDENCIES:
*       None.
*
* FILE REVISION NUMBER:
*       $Revision: 300 $
*
*******************************************************************************/
#include <asicSimulation/SKernel/suserframes/snet.h>
#include <asicSimulation/SKernel/suserframes/snetCheetahIngress.h>
#include <asicSimulation/SKernel/smem/smemCheetah.h>
#include <asicSimulation/SKernel/skernel.h>
#include <asicSimulation/SKernel/cheetahCommon/sregCheetah.h>
#include <asicSimulation/SKernel/sfdb/sfdbCheetah.h>
#include <common/SHOST/GEN/INTR/EXP/INTR.H>
#include <asicSimulation/SKernel/suserframes/snetPuma.h>
#include <gmSimulation/GM/GMApi.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah3Reassembly.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah3CentralizedCnt.h>
#include <asicSimulation/SKernel/suserframes/snetCheetahEgress.h>
#include <asicSimulation/SKernel/suserframes/snetXCat.h>
#include <asicSimulation/SKernel/suserframes/snetLion.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah3.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah2TStart.h>
#include <asicSimulation/SKernel/suserframes/snetCheetahPolicer.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah3Policer.h>
#include <asicSimulation/SKernel/suserframes/snetCheetahEq.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah3MacLookup.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah3TTermination.h>
#include <asicSimulation/SLog/simLog.h>
#include <asicSimulation/SLog/simLogInfoTypePacket.h>
#include <asicSimulation/SLog/simLogInfoTypeDevice.h>
#include <asicSimulation/SKernel/suserframes/snetCheetahTxQ.h>
#include <asicSimulation/SKernel/suserframes/snetXCatPolicer.h>
#include <asicSimulation/SKernel/suserframes/snetLion2TrafficGenerator.h>
#include <asicSimulation/SKernel/smem/smemBobcat2.h>
#include <asicSimulation/SKernel/suserframes/snetCheetah2Routing.h>

/* values taken from RFC 2460 */

/* end of packet or unknown not L4 data */
#define IPV6_EXT_HDR_NO_EXT_AND_NO_L4_CNS     59
/* IPV6 extended headers */
#define IPV6_EXT_HDR_HOP_BY_HOP_CNS            0
#define IPV6_EXT_HDR_ROUTING_CNS              43
#define IPV6_EXT_HDR_FRAGMENT_CNS             44
#define IPV6_EXT_HDR_ENCAP_SECUR_PAYLOAD_CNS  50
#define IPV6_EXT_HDR_AUTENTICATION_CNS        51
#define IPV6_EXT_HDR_DESTINATION_OPTIONS_CNS  60
#define IPV6_EXT_HDR_MOBILITY_HEADER_CNS     135

static GT_U8 ipv6ExtHeaders[] =
{
    IPV6_EXT_HDR_HOP_BY_HOP_CNS,          /* Hop By Hop                     */
    IPV6_EXT_HDR_ROUTING_CNS,             /* Routing                        */
    IPV6_EXT_HDR_FRAGMENT_CNS,            /* Fragment                       */
    IPV6_EXT_HDR_ENCAP_SECUR_PAYLOAD_CNS, /* Encapsulating Security Payload */
    IPV6_EXT_HDR_AUTENTICATION_CNS,       /* Authentication                 */
    IPV6_EXT_HDR_DESTINATION_OPTIONS_CNS, /* Destination Options            */
    IPV6_EXT_HDR_MOBILITY_HEADER_CNS,     /* Mobility Header                */
};

static GT_U32 ipv6ExtHeadersAmount =
    sizeof(ipv6ExtHeaders) / sizeof(ipv6ExtHeaders[0]);

#define CPY_DESC_FIELD_MAC(targetDescrPtr,sourceDescrPtr,field)   \
    {                                                             \
        if(targetDescrPtr->field != sourceDescrPtr->field)        \
        {                                                         \
            __LOG_NO_LOCATION_META_DATA(("\t\t %s = [0x%x] \n",#field , sourceDescrPtr->field));\
        }                                                         \
        targetDescrPtr->field = sourceDescrPtr->field;            \
    }

#define CMD_FORWARD   SKERNEL_EXT_PKT_CMD_FORWARD_E
#define CMD_MIRROR    SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E
#define CMD_TRAP      SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E
#define CMD_SOFT_DROP SKERNEL_EXT_PKT_CMD_SOFT_DROP_E
#define CMD_HARD_DROP SKERNEL_EXT_PKT_CMD_HARD_DROP_E

/* Number of Transmit Queues in Cheetah */
#define SNET_CHT_SDMA_TX_QUEUE_MAX_NUMBER       8

/* CHT3 OAM PROTOCOL */
#define SNET_CHT3_ETHERTYPE_OAM_SLOW_PROTOCOL       0x8809

/* Flow Control Packet Ethertype */
#define SNET_CHT_FC_ETHERTYPE                       0x8808

/* Flow Control Packet OpCode */
#define SNET_CHT_FC_OPCODE                          0x0001

/* Priority Flow Control Packet OpCode */
#define SNET_CHT_PFC_OPCODE                         0x0101

/* double indexed : with one of
SKERNEL_EXT_PKT_CMD_FORWARD_E
SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E
SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E
SKERNEL_EXT_PKT_CMD_HARD_DROP_E
SKERNEL_EXT_PKT_CMD_SOFT_DROP_E
*/
static SKERNEL_EXT_PACKET_CMD_ENT chtResovedPacketCmdTable[5][5]=
{
    {CMD_FORWARD,   CMD_MIRROR,    CMD_TRAP,      CMD_HARD_DROP, CMD_SOFT_DROP},
    {CMD_MIRROR,    CMD_MIRROR,    CMD_TRAP,      CMD_HARD_DROP, CMD_TRAP},
    {CMD_TRAP,      CMD_TRAP,      CMD_TRAP,      CMD_HARD_DROP, CMD_TRAP},
    {CMD_HARD_DROP, CMD_HARD_DROP, CMD_HARD_DROP, CMD_HARD_DROP, CMD_HARD_DROP},
    {CMD_SOFT_DROP, CMD_TRAP,      CMD_TRAP,      CMD_HARD_DROP, CMD_SOFT_DROP}
};

/* VLAN mode */
typedef enum {
    SNET_NOT_CHANGE_E = 0,
    SNET_UNTAGGED_ONLY_E,
    SNET_TAGGED_ONLY_E,
    SNET_ALL_PACKETS_E
} SNET_VLAN_MODE_ENT;

/* QoS Trust Mode */
#define SNET_TRUST_L2_E         1
#define SNET_TRUST_L3_E         2

/* IPV6 Trunk Hushing Mode */
typedef enum {
    SNET_IPV6_TRUNK_HASH0_E = 0,
    SNET_IPV6_TRUNK_HASH1_E,
    SNET_IPV6_TRUNK_HASH2_E,
    SNET_IPV6_TRUNK_HASH3_E
} SNET_IPV6_TRUNK_LBH_ENT;

/* Classification of IEEE802.3x Flow Control Packets:
     SNET_NOT_FC_PACKET_E       -   Not FC packet
     SNET_FC_PACKET_E           -   Valid FC packet
     SNET_PFC_PACKET_E          -   Priority Flow control frame
     SNET_UNKNOWN_FC_PACKET_E   -   Unknown MAC control frame */
typedef enum {
    SNET_NOT_FC_PACKET_E = 0,
    SNET_FC_PACKET_E,
    SNET_PFC_PACKET_E,
    SNET_UNKNOWN_FC_PACKET_E
} SNET_FLOW_CONTROL_PACKET_TYPE_ENT;

/* Pre-Route Exception Check Masks */
typedef enum {
    IPV4_UC_HDR_CHKSUM_ERR_MASK_E = 0,
    IPV4_MC_HDR_CHKSUM_ERR_MASK_E,
    IPV4_UC_HDR_VER_ERR_MASK_E,
    IPV4_MC_HDR_VER_ERR_MASK_E,
    IPV4_UC_HDR_LENGTH_ERR_MASK_E,
    IPV4_MC_HDR_LENGTH_ERR_MASK_E,
    IPV4_UC_HDR_SIP_NE_DIP_ERR_MASK_E,
    IPV4_MC_HDR_SIP_NE_DIP_ERR_MASK_E,
    IPV6_UC_HDR_VER_ERR_MASK_E,
    IPV6_MC_HDR_VER_ERR_MASK_E,
    IPV6_UC_HDR_LENGTH_ERR_MASK_E,
    IPV6_MC_HDR_LENGTH_ERR_MASK_E,
    IPV6_UC_HDR_SIP_NE_DIP_ERR_MASK_E,
    IPV6_MC_HDR_SIP_NE_DIP_ERR_MASK_E
} PRE_ROUT_HEADER_EXCEPTION_CHECK_ENT;

/* force reduced number of bits from the eDSA (like actual device !!! - not documented behavior) */
#define REDUCE_NUM_BIT_FROM_EDSA_MAC(dev,field,type)                            \
        {                                                                       \
            GT_U32  __origValue = field;                                        \
            field &= SMEM_BIT_MASK(dev->flexFieldNumBitsSupport.type);          \
            if(field != __origValue)                                            \
            {                                                                   \
                __LOG(("NOTE: force reduced number of bits from the eDSA : for field[%s] from[0x%x] to [0x%x] (type [%s] support max [%d] bits) \n" ,\
                    #field , __origValue , field,                               \
                    #type, dev->flexFieldNumBitsSupport.type));                 \
            }                                                                   \
        }

#define SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_NAME                                     \
     STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_DEFAULT_SOURCE_EPORT_NUMBER       )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_RING_CORE_PORT                 )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_LOOPED                         )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_ENABLE_MRU_CHECK_ON_CASCADE_PORT       )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_PORTS_DEFAULT_EPORT_BASE  )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_TRUNK_DEFAULT_EPORT_BASE  )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CENTRALIZED_CHASSIS_PORT_ENABLE        )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_TRUNK_ID                               )\
    ,STR(   SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_QOS_MODE                          )

char * lion3TtiPhysicalPortFieldsTableNames[SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3TtiPhysicalPortTableFieldsFormat[SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS___LAST_VALUE___E] =
{
/*    SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_DEFAULT_SOURCE_EPORT_NUMBER            */
    STANDARD_FIELD_MAC(13),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_RING_CORE_PORT                     */
    STANDARD_FIELD_MAC(1),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_LOOPED                              */
    STANDARD_FIELD_MAC(1),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_ENABLE_MRU_CHECK_ON_CASCADE_PORT            */
    STANDARD_FIELD_MAC(1),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_PORTS_DEFAULT_EPORT_BASE       */
    STANDARD_FIELD_MAC(13),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_TRUNK_DEFAULT_EPORT_BASE       */
    STANDARD_FIELD_MAC(13),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CENTRALIZED_CHASSIS_PORT_ENABLE             */
    STANDARD_FIELD_MAC(1),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_TRUNK_ID                                    */
    STANDARD_FIELD_MAC(12),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_QOS_MODE                               */
    STANDARD_FIELD_MAC(1)
};

#define SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_NAME                                    \
     STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_QOS_EN                    )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_VLAN_EN                   )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_DEF_TAG1_VLAN_ID                     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_UP0                             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_INGRESS_TAG0_TPID_PROFILE            )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_INGRESS_TAG1_TPID_PROFILE            )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_VLAN_TRANSLATION                     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_VID_PRECEDENCE                     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_EVLAN_MODE                         )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_EVLAN                              )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_802_1AH_MAC_TO_ME_EN             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_EN_802_1AH_TTI_LOOKUP                )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_ETHERNET_CLASSIFIER_EN               )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MPLS_TUNNEL_TERMINATION_EN           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_MPLS_MAC_TO_ME_EN                )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_IPV4_MAC_TO_ME_EN                )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_TTI_FOR_TT_ONLY                 )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_TUNNEL_TERMINATION_EN           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_EXTENDED_DSA_BYPASS_BRIDGE           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_QOS_PROFILE                     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSA_TAG_QOS                    )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_EXP                            )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSCP                           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_UP                             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MAP_DSCP_TO_DSCP                     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_QOS_MAPPING_TABLE_INDEX        )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_MODIFY_DSCP                     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_MODIFY_UP                       )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_QOS_PRECEDENCE                  )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_NESTED_VLAN_ACCESS_PORT              )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OVERSIZE_UNTAGGED_PKTS_FILTER_EN     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRILL_ENGINE_EN                      )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRILL_INGRESS_OUTER_VID0             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_802_1AH_PASSENGER_STAG_IS_TAG0_1 )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_6_TOTAL_LENGTH_DEDUCTION_EN     )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OAM_LINK_LAYER_PDU_TRAP_EN           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OAM_LINK_LAYER_LOOPBACK_EN           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_UP_CFI_TO_QOS_TABLE_SELECT_MODE      )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE                 )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE                 )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP2_PCL_CFG_MODE                 )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_ASSIGN_VF_ID_EN                      )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_L2_QOS_TAG0_OR_TAG1            )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_PKT_TYPE_UDB_KEY_I_ENABLE        )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_MC_DUPLICATION_MODE             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV6_MC_DUPLICATION_MODE             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MPLS_MC_DUPLICATION_ENABLE           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRILL_MC_DUPLICATION_ENABLE          )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PBB_MC_DUPLICATION_ENABLE            )\
    ,STR( SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MRU_INDEX                            )

char * lion3TtiDefaultEPortFieldsTableNames[SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3TtiDefaultEPortTableFieldsFormat[SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS___LAST_VALUE___E] =
{
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_QOS_EN                             */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_VLAN_EN                            */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_DEF_TAG1_VLAN_ID                              */
   STANDARD_FIELD_MAC(12),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_UP0                                      */
   STANDARD_FIELD_MAC(3),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_INGRESS_TAG0_TPID_PROFILE                     */
   STANDARD_FIELD_MAC(3),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_INGRESS_TAG1_TPID_PROFILE                     */
   STANDARD_FIELD_MAC(3),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_VLAN_TRANSLATION                              */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_VID_PRECEDENCE                              */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_EVLAN_MODE                                  */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_EVLAN                                       */
   STANDARD_FIELD_MAC(13),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_802_1AH_MAC_TO_ME_EN                      */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_EN_802_1AH_TTI_LOOKUP                         */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_ETHERNET_CLASSIFIER_EN                        */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MPLS_TUNNEL_TERMINATION_EN                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_MPLS_MAC_TO_ME_EN                         */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_IPV4_MAC_TO_ME_EN                         */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_TTI_FOR_TT_ONLY                          */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_TUNNEL_TERMINATION_EN                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_EXTENDED_DSA_BYPASS_BRIDGE                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_QOS_PROFILE                              */
   STANDARD_FIELD_MAC(10),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSA_TAG_QOS                             */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_EXP                                     */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSCP                                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_UP                                      */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MAP_DSCP_TO_DSCP                              */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_QOS_MAPPING_TABLE_INDEX                 */
   STANDARD_FIELD_MAC(4),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_MODIFY_DSCP                              */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_MODIFY_UP                                */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_QOS_PRECEDENCE                           */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_NESTED_VLAN_ACCESS_PORT                       */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OVERSIZE_UNTAGGED_PKTS_FILTER_EN              */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRILL_ENGINE_EN                               */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRILL_INGRESS_OUTER_VID0                      */
   STANDARD_FIELD_MAC(12),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_802_1AH_PASSENGER_STAG_IS_TAG0_1          */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_6_TOTAL_LENGTH_DEDUCTION_EN              */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OAM_LINK_LAYER_PDU_TRAP_EN                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OAM_LINK_LAYER_LOOPBACK_EN                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_UP_CFI_TO_QOS_TABLE_SELECT_MODE               */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE                          */
   STANDARD_FIELD_MAC(2),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE                          */
   STANDARD_FIELD_MAC(2),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP2_PCL_CFG_MODE                          */
   STANDARD_FIELD_MAC(2),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_ASSIGN_VF_ID_EN                               */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_L2_QOS_TAG0_OR_TAG1                     */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_PKT_TYPE_UDB_KEY_I_ENABLE                 */
   STANDARD_FIELD_MAC(16),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_MC_DUPLICATION_MODE                      */
   STANDARD_FIELD_MAC(3),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV6_MC_DUPLICATION_MODE                      */
   STANDARD_FIELD_MAC(3),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MPLS_MC_DUPLICATION_ENABLE                    */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRILL_MC_DUPLICATION_ENABLE                   */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PBB_MC_DUPLICATION_ENABLE                     */
   STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MRU_INDEX                                     */
   STANDARD_FIELD_MAC(3)
};

#define SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_NAME                                     \
     STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_EVLAN                 )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_EVLAN_COMMAND                  )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_EVLAN_PRECEDENCE               )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_VALID                          )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_UP             )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_DSCP           )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_QOS_PROFILE    )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_QOS_PROFILE                    )\
    ,STR( SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_QOS_PRECEDENCE        )

char * lion3TtiDefaultPortProtocolEvlanAndQosConfigurationFieldsTableNames[
    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3TtiDefaultPortProtocolEvlanAndQosConfigurationTableFieldsFormat[
    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_EVLAN                */
    STANDARD_FIELD_MAC(13),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_EVLAN_COMMAND                 */
    STANDARD_FIELD_MAC(2),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_EVLAN_PRECEDENCE              */
    STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_VALID                         */
    STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_UP            */
    STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_DSCP          */
    STANDARD_FIELD_MAC(1),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_QOS_PROFILE   */
    STANDARD_FIELD_MAC(2),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_QOS_PROFILE                   */
    STANDARD_FIELD_MAC(10),
    /*SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_QOS_PRECEDENCE       */
    STANDARD_FIELD_MAC(1),
};

#define SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_NAME                            \
     STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_TAG0_TPID_PROFILE        )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_TAG1_TPID_PROFILE        )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_NUM_OF_TAGS_TO_POP           )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_POLICY_EN                )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_DIS_IPCL0_FOR_ROUTED         )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_TRUST_L2_QOS_TAG0_OR_TAG1    )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_OVERRIDE_MASK_HASH_EN        )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_HASH_MASK_INDEX              )\
    ,STR( SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_PHY_SRC_MC_FILTERING_EN      )

char * lion3TtiEPortAttributesFieldsTableNames[
    SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC lion3TtiEPortAttributesTableFieldsFormat[
    SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_TAG0_TPID_PROFILE      */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_TAG1_TPID_PROFILE      */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_NUM_OF_TAGS_TO_POP         */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_POLICY_EN              */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_DIS_IPCL0_FOR_ROUTED       */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_TRUST_L2_QOS_TAG0_OR_TAG1  */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_OVERRIDE_MASK_HASH_EN      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_HASH_MASK_INDEX            */
    STANDARD_FIELD_MAC(4),
/*SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_PHY_SRC_MC_FILTERING_EN    */
    STANDARD_FIELD_MAC(1)
};

#define SMEM_LION3_L2_MLL_TABLE_FIELDS_NAME                                    \
     STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_0                                 )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_0                  )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_0                          )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_0                             )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0                      )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_0                            )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0                         )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_0                                 )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_0             )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_0        )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_0                     )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_0                              )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_0        )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_0                        )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_0                              )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_0            )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_0                 )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_0               )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_RESERVED_1                             )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_1                                 )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_1                  )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_1                          )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_1                             )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1                      )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_1                            )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1                         )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_1                                 )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_1             )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_1        )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_1                     )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_1                              )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_1        )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_1                        )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_1                              )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_1            )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_1                 )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_1               )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_RESERVED_2                             )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_ENTRY_SELECTOR                         )\
    ,STR(SMEM_LION3_L2_MLL_TABLE_FIELDS_L2_NEXT_MLL_PTR                        )

static char * lion3L2MllFieldsTableNames[
    SMEM_LION3_L2_MLL_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_L2_MLL_TABLE_FIELDS_NAME};

static SNET_ENTRY_FORMAT_TABLE_STC lion3L2MllTableFieldsFormat[
    SMEM_LION3_L2_MLL_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_0                                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_0                     */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_0                             */
    STANDARD_FIELD_MAC(15),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_0                                */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "False"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0                         */
        {FIELD_SET_IN_RUNTIME_CNS,
         1,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_0},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_0                               */
            {FIELD_SET_IN_RUNTIME_CNS,
             13,
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0                             */
            {FIELD_SET_IN_RUNTIME_CNS,
             12,
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_0                                    */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},


/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_0                */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_0},
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_0           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_0                        */
    STANDARD_FIELD_MAC(1),

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_0                                 */
    STANDARD_FIELD_MAC(10),

/*SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_0           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_0                           */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_0                                 */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_0               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_0                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_0                  */
    STANDARD_FIELD_MAC(6),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_RESERVED_1*/
    STANDARD_FIELD_MAC(0),


/*SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_1                                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_1                     */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_1                             */
    STANDARD_FIELD_MAC(15),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_1                                */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "False"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1                         */
        {FIELD_SET_IN_RUNTIME_CNS,
         1,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_1},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_1                               */
            {FIELD_SET_IN_RUNTIME_CNS,
             13,
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1                             */
            {FIELD_SET_IN_RUNTIME_CNS,
             12,
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_1                                    */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},


/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_1                */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_1},
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_1           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_1                        */
    STANDARD_FIELD_MAC(1),

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_1                                 */
    STANDARD_FIELD_MAC(10),

/*SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_1           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_1                           */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_1                                 */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_1               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_1                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_1                  */
    STANDARD_FIELD_MAC(6),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_RESERVED_2*/
    STANDARD_FIELD_MAC(0),

/*SMEM_LION3_L2_MLL_TABLE_FIELDS_ENTRY_SELECTOR                            */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_L2_NEXT_MLL_PTR                           */
    STANDARD_FIELD_MAC(15)
};

static SNET_ENTRY_FORMAT_TABLE_STC sip5_20L2MllTableFieldsFormat[
    SMEM_LION3_L2_MLL_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_0                                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_0                     */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_0                             */
    STANDARD_FIELD_MAC(15),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_0                                */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "False"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0                         */
        {FIELD_SET_IN_RUNTIME_CNS,
         1,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_0},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_0                               */
            {FIELD_SET_IN_RUNTIME_CNS,
             14,/*was 13 in sip5*/
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0                             */
            {FIELD_SET_IN_RUNTIME_CNS,
             12,
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_0                                    */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},


/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_0                */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_0},
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_0           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_0                        */
    STANDARD_FIELD_MAC(1),

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_0                                 */
    STANDARD_FIELD_MAC(10),

/*SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_0           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_0                           */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_0                                 */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_0               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_0                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_0                  */
    STANDARD_FIELD_MAC(6),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_RESERVED_1*/
    STANDARD_FIELD_MAC(1),


/*SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_1                                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_1                     */
    STANDARD_FIELD_MAC(2),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_1                             */
    STANDARD_FIELD_MAC(15),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_1                                */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "False"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1                         */
        {FIELD_SET_IN_RUNTIME_CNS,
         1,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_1},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_1                               */
            {FIELD_SET_IN_RUNTIME_CNS,
             14,/*was 13 in sip5*/
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

        /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
        /*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1                             */
            {FIELD_SET_IN_RUNTIME_CNS,
             12,
             SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_1                                    */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},


/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_1                */
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_1},
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_1           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_1                        */
    STANDARD_FIELD_MAC(1),

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_1                                 */
    STANDARD_FIELD_MAC(10),

/*SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_1           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_1                           */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_1                                 */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_1               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_1                    */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_1                  */
    STANDARD_FIELD_MAC(6),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_RESERVED_2*/
    STANDARD_FIELD_MAC(1),

/*SMEM_LION3_L2_MLL_TABLE_FIELDS_ENTRY_SELECTOR                            */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_L2_MLL_TABLE_FIELDS_L2_NEXT_MLL_PTR                           */
    STANDARD_FIELD_MAC(15)
};

#define SMEM_LION3_IP_MLL_TABLE_FIELDS_NAME                                    \
     STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_LAST_0                                  )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_START_OF_TUNNEL_0                       )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_RPF_FAIL_CMD_0                      )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_EVID_0                              )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_USE_VIDX_0                              )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0                       )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_0                                 )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_EPORT_0                             )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0                          )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_RESERVED_2                              )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_DEV_0                               )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_EXCLUDE_SRC_VLAN_0                      )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TTL_THRESHOLD_0_OR_HOP_LIMIT_THRESHOLD_0)\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_PTR_0                            )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_TYPE_0                           )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_LAST_1                                  )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_START_OF_TUNNEL_1                       )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_RPF_FAIL_CMD_1                      )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_EVID_1                              )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_USE_VIDX_1                              )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1                       )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_1                                 )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_EPORT_1                             )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1                          )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_RESERVED_3                              )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_DEV_1                               )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_EXCLUDE_SRC_VLAN_1                      )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TTL_THRESHOLD_1_OR_HOP_LIMIT_THRESHOLD_1)\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_PTR_1                            )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_TYPE_1                           )\
    ,STR(SMEM_LION3_IP_MLL_TABLE_FIELDS_NEXT_MLL_PTR                            )

static char * lion3IpMllFieldsTableNames[
    SMEM_LION3_IP_MLL_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_LION3_IP_MLL_TABLE_FIELDS_NAME};

static SNET_ENTRY_FORMAT_TABLE_STC lion3IpMllTableFieldsFormat[
    SMEM_LION3_IP_MLL_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_LAST_0                                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_START_OF_TUNNEL_0                           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_RPF_FAIL_CMD_0                          */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_EVID_0                                  */
    STANDARD_FIELD_MAC(13),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_USE_VIDX_0                                  */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0                           */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_0                                     */
        {FIELD_SET_IN_RUNTIME_CNS,
         16,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_EPORT_0                                 */
        {FIELD_SET_IN_RUNTIME_CNS,
         13,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0                              */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_RESERVED_2*/
    STANDARD_FIELD_MAC(0),/* not exist */

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_DEV_0                                   */
    {FIELD_SET_IN_RUNTIME_CNS,
     10,
     SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_0},

/*SMEM_LION3_IP_MLL_TABLE_FIELDS_EXCLUDE_SRC_VLAN_0                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TTL_THRESHOLD_0_OR_HOP_LIMIT_THRESHOLD_0    */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_PTR_0                                */
    STANDARD_FIELD_MAC(15),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_TYPE_0                               */
    STANDARD_FIELD_MAC(1),


/*SMEM_LION3_IP_MLL_TABLE_FIELDS_LAST_1                                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_START_OF_TUNNEL_1                           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_RPF_FAIL_CMD_1                          */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_EVID_1                                  */
    STANDARD_FIELD_MAC(13),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_USE_VIDX_1                                  */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1                           */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_1                                     */
        {FIELD_SET_IN_RUNTIME_CNS,
         16,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_EPORT_1                                 */
        {FIELD_SET_IN_RUNTIME_CNS,
         13,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1                              */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_RESERVED_3*/
    STANDARD_FIELD_MAC(0),/* not exist */

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_DEV_1                                   */
    {FIELD_SET_IN_RUNTIME_CNS,
     10,
     SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_1},

/*SMEM_LION3_IP_MLL_TABLE_FIELDS_EXCLUDE_SRC_VLAN_1                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TTL_THRESHOLD_1_OR_HOP_LIMIT_THRESHOLD_1    */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_PTR_1                                */
    STANDARD_FIELD_MAC(15),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_TYPE_1                               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_NEXT_MLL_PTR                                */
    STANDARD_FIELD_MAC(16)
};

static SNET_ENTRY_FORMAT_TABLE_STC sip5_20IpMllTableFieldsFormat[
    SMEM_LION3_IP_MLL_TABLE_FIELDS___LAST_VALUE___E] =
{
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_LAST_0                                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_START_OF_TUNNEL_0                           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_RPF_FAIL_CMD_0                          */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_EVID_0                                  */
    STANDARD_FIELD_MAC(13),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_USE_VIDX_0                                  */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0                           */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_0                                     */
        {FIELD_SET_IN_RUNTIME_CNS,
         16,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_EPORT_0                                 */
        {FIELD_SET_IN_RUNTIME_CNS,
         14,/*was 13 in sip5 */
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0                              */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0},

    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_RESERVED_2*/
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_0},

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_DEV_0                                   */
    STANDARD_FIELD_MAC(10),

/*SMEM_LION3_IP_MLL_TABLE_FIELDS_EXCLUDE_SRC_VLAN_0                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TTL_THRESHOLD_0_OR_HOP_LIMIT_THRESHOLD_0    */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_PTR_0                                */
    STANDARD_FIELD_MAC(16),/* was 15 in sip 5*/
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_TYPE_0                               */
    STANDARD_FIELD_MAC(1),


/*SMEM_LION3_IP_MLL_TABLE_FIELDS_LAST_1                                      */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_START_OF_TUNNEL_1                           */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_RPF_FAIL_CMD_1                          */
    STANDARD_FIELD_MAC(3),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_MLL_EVID_1                                  */
    STANDARD_FIELD_MAC(13),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_USE_VIDX_1                                  */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1                           */
    STANDARD_FIELD_MAC(1),

    /*UseVIDX0 = "True"*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_1                                     */
        {FIELD_SET_IN_RUNTIME_CNS,
         16,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_EPORT_1                                 */
        {FIELD_SET_IN_RUNTIME_CNS,
         14,/*was 13 in sip5 */
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},

    /*(UseVIDX0 = "False") and (TargetIsTrunk0 = "True")*/
    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1                              */
        {FIELD_SET_IN_RUNTIME_CNS,
         12,
         SMEM_LION3_IP_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1},


    /*SMEM_LION3_IP_MLL_TABLE_FIELDS_RESERVED_3*/
    {FIELD_SET_IN_RUNTIME_CNS,
     1,
     SMEM_LION3_IP_MLL_TABLE_FIELDS_EVIDX_1},

/*(UseVIDX0 = "False") and (TargetIsTrunk0 = "False")*/
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TRG_DEV_1                                   */
    STANDARD_FIELD_MAC(10),

/*SMEM_LION3_IP_MLL_TABLE_FIELDS_EXCLUDE_SRC_VLAN_1                          */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TTL_THRESHOLD_1_OR_HOP_LIMIT_THRESHOLD_1    */
    STANDARD_FIELD_MAC(8),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_PTR_1                                */
    STANDARD_FIELD_MAC(16),/* was 15 in sip 5*/
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_TUNNEL_TYPE_1                               */
    STANDARD_FIELD_MAC(1),
/*SMEM_LION3_IP_MLL_TABLE_FIELDS_NEXT_MLL_PTR                                */
    STANDARD_FIELD_MAC(16)
};

/* BOBCAT2 B0 TABLES - Start */
#define SMEM_BOBCAT2_B0_TTI_PHYSICAL_PORT_TABLE_FIELDS_NAME                                            \
     STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_DEFAULT_SOURCE_EPORT_NUMBER     )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_RING_CORE_PORT               )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_LOOPED                       )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_ENABLE_MRU_CHECK_ON_CASCADE_PORT     )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_PORTS_DEFAULT_EPORT_BASE)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_TRUNK_DEFAULT_EPORT_BASE)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CENTRALIZED_CHASSIS_PORT_ENABLE      )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_TRUNK_ID                             )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_QOS_MODE                        )

char * bobcat2B0TtiPhysicalPortTableFieldsNames[
    SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_BOBCAT2_B0_TTI_PHYSICAL_PORT_TABLE_FIELDS_NAME};

SNET_ENTRY_FORMAT_TABLE_STC bobcat2B0TtiPhysicalPortTableFieldsFormat[SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS___LAST_VALUE___E] =
{
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_DEFAULT_SOURCE_EPORT_NUMBER */
    STANDARD_FIELD_MAC(13),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_RING_CORE_PORT                     */
    STANDARD_FIELD_MAC(0),/* field not exists ! was removed ! but this line must exists !!! */
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_LOOPED */
    STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_ENABLE_MRU_CHECK_ON_CASCADE_PORT */
    STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_PORTS_DEFAULT_EPORT_BASE */
    STANDARD_FIELD_MAC(13),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_TRUNK_DEFAULT_EPORT_BASE */
    STANDARD_FIELD_MAC(13),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CENTRALIZED_CHASSIS_PORT_ENABLE */
    STANDARD_FIELD_MAC(1),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_TRUNK_ID */
    STANDARD_FIELD_MAC(12),
/* SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_QOS_MODE */
    STANDARD_FIELD_MAC(1)
};

/* BOBCAT2 B0 TABLES - End */

static SNET_ENTRY_FORMAT_TABLE_STC sip5_20TtiPhysicalPortTableFieldsFormat[SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS___LAST_VALUE___E] =
{
/*    SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_DEFAULT_SOURCE_EPORT_NUMBER            */
    STANDARD_FIELD_MAC(14), /* + 1 from sip 5 */
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_RING_CORE_PORT                     */
    STANDARD_FIELD_MAC(0),/* field not exists ! was removed ! but this line must exists !!! */
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_LOOPED                              */
    STANDARD_FIELD_MAC(1),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_ENABLE_MRU_CHECK_ON_CASCADE_PORT            */
    STANDARD_FIELD_MAC(1),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_PORTS_DEFAULT_EPORT_BASE       */
    STANDARD_FIELD_MAC(14), /* + 1 from sip 5 */
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_TRUNK_DEFAULT_EPORT_BASE       */
    STANDARD_FIELD_MAC(14), /* + 1 from sip 5 */
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CENTRALIZED_CHASSIS_PORT_ENABLE             */
    STANDARD_FIELD_MAC(1), /* + 1 from sip 5 */
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_TRUNK_ID                                    */
    STANDARD_FIELD_MAC(12),
/*    ,SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_QOS_MODE                               */
    STANDARD_FIELD_MAC(1)
};


#define SMEM_SIP5_20_TTI_PHYSICAL_PORT_2_TABLE_FIELDS_NAME                                            \
     STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_00_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_01_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_02_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_03_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_04_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_05_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_06_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_07_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_08_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_09_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_10_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_11_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_12_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_13_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_14_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_15_DOMAIN_X_PTP_PACKET_COMMAND)\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_PIGGYBACKED_TIMESTAMP_ENABLE               )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_PORT_LIST_BIT_VECTOR_OFFSET                )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_PORT_GROUP                                 )\
    ,STR(SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_EXTRACT_HASH_FROM_FORWARD_EDSA             )

static char * sip5_20TtiPhysicalPort2TableFieldsNames[
    SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_SIP5_20_TTI_PHYSICAL_PORT_2_TABLE_FIELDS_NAME};

static SNET_ENTRY_FORMAT_TABLE_STC sip5_20TtiPhysicalPort2TableFieldsFormat[SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELDS___LAST_VALUE___E] =
{
     STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_00_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_01_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_02_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_03_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_04_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_05_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_06_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_07_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_08_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_09_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_10_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_11_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_12_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_13_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_14_DOMAIN_X_PTP_PACKET_COMMAND */
    ,STANDARD_FIELD_MAC(15) /*  SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_MESSAGE_TYPE_15_DOMAIN_X_PTP_PACKET_COMMAND */

   /*SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_PIGGYBACKED_TIMESTAMP_ENABLE    */
   ,STANDARD_FIELD_MAC(1)
   /*SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_PORT_LIST_BIT_VECTOR_OFFSET     */
   ,STANDARD_FIELD_MAC(5)
   /*SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_PORT_GROUP                      */
   ,STANDARD_FIELD_MAC(4)
   /*SMEM_LION3_TTI_PHYSICAL_PORT_2_TABLE_FIELD_EXTRACT_HASH_FROM_FORWARD_EDSA  */
   ,STANDARD_FIELD_MAC(1)
};

#define SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_NAME                                          \
     STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_LOOPBACK_PROFILE      )\
    ,STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_TC_PROFILE            )\
    ,STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_EVLAN_MIRRORING_ENABLE)\
    ,STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_EUSE_VLAN_TAG_1_FOR_TAG_STATE               )\
    ,STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_ENQ_PROFILE           )\
    ,STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ELOOPBACK_ENQ_PROFILE                       )\
    ,STR(SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ELOOPBACK_PORT                              )

static char * sip5_20EgfQagPortTargetAttributesTableFieldsNames[
    SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
    {SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_NAME};

static SNET_ENTRY_FORMAT_TABLE_STC sip5_20EgfQagPortTargetAttributesTableFieldsFormat[SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS___LAST_VALUE___E] =
{
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_LOOPBACK_PROFILE       */
    STANDARD_FIELD_MAC(2)
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_TC_PROFILE             */
   ,STANDARD_FIELD_MAC(2)
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_EVLAN_MIRRORING_ENABLE */
   ,STANDARD_FIELD_MAC(1)
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_EUSE_VLAN_TAG_1_FOR_TAG_STATE                */
   ,STANDARD_FIELD_MAC(1)
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ETARGET_PHYSICAL_PORT_ENQ_PROFILE            */
   ,STANDARD_FIELD_MAC(1)
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ELOOPBACK_ENQ_PROFILE                        */
   ,STANDARD_FIELD_MAC(1)
    /*SMEM_SIP5_20_EGF_QAG_PORT_TARGET_ATTRIBUTES_TABLE_FIELDS_ELOOPBACK_PORT                               */
   ,STANDARD_FIELD_MAC(9)
};


#ifdef _WIN32
extern void SHOSTG_psos_reg_asic_task(void);
#endif /*_WIN32*/

static GT_BOOL snetChtRxPort(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtFrameParsingVlanAssign(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    INTERNAL_TTI_DESC_INFO_STC        * internalTtiInfoPtr
);

static GT_VOID snetChtCfmEtherTypeCheck(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtIPcl(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtIPolicer(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtRouting(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtRxMacCountUpdate(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_BOOL overSize,
    IN SNET_FLOW_CONTROL_PACKET_TYPE_ENT fcPacketType,
    IN GT_U32  macPort
);

static GT_VOID snetChtIngressIsLoopedAndDropOnSource
(
    IN  SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
);

static GT_VOID snetChtMarvellTagParsing(
    IN  SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN  INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
);

static GT_VOID snetChtVlanQosProfAssign(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 etherType,
    IN SKERNEL_L2_ENCAPSULATION_TYPE_ENT l2encapsul,
    IN GT_U32 * portVlanCfgEntryPtr
);

static GT_VOID snetChtPortProtVlans(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 etherType,
    IN SKERNEL_L2_ENCAPSULATION_TYPE_ENT l2encapsul,
    IN GT_U32     portProtVlanEnabled
);

static GT_VOID  snetChtQoSAssignPart1
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * portVlanCfgEntryPtr
);

static GT_VOID  snetChtQoSAssignPart2
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * portVlanCfgEntryPtr,
    IN GT_BIT   usePortBasedQos
);

static GT_VOID snetChtTrunkHash(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * escrPtr
);

static GT_VOID snetXCatA1TrunkHash(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * escrPtr
);

static GT_VOID snetChtLinkStateNotify(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 port,
    IN GT_U32 linkState
);

extern GT_VOID snetChtL2i(
    IN    SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtPerformFromCpuDma(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 txQue,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    OUT GT_BOOL * queueEmptyPtr,
    OUT GT_BOOL * isLastPacketPtr
);

extern GT_VOID  snetChtUcRouting(
    SKERNEL_DEVICE_OBJECT * devObjPtr,
    SKERNEL_FRAME_CHEETAH_DESCR_STC *  descrPtr
);

extern GT_VOID snetCht2Routing(
    IN    SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtTTermination
(
    IN    SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN    INTERNAL_TTI_DESC_INFO_STC        * internalTtiInfoPtr
);

static GT_VOID snetChtFromEmbeddedCpuProcess
(
    IN    SKERNEL_DEVICE_OBJECT             * devObjPtr,
    IN SBUF_BUF_ID bufferId
);

static GT_VOID snetChtIngressMacSa
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
);

static GT_VOID snetChtIngress
(
        IN SKERNEL_DEVICE_OBJECT * devObjPtr,
        IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
);

static GT_VOID snetChtFrameProcess
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SBUF_BUF_ID bufferId,
    IN GT_U32 srcPort
);

static GT_VOID snetChtFromCpuDmaProcess
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SBUF_BUF_ID bufferId
);

static GT_VOID snetChtIngressL2TunnelReplication
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
);

static GT_VOID snetChtMll
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
);

static GT_VOID snetChtIngressL2MllEngine
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
);


static GT_BOOL snetChtDoForwardFcFrame
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    OUT SNET_FLOW_CONTROL_PACKET_TYPE_ENT   *fcPacketTypePtr
);

static SKERNEL_DEVICE_OBJECT *   snetChtSoftReset
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
);

static GT_VOID snetChtTimestampTagAndTimestampInfo
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 tstStartOffset
);

static GT_VOID snetChtTimestampTagDetection
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U32 * ethTypeOffset
);

#if 0
static GT_VOID sdmaTxPacketGeneratorConfigSet_test
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 txQue,
    IN GT_U32 firstDmaAddr,
    IN GT_U32 lastDmaAddr
);
#endif

#define SNET_CHT_PORT_VLAN_QOS_DSA_CSCD_BYPASS_BRG_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 8, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 21, 1)

#define SNET_CHT_PORT_VLAN_QOS_MIRR_INGR_ANALAYZER_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 7, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 23, 1)

#define SNET_CHT_PORT_VLAN_QOS_TRUNK_ID_GET_MAC(dev, entry) \
        SMEM_U32_GET_FIELD(entry[0], 0, 7)

#define SNET_CHT_PORT_VLAN_QOS_PORT_POLICY_EN_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 10, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 17, 1)

#define SNET_CHT_PORT_VLAN_QOS_PCL0_0_LOOKUP_CONFIGURATION_MODE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 11, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 20, 1)

#define SNET_CHT_PORT_VLAN_QOS_PCL0_1_LOOKUP_CONFIGURATION_MODE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 12, 1) : \
        0

#define SNET_CHT_PORT_VLAN_QOS_PCL1_0_LOOKUP_CONFIGURATION_MODE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 13, 1) : \
        0

#define SNET_CHT_PORT_VLAN_QOS_INGR_VLAN_SELECT_GET_MAC(dev, entry) \
    /* There is only VLAN Range0 for XCat devices */ \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        0 : SMEM_U32_GET_FIELD(entry[0], 22, 1)

#define SNET_CHT_PORT_VLAN_QOS_PVID_MODE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 27, 1) : \
        SMEM_U32_GET_FIELD(entry[1], 15, 1)

#define SNET_CHT_PORT_VLAN_QOS_PVID_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 15, 12) : \
        SMEM_U32_GET_FIELD(entry[1], 0, 12)

#define SNET_CHT_PORT_VLAN_QOS_PVID_PRECEDENCE_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 29, 1) : \
        SMEM_U32_GET_FIELD(entry[1], 16, 1)

#define SNET_CHT_PORT_VLAN_QOS_VLAN_TRANSLATION_GET_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 31, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 15, 1)

#define SNET_CHT_PORT_VLAN_QOS_TRUST_DSA_QOS_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 10, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 12, 1)

#define SNET_CHT_PORT_VLAN_QOS_TRUST_PKT_QOS_MODE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 7, 2) : \
        SMEM_U32_GET_FIELD(entry[0], 10, 2)

/* MPLS EXP supported only by XCAT A1 and above */
#define SNET_CHT_PORT_VLAN_QOS_TRUST_PKT_MPLS_EXP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 9, 2) : 0

#define SNET_CHT_PORT_VLAN_QOS_MAP_DSCP_TO_DSCP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 6, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 9, 1)

#define SNET_CHT_PORT_VLAN_QOS_QOS_PROFILE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 12, 7) : \
        SMEM_U32_GET_FIELD(entry[0], 25, 7)

#define SNET_CHT_PORT_VLAN_QOS_MODIFY_UP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 4, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 7, 1)

#define SNET_CHT_PORT_VLAN_QOS_MODIFY_DSCP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 5, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 8, 1)

#define SNET_CHT_PORT_VLAN_QOS_QOS_PECEDENCE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 3, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 13, 1)

#define SNET_CHT_PORT_VLAN_QOS_PROT_BASED_QOS_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1], 11, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 19, 1)

#define SNET_CHT_PORT_VLAN_QOS_PROT_BASED_VLAN_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 30, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 18, 1)

#define SNET_CHT_PORT_VLAN_QOS_UP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[1],  0, 3) : \
        SMEM_U32_GET_FIELD(entry[1], 12, 3)

#define SNET_CHT_PORT_VLAN_QOS_ACCESS_PORT_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[0], 28, 1) : \
        SMEM_U32_GET_FIELD(entry[0], 24, 1)

/* relevant only for XCAT A1 and above devices */
#define SNET_CHT_PORT_VLAN_QOS_TRUST_VLAN_TAG1_QOS_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry[2],  1, 1) : 0

#define SNET_CHT_PORT_PROT_VLAN_QOS_QOS_PROFILE_MODE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry, 18, 2) : \
        SMEM_U32_GET_FIELD(entry, 25, 2)

#define SNET_CHT_PORT_PROT_VLAN_QOS_QOS_PROFILE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry, 20, 7) : \
        SMEM_U32_GET_FIELD(entry, 12, 7)

#define SNET_CHT_PORT_PROT_VLAN_QOS_MODIFY_UP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry, 16, 1) : \
        SMEM_U32_GET_FIELD(entry, 20, 1)

#define SNET_CHT_PORT_PROT_VLAN_QOS_MODIFY_DSCP_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry, 17, 1) : \
        SMEM_U32_GET_FIELD(entry, 19, 1)

#define SNET_CHT_PORT_PROT_VLAN_QOS_QOS_PECEDENCE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD(entry, 27, 1) : \
        SMEM_U32_GET_FIELD(entry, 23, 1)

#define SNET_CHT_PORT_PROT_IS_VALID_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD((entry), 15, 1) : \
        SMEM_U32_GET_FIELD((entry), 27, 1)

#define SNET_CHT_PORT_PROT_VLAN_MODE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD((entry), 12, 2) : \
        SMEM_U32_GET_FIELD((entry), 21, 2)

#define SNET_CHT_PORT_PROT_VID_PRECEDENCE_MAC(dev, entry) \
    (SKERNEL_IS_XCAT_REVISON_A1_DEV(dev)) ? \
        SMEM_U32_GET_FIELD((entry), 14, 1) : \
        SMEM_U32_GET_FIELD((entry), 24, 1)


/* ipv4 hash -- byte index after the shift */
#define IPV4_SHIFT_INDEX_MAC(origByte,byteShift)  (((origByte)+(byteShift)) & 3)

/* ipv4 hash -- byte index after the shift */
#define IPV6_SHIFT_INDEX_MAC(origByte,byteShift)  (((origByte)+(byteShift)) & 15)

/*******************************************************************************
*   snetChtPktCmdResolution
*
* DESCRIPTION:
*       resolve from old and current commands the new command
*
* INPUTS:
*       prevCmd --- previous command
*       currCmd  current command
*
* OUTPUTS:
*       none
*
* RETURN:
*       resolved new command
*
* COMMENTS:
*
*        [2] Table 5: cpu code changes conflict resolution   page 17
*
*******************************************************************************/
extern GT_U32 snetChtPktCmdResolution
(
    IN SKERNEL_EXT_PACKET_CMD_ENT prevCmd,
    IN SKERNEL_EXT_PACKET_CMD_ENT currCmd
)
{
    SKERNEL_EXT_PACKET_CMD_ENT newCommand;
    SKERNEL_DEVICE_OBJECT * devObjPtr = NULL;

    if(prevCmd >= 5 || currCmd >= 5)
    {
        /* fatal error */
        skernelFatalError("snetChtPktCmdResolution: bad parameters \n");
    }

    newCommand = chtResovedPacketCmdTable[prevCmd][currCmd];

    if(newCommand != prevCmd)
    {
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("do packet command resolution between : "));
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("Orig:"));
        simLogPacketDescrPacketCmdDump(devObjPtr,prevCmd);

        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("Assign:"));
        simLogPacketDescrPacketCmdDump(devObjPtr,currCmd);

        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("new command is: "));
        simLogPacketDescrPacketCmdDump(devObjPtr,newCommand);
        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("\n"));
    }

    return newCommand;
}


/*******************************************************************************
*   snetChtProcessInit
*
* DESCRIPTION:
*       Init module.
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*
*******************************************************************************/
GT_VOID snetChtProcessInit
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    GT_U32  descNumber; /* number of descriptors for the Cheetah device */

    if (devObjPtr->gmDeviceType == GOLDEN_MODEL)
    {
        devObjPtr->devFrameProcFuncPtr = snetPumaProcessFrameFromSlan;
        devObjPtr->devPortLinkUpdateFuncPtr = snetGmLinkStateNotify;
        return;
    }

    descNumber = 512;

    devObjPtr->prependNumBytes = 2;

    /**************************/
    /* init specific features */
    /**************************/
    if(SKERNEL_IS_CHEETAH3P_ONLY_DEV(devObjPtr))
    {
        devObjPtr->supportCapwap = GT_TRUE;
        devObjPtr->supportCpuTrgPort = GT_TRUE;
        devObjPtr->supportEmbeddedCpu = GT_TRUE;
        devObjPtr->supportTunnelInterface = GT_TRUE;
        devObjPtr->supportUdpLite = GT_TRUE;
        devObjPtr->capwapReassemblyTablePtr =
                smemDeviceObjMemoryAlloc(devObjPtr,
                    SNET_CHT3_CAPWAP_REASSEMBLY_NUM_ENTRIES_CNS,
                       sizeof(SKERNEL_CAPWAP_REASSEMBLY_ENTRY_STC));
        /* set the start index of the descriptors that will be used for
           holders of waiting frames in reassembly engine */
        devObjPtr->capwapReassemblyFirstDescriptorIndex = descNumber;
        /* support additional descriptor that would be used for the reassembly
           CAPWAP engine */
        descNumber += SNET_CHT3_CAPWAP_REASSEMBLY_NUM_ENTRIES_CNS;

        devObjPtr->capwapReassemblyDescriptorsUsedBmpPtr = smemDeviceObjMemoryAlloc(devObjPtr,
            ((SNET_CHT3_CAPWAP_REASSEMBLY_NUM_ENTRIES_CNS+31)/32),sizeof(GT_U32));
    }

    devObjPtr->descriptorPtr =
        (void *)smemDeviceObjMemoryAlloc(devObjPtr,descNumber, sizeof(SKERNEL_FRAME_CHEETAH_DESCR_STC));

    if (devObjPtr->descriptorPtr == 0) {
        skernelFatalError("smemChtInit: allocation error\n");
    }
    if(SKERNEL_IS_CHEETAH3P_ONLY_DEV(devObjPtr))
    {
        /* we needed the number for allocation only .
        do-not tell every body that we have extra descriptor(keep it secret...)*/
        descNumber -= SNET_CHT3_CAPWAP_REASSEMBLY_NUM_ENTRIES_CNS;
    }
    devObjPtr->descrNumber = descNumber;

    /* initiation of internal cheetah functions */
    devObjPtr->devFrameProcFuncPtr = snetChtFrameProcess;
    devObjPtr->devPortLinkUpdateFuncPtr = snetChtLinkStateNotify;
    devObjPtr->devFdbMsgProcFuncPtr = sfdbChtMsgProcess;
    devObjPtr->devMacTblTrigActFuncPtr = sfdbChtMacTableTriggerAction;
    devObjPtr->devMacEntriesAutoAgingFuncPtr = sfdbChtMacTableAutomaticAging;
    devObjPtr->devFromCpuDmaFuncPtr = snetChtFromCpuDmaProcess;
    devObjPtr->devMacTblAgingProcFuncPtr = sfdbChtAutoAging;
    devObjPtr->devMacTblUploadProcFuncPtr = sfdbCht2MacTableUploadAction;
    devObjPtr->devCncFastDumpFuncPtr = snetCht3CncFastDumpFuncPtr;
    devObjPtr->devFromEmbeddedCpuFuncPtr = snetChtFromEmbeddedCpuProcess;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) == 0)
    {
        devObjPtr->devSoftResetFunc = snetChtSoftReset;
    }
    else
    {
        devObjPtr->devSoftResetFunc = skernelDeviceSoftResetGeneric;
        devObjPtr->devSoftResetFuncPart2 = skernelDeviceSoftResetGenericPart2;
    }


}

/*******************************************************************************
*   snetChtRxMacPortGet
*
* DESCRIPTION:
*        Get RX MAC number.
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       slanPort     - SLAN port number that is local port number
*
* RETURN:
*       RX MAC number:
*       Extended mode:  port 9 - MAC 12, port 11 - MAC 14
*       Normal mode: MAC number = port number
*
*******************************************************************************/
static GT_U32 snetChtRxMacPortGet
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                  slanPort
)
{
    GT_U32  fldOffset; /* field offset in register */
    GT_U32  fldValue;  /* field value */
    GT_U32  macNum;    /* MAC number */

    /* only ports 9 and 11 may be connected to extended MACs 12 and 14 */
    if ((devObjPtr->supportExtPortMac == 0) ||
        ((slanPort != 9) && (slanPort != 11)))
    {
        return slanPort;
    }

    fldOffset = (slanPort == 9) ?  7 : 15;
    smemRegFldGet(devObjPtr, SMEM_LION2_RXDMA_HIGH_DMA_IF_CONFIG_REG(devObjPtr), fldOffset, 1, &fldValue);

    macNum = slanPort + 3 * fldValue;
    return macNum;
}

/*******************************************************************************
*   snetChtFrameProcess
*
* DESCRIPTION:
*       Process frames in the Cheetah
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       bufferId     - frame data buffer Id
*       srcPort      - sourcu port number
*
*******************************************************************************/
static GT_VOID snetChtFrameProcess
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SBUF_BUF_ID bufferId,
    IN GT_U32 srcPort
)
{
    /* pointer to the frame's descriptor */
    SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr;

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT___ALLOW_ALL_UNITS___E);/* wild card for LOG without the unit filter */
    simLogPacketFrameCommandSet(SIM_LOG_FRAME_COMMAND_TYPE_GENERAL_E);

    descrPtr = snetChtEqDuplicateDescr(devObjPtr, NULL);

    SIM_LOG_PACKET_DESCR_SAVE

    descrPtr->localDevSrcPort = srcPort;

    if(devObjPtr->numOfPipes)
    {
        /* Update 'currentPipeId' and get new (local) srcPort */
        smemConvertGlobalPortToCurrentPipeId(devObjPtr,srcPort,&srcPort);

    }

    /* save the ingress device*/
    descrPtr->ingressDevObjPtr = devObjPtr;

    descrPtr->frameBuf = bufferId;

    /* get the RXDMA port number */
    descrPtr->ingressRxDmaPortNumber = SMEM_LION2_LOCAL_PORT_TO_RX_DMA_PORT_MAC(devObjPtr,srcPort);

    /* get the MAC port number */
    descrPtr->ingressGopPortNumber = snetChtRxMacPortGet(devObjPtr,descrPtr->localDevSrcPort);

    descrPtr->byteCount = bufferId->actualDataSize;

    if(devObjPtr->portGroupSharedDevObjPtr)
    {
        /* protect the full processing */
        SIM_OS_MAC(simOsMutexLock)(devObjPtr->portGroupSharedDevObjPtr->fullPacketWalkThroughProtectMutex);
    }

    SIM_LOG_PACKET_DESCR_COMPARE("snetChtFrameProcess : prepare packet from network port ");

    snetChtIngress(devObjPtr, descrPtr);


    if(devObjPtr->portGroupSharedDevObjPtr)
    {
        /* protect the egress processing */
        SIM_OS_MAC(simOsMutexUnlock)(devObjPtr->portGroupSharedDevObjPtr->fullPacketWalkThroughProtectMutex);
    }
}

/*******************************************************************************
*
* DESCRIPTION:
*       ingress pipe processing after the TTI unit
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetChtIngressAfterTti
(
        IN SKERNEL_DEVICE_OBJECT * devObjPtr,
        IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngressAfterTti);

    if(devObjPtr->supportCapwap != SKERNEL_CAPWAP_NOT_SUPPORTED_E)
    {
        /* Ingress MAC SA LookUp ,VLAN assignment , RSSI */
        SIM_LOG_PACKET_DESCR_SAVE
        snetChtIngressMacSa(devObjPtr, descrPtr);
        SIM_LOG_PACKET_DESCR_COMPARE("snetChtIngressMacSa");
    }

    /* Policy (PCL and IP-Classifier) processing */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtIPcl(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtIPcl");

    /* Save Ingress VID modification after the PCL,TTI Processing
        (and before the Router) */
    descrPtr->ingressPipeVid = descrPtr->eVid;

    /* L2 Processing */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtL2i(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtL2i");

    if (descrPtr->bypassIngressPipe == GT_FALSE)
    {
        /* L3 routing */
        SIM_LOG_PACKET_DESCR_SAVE
        snetChtRouting(devObjPtr, descrPtr);
        SIM_LOG_PACKET_DESCR_COMPARE("snetChtRouting");
    }
    else
    {
        __LOG(("Router bypassed due to <bypassIngressPipe> \n"));
    }

    /* Policer Processing  */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtIPolicer(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtIPolicer");

    /* L2 Tunnel Replication */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtIngressL2TunnelReplication(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtIngressL2TunnelReplication");

    /* MLL unit entry point */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtMll(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtMll");

    /* EQ Block processing */
    snetChtEq(devObjPtr, descrPtr);
}

/*******************************************************************************
*
* snetChtIngressAfterL3IpReplication:
*       ingress pipe processing after the IP MLL (L3 IP replication) unit
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetChtIngressAfterL3IpReplication
(
        IN SKERNEL_DEVICE_OBJECT * devObjPtr,
        IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    /* L2 MLL Replication */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtIngressL2MllEngine(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtIngressL2MllEngine \n");

    /* EQ Block processing */
    snetChtEq(devObjPtr, descrPtr);

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_MLL_E);
}

/*******************************************************************************
*   snetLion3RxdmaToTti
*
* DESCRIPTION:
*        perform RXDMA unit to TTI unit changes
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*       None
*
*******************************************************************************/
static void snetLion3RxdmaToTti
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetLion3RxdmaToTti);

    GT_U32      virtualPortNum;/*virtualPortNum from the RXDMA*/

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_RXDMA_E);

    /*perform RXDMA mapping from local port to 'virual' port on the field of:
      localDevSrcPort */
    smemRegFldGet(devObjPtr,
        SMEM_LION3_RXDMA_SCDMA_CONFIG_1_REG(devObjPtr,descrPtr->ingressRxDmaPortNumber),
        0, SMEM_CHT_IS_SIP5_20_GET(devObjPtr) ? 9 : 8, &virtualPortNum);

    __LOG(("perform RXDMA mapping from local port[%d] to virtual port[%d] on the field of <localDevSrcPort>",
                  descrPtr->localDevSrcPort,virtualPortNum));

    /* change the <localDevSrcPort> only after we are done with the MAC counters
       and the MAC configurations that are according to 'RXDMA port num'*/


    /* this must be done before first access to the TTI-Physical Port Attribute Table:
       <LocalDevSrcPort> as received from WRDMA, i.e. global physical port number */
    descrPtr->localDevSrcPort = virtualPortNum;

    /* from this point : <LocalDevSrcPort> as received from WRDMA, i.e. global physical port number */

    /* save info that used by the BMA/BM (buffer management) of the device */
    if(devObjPtr->numOfPipes &&
       devObjPtr->multiDataPath.supportRelativePortNum)
    {
        /* the RxDma number is '0' based .
           need to convert it to global number in the device */
        smemConvertCurrentPipeIdAndLocalPortToGlobal(devObjPtr,
            descrPtr->ingressRxDmaPortNumber,
            &descrPtr->localDevSrcPort_fromRxDma_forBma);
    }
    else
    {
        /* the RxDma number is 'global' based . */
        descrPtr->localDevSrcPort_fromRxDma_forBma = descrPtr->ingressRxDmaPortNumber;
    }

    __LOG_PARAM(descrPtr->localDevSrcPort_fromRxDma_forBma);
}

/*******************************************************************************
* snetLion3IngressReassignSrcEPort
*
* DESCRIPTION:
*        TRILL/TTI/PCL reassign new src EPort
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to frame descriptor
*       clientNamePtr - the name of the client (for the LOGGER)
*       newSrcEPort - the new srcEPort
* OUTPUTS:
*       descrPtr     - pointer to frame descriptor
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
GT_VOID snetLion3IngressReassignSrcEPort
(
    IN    SKERNEL_DEVICE_OBJECT             *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   *descrPtr,
    IN    GT_CHAR*                          clientNamePtr,
    IN    GT_U32                            newSrcEPort
)
{
    DECLARE_FUNC_NAME(snetLion3IngressReassignSrcEPort);

    if(descrPtr->origIsTrunk)
    {
        __LOG(("src orig was 'trunk' [%d] will be modified to 'eport' [%d] \n",
            descrPtr->origSrcEPortOrTrnk,
            newSrcEPort));
    }

    if(descrPtr->srcDev != descrPtr->ownDev)
    {
        __LOG(("src device [%d]will be modified to [%d] \n",
            descrPtr->srcDev,
            descrPtr->ownDev));
    }

    descrPtr->eArchExtInfo.localDevSrcEPort = newSrcEPort;
    descrPtr->origSrcEPortOrTrnk = newSrcEPort;
    descrPtr->origIsTrunk = 0;
    descrPtr->srcDev = descrPtr->ownDev;
    descrPtr->srcDevIsOwn = 1;

    __LOG(("[%s] Reassigns new Source EPort [%d] \n",
        clientNamePtr ? clientNamePtr : "unknown",
        newSrcEPort));

    return;
}


/*******************************************************************************
*
* DESCRIPTION:
*       Ingress processing of frames
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetChtIngress
(
        IN SKERNEL_DEVICE_OBJECT * devObjPtr,
        IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngress);

    GT_STATUS st = GT_OK;
    INTERNAL_TTI_DESC_INFO_STC  internalTtiInfo;

    /* save info to log */
    __LOG((SIM_LOG_IN_PACKET_STR
            "start new frame on: deviceName[%s],deviceId[%d], \n"
            "                    portGroupId[%d],srcPort[%d] \n",
            devObjPtr->deviceName,
            devObjPtr->deviceId,
            devObjPtr->portGroupId ,
            descrPtr->localDevSrcPort));

    /* save info to the descriptor even if packet discard , for the LOG info */
    SIM_LOG_PACKET_DESCR_SAVE
    descrPtr->startFramePtr = descrPtr->frameBuf->actualDataPtr;
    descrPtr->byteCount = descrPtr->frameBuf->actualDataSize;
    descrPtr->origByteCount = descrPtr->byteCount;

    __LOG(("frame dump:  \n"));
    simLogPacketDescrFrameDump(devObjPtr, descrPtr);

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_PORT_MAC_INGRESS_E);

    st = snetChtRxPort(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtRxPort");

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT___ALLOW_ALL_UNITS___E);/* wild card for LOG without the unit filter */

    /* Rx Port layer processing of frames */
    if (st == GT_FALSE)
    {
        /* packet was dropped by the "MAC/PHY" layer */
        __LOG(("Packet was dropped by the 'MAC/PHY' layer. (or the RxDMA unit)"));

        __LOG((SIM_LOG_ENDED_IN_PACKET_STR
                "ended processing frame from: deviceName[%s],deviceId[%d], \n"
                "                    portGroupId[%d],srcPort[%d] \n",
                devObjPtr->deviceName,
                devObjPtr->deviceId,
                devObjPtr->portGroupId ,
                descrPtr->localDevSrcPort));

        return;
    }

    /* Init the internal TTI unit info */
    memset(&internalTtiInfo,0,sizeof(INTERNAL_TTI_DESC_INFO_STC));

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_TTI_E);

    SIM_LOG_PACKET_DESCR_SAVE
    /* Parse frames header and assign VLAN/QoS Port Protocol */
    snetChtFrameParsingVlanAssign(devObjPtr, descrPtr,&internalTtiInfo);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtFrameParsingVlanAssign");

    /* Tunnel Termination processing */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtTTermination(devObjPtr, descrPtr,&internalTtiInfo);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtTTermination");

    /* continue the ingress pipe after the TTI unit */
    snetChtIngressAfterTti(devObjPtr, descrPtr);

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT___ALLOW_ALL_UNITS___E);/* wild card for LOG without the unit filter */

    __LOG((SIM_LOG_ENDED_IN_PACKET_STR
            "ended processing frame from: deviceName[%s],deviceId[%d], \n"
            "                    portGroupId[%d],srcPort[%d] \n",
            devObjPtr->deviceName,
            devObjPtr->deviceId,
            devObjPtr->portGroupId ,
            descrPtr->localDevSrcPort));

    return;
}

/*******************************************************************************
*   snetSip5_10RxDmaPipCheck
*
* DESCRIPTION:
*        RxDma Pre-Ingress Prioritization (PIP) processing of frames
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*       GT_TRUE  - continue packet processing
*       GT_FALSE - terminate packet processing
*
*******************************************************************************/
static GT_BOOL snetSip5_10RxDmaPipCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetSip5_10RxDmaPipCheck);

    GT_U32 regAddress;          /* register address */
    GT_U32 fldValue;            /* register's field address */
    GT_U32 portNum = descrPtr->ingressRxDmaPortNumber;/* rxDma port number */
    GT_U32 Port_Default_PIP_Priority;
    GT_U32 pipProfile;
    GT_U32 pipPriority = 0;
    GT_U32 firstWordAfterMacSa,secondWordAfterMacSa;
    GT_U32 byteIndex;
    GT_U32 fieldIndex = 0;
    GT_U32 etherType,vid;
    GT_U32 packetEtherType;
    GT_U32 ii;
    GT_BIT matched = 0;
    GT_U32 mpls_exp , ipv4_tos , ipv6_tc;
    GT_U32 packet_macDa_2_msb , packet_macDa_4_lsb;
    GT_U32 macDa_2_msb , macDa_4_lsb;
    GT_U32 macDa_2_msb_mask , macDa_4_lsb_mask;
    GT_U32  unitIndex = SMEM_DUAL_UNIT_DMA_UNIT_INDEX_GET(devObjPtr,portNum);

    regAddress = SMEM_SIP_5_10_RXDMA_PIP_ENABLE_REG(devObjPtr,unitIndex);
    smemRegFldGet(devObjPtr, regAddress, 0, 1, &fldValue);

    if(fldValue == 0)
    {
        __LOG(("PIP : Globally disabled \n"));
        return GT_TRUE;
    }

    regAddress = SMEM_SIP_5_10_RXDMA_PIP_SCDMA_N_PIP_CONFIG_REG(devObjPtr,portNum);
    smemRegFldGet(devObjPtr, regAddress, 0, 1, &fldValue);
    smemRegFldGet(devObjPtr, regAddress, 1, 2, &Port_Default_PIP_Priority);

    if(fldValue == 0)
    {
        __LOG(("PIP : the ingress rxDMA port [%d] is 'not trusted' ... use default PIP priority [%d] \n",
            portNum ,Port_Default_PIP_Priority));

        pipPriority = Port_Default_PIP_Priority;
    }
    else
    {
        smemRegFldGet(devObjPtr, regAddress, 3, 2, &pipProfile);

        __LOG_PARAM(pipProfile);

        __LOG(("PIP : the ingress rxDMA port [%d] is 'trusted' \n",
            portNum));

        byteIndex = 12;
        firstWordAfterMacSa =    descrPtr->macDaPtr[byteIndex + 0] << 24 |
                                 descrPtr->macDaPtr[byteIndex + 1] << 16 |
                                 descrPtr->macDaPtr[byteIndex + 2] <<  8 |
                                 descrPtr->macDaPtr[byteIndex + 3] <<  0 ;
        byteIndex +=4 ;
        secondWordAfterMacSa =   descrPtr->macDaPtr[byteIndex + 0] << 24 |
                                 descrPtr->macDaPtr[byteIndex + 1] << 16 |
                                 descrPtr->macDaPtr[byteIndex + 2] <<  8 |
                                 descrPtr->macDaPtr[byteIndex + 3] <<  0 ;

        __LOG_PARAM(firstWordAfterMacSa);
        __LOG_PARAM(secondWordAfterMacSa);

        if(descrPtr->marvellTagged)
        {
            /* check the DSA type */
            if(SMEM_U32_GET_FIELD(firstWordAfterMacSa,30,2) == 3 /*Tag Command*/&&
               SMEM_U32_GET_FIELD(firstWordAfterMacSa,12,1) /*Extend*/)
            {
                fieldIndex = SMEM_U32_GET_FIELD(secondWordAfterMacSa,13,7);

                __LOG(("PIP: DSA TAG 'FORWARD' Extended/eDsa so use <QoSProfile> [%d] \n",
                    fieldIndex));

                regAddress = SMEM_SIP_5_10_RXDMA_PIP_QOS_DSA_PRIORITY_ARRAY_PROFILE_N_SEGMENT_M_REG(
                                devObjPtr,pipProfile,fieldIndex,unitIndex);
            }
            else
            {
                fieldIndex = SMEM_U32_GET_FIELD(firstWordAfterMacSa,13,3);

                __LOG(("PIP: DSA TAG without <QoSProfile> so use <UP> [%d] \n",
                    fieldIndex));

                regAddress = SMEM_SIP_5_10_RXDMA_PIP_UP_DSA_TAG_ARRAY_PROFILE_N_REG(
                                devObjPtr,pipProfile,unitIndex);
            }

            matched = 1;
        }
        else
        {
            packetEtherType = SMEM_U32_GET_FIELD(firstWordAfterMacSa,16,16);
            __LOG_PARAM(packetEtherType);

            /* check Is <portN> and <VID classification enabled> and (EtherType & VID) pair
                equal to one of 4 pairs of (<VLAN EtherType Conf> & <VID Conf>) arrays */
            smemRegFldGet(devObjPtr, regAddress, 5, 1, &fldValue);
            if(fldValue)
            {
                __LOG(("PIP : rxDMA port [%d] is enabled for {etherType,vid} lookup \n",
                    portNum));

                for(ii = 0 ; ii < 4 ; ii++)
                {
                    smemRegFldGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_VLAN_ETHERTYPE_CONF_N_REG(devObjPtr, ii,unitIndex),
                        0, 16, &etherType);

                    smemRegFldGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_VID_CONF_N_REG(devObjPtr, ii,unitIndex),
                        0, 12, &vid);

                    __LOG(("PIP : check match for etherType [0x%x] and vid [%d] in index [%d] \n",
                        etherType,vid,ii));

                    if(vid       == SMEM_U32_GET_FIELD(firstWordAfterMacSa, 0,12) &&
                       etherType == packetEtherType)
                    {
                        __LOG(("PIP : the etherType [0x%x] and vid [%d] matched index [%d] \n",
                            etherType,vid,ii))

                        smemRegFldGet(devObjPtr,
                            SMEM_SIP_5_10_RXDMA_PIP_SCDMA_N_PIP_CONFIG_REG(devObjPtr,portNum),
                            6, 2, &fldValue);

                        pipPriority = fldValue;

                        __LOG(("PIP : so use (per port) VID classification PIP priority [%d] \n",
                            pipPriority));

                        goto got_pip_priority_lbl;
                    }
                }

                /* no match in <VLAN EtherType Conf> & <VID Conf> */
                __LOG(("PIP : the etherType [0x%x] and vid [%d] was not matched \n",
                    packetEtherType,
                    SMEM_U32_GET_FIELD(firstWordAfterMacSa, 0,12)));
            }
            else
            {
                __LOG(("PIP : rxDMA port [%d] is disabled for {etherType,vid} lookup \n",
                    portNum));
            }

            __LOG(("PIP : Check if EtherType is 'vlan tag' (TPID) \n"));

            /* check if EtherType equals one of 4 values in <VLAN EtherType Conf> array */
            for(ii = 0 ; ii < 4 ; ii++)
            {
                smemRegFldGet(devObjPtr,
                    SMEM_SIP_5_10_RXDMA_PIP_VLAN_ETHERTYPE_CONF_N_REG(devObjPtr, ii,unitIndex),
                    0, 16, &etherType);

                __LOG(("PIP : check match for etherType [0x%x] in index [%d] \n",
                    etherType,ii));

                if(etherType == packetEtherType)
                {
                    fieldIndex = SMEM_U32_GET_FIELD(firstWordAfterMacSa,13,3);
                    __LOG(("PIP : the etherType [0x%x] matched index [%d] - as vlan tag  , use <UP> [%d]  \n",
                        etherType,ii,fieldIndex))

                    regAddress = SMEM_SIP_5_10_RXDMA_PIP_VLAN_UP_PRIORITY_ARRAY_PROFILE_N_REG(
                                    devObjPtr,pipProfile,unitIndex);

                    matched = 1;
                    break;
                }
            }/* vlan tag */

            if(0 == matched)
            {
                __LOG(("PIP : the etherType [0x%x] not matched as 'vlan tag' \n",
                    packetEtherType));
            }

            if(0 == matched)
            {
                __LOG(("PIP : Check if EtherType is MPLS \n"));
                for(ii = 0 ; ii < 2 ; ii++)
                {
                    smemRegFldGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_MPLS_ETHERTYPE_CONF_N_REG(devObjPtr, ii,unitIndex),
                        0, 16, &etherType);

                    __LOG(("PIP : check match for etherType [0x%x] in index [%d] \n",
                        etherType,ii));

                    if(etherType == packetEtherType)
                    {
                        mpls_exp = SMEM_U32_GET_FIELD(secondWordAfterMacSa, 25,3);
                        __LOG_PARAM(mpls_exp);

                        __LOG(("PIP : the etherType [0x%x] matched index [%d] - as MPLS , use <EXP> [%d] \n",
                            etherType,ii,mpls_exp));

                        fieldIndex = mpls_exp;

                        regAddress = SMEM_SIP_5_10_RXDMA_PIP_MPLS_EXP_PRIORITY_ARRAY_PROFILE_N_REG(
                                        devObjPtr,pipProfile,unitIndex);

                        matched = 1;
                        break;
                    }
                }

                if(0 == matched)
                {
                    __LOG(("PIP : the etherType [0x%x] not matched as MPLS \n",
                        packetEtherType));
                }
            }/* mpls */

            if(0 == matched)
            {
                __LOG(("PIP : Check if EtherType is IPv4 \n"));
                smemRegFldGet(devObjPtr,
                    SMEM_SIP_5_10_RXDMA_PIP_IPV4_ETHERTYPE_CONF_REG(devObjPtr,unitIndex),
                    0, 16, &etherType);

                if(etherType == packetEtherType)
                {
                    ipv4_tos = SMEM_U32_GET_FIELD(firstWordAfterMacSa, 0,8);
                    __LOG_PARAM(ipv4_tos);

                    __LOG(("PIP : the etherType [0x%x] matched as IPv4 , use <TOS> [%d] \n",
                        etherType,ipv4_tos))

                    fieldIndex = ipv4_tos;

                    regAddress = SMEM_SIP_5_10_RXDMA_PIP_IPV4_TOS_PRIORITY_ARRAY_PROFILE_N_SEGMENT_M_REG(
                                    devObjPtr,pipProfile,fieldIndex,unitIndex);

                    matched = 1;
                }
                else
                {
                    __LOG(("PIP : the etherType [0x%x] not matched as IPv4 \n",
                        packetEtherType));
                }
            }/*IPv4*/

            if(0 == matched)
            {
                __LOG(("PIP : Check if EtherType is IPv6 \n"));
                smemRegFldGet(devObjPtr,
                    SMEM_SIP_5_10_RXDMA_PIP_IPV6_ETHERTYPE_CONF_REG(devObjPtr,unitIndex),
                    0, 16, &etherType);

                if(etherType == packetEtherType)
                {
                    ipv6_tc = SMEM_U32_GET_FIELD(firstWordAfterMacSa, 4,8);
                    __LOG_PARAM(ipv6_tc);

                    fieldIndex = ipv6_tc;

                    if (devObjPtr->errata.rxdmaPipIpv6WrongBitsTc)
                    {
                        __LOG(("WARNING : Erratum : only the ipv6_tc taken from wrong offset \n"));
                        /* we not use the actual 'TC' from the ipv6 header ... but the 8 bits from 'wrong' offset */
                        fieldIndex = SMEM_U32_GET_FIELD(firstWordAfterMacSa, 2/*wrong offset*/,8);
                        __LOG(("PIP : the etherType [0x%x] matched as IPv6 , with <TC from ipv6 header> [%d] , but 'register access actual tc' is [%d] \n",
                            etherType,ipv6_tc,fieldIndex))
                    }
                    else
                    {
                        __LOG(("PIP : the etherType [0x%x] matched as IPv6 , with <TC> [%d] \n",
                            etherType,ipv6_tc))
                    }

                    regAddress = SMEM_SIP_5_10_RXDMA_PIP_IPV6_TC_PRIORITY_ARRAY_PROFILE_N_SEGMENT_M_REG(
                                    devObjPtr,pipProfile,fieldIndex,unitIndex);

                    matched = 1;
                }
                else
                {
                    __LOG(("PIP : the etherType [0x%x] not matched as IPv6 \n",
                        packetEtherType));
                }
            }/* ipv6 */

            if(0 == matched)
            {
                __LOG(("PIP : Check if EtherType is UDE (user defined etherType) - generic etherType \n"));
                for(ii = 0 ; ii < 4 ; ii++)
                {
                    smemRegFldGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_GENERIC_ETHERTYPE_N_REG(devObjPtr, ii,unitIndex),
                        0, 16, &etherType);

                    __LOG(("check match for etherType [0x%x] in index [%d] \n",
                        etherType,ii));

                    if(etherType == packetEtherType)
                    {
                        __LOG(("PIP : the etherType [0x%x] matched index [%d] - as UDE \n",
                            etherType,ii))

                        fieldIndex = ii;

                        regAddress = SMEM_SIP_5_10_RXDMA_PIP_ETHERTYPE_PRIORITY_ARRAY_PROFILE_N_REG(
                                        devObjPtr,pipProfile,unitIndex);

                        matched = 1;
                        break;
                    }
                }

                if(0 == matched)
                {
                    __LOG(("PIP : the etherType [0x%x] not matched as UDE \n",
                        packetEtherType));
                }
            }/* UDE */

            if(0 == matched)
            {
                __LOG(("PIP : Check if MAC DA match 'well known' address \n"));


                byteIndex = 0;
                packet_macDa_2_msb = descrPtr->macDaPtr[byteIndex + 0] <<  8 |
                                     descrPtr->macDaPtr[byteIndex + 1] <<  0 ;
                byteIndex += 2;
                packet_macDa_4_lsb = descrPtr->macDaPtr[byteIndex + 0] << 24 |
                                     descrPtr->macDaPtr[byteIndex + 1] << 16 |
                                     descrPtr->macDaPtr[byteIndex + 2] <<  8 |
                                     descrPtr->macDaPtr[byteIndex + 3] <<  0 ;

                __LOG(("PIP : packet mac DA [0x%4.4x%8.8x] \n",
                    packet_macDa_2_msb,packet_macDa_4_lsb));

                for(ii = 0 ; ii < 4 ; ii++)
                {
                    smemRegFldGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_MAC_DA_2_MSB_BYTES_CONF_N_REG(devObjPtr, ii,unitIndex),
                        0, 16, &macDa_2_msb);
                    smemRegGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_MAC_DA_4_LSB_BYTES_CONF_N_REG(devObjPtr, ii,unitIndex),
                        &macDa_4_lsb);

                    smemRegFldGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_MAC_DA_MASK_2_MSB_CONF_N_REG(devObjPtr, ii,unitIndex),
                        0, 16, &macDa_2_msb_mask);
                    smemRegGet(devObjPtr,
                        SMEM_SIP_5_10_RXDMA_PIP_MAC_DA_MASK_4_LSB_CONF_N_REG(devObjPtr, ii,unitIndex),
                        &macDa_4_lsb_mask);

                    __LOG(("check match for macDa in index [%d] with value [0x%4.4x%8.8x] mask[0x%4.4x%8.8x] \n",
                        ii,
                        macDa_2_msb,macDa_4_lsb,
                        macDa_2_msb_mask,macDa_4_lsb_mask));


                    if((packet_macDa_2_msb & macDa_2_msb_mask) == macDa_2_msb &&
                       (packet_macDa_4_lsb & macDa_4_lsb_mask) == macDa_4_lsb )
                    {
                        __LOG(("PIP : the mac addr matched index [%d] \n",
                            ii))

                        fieldIndex = ii;

                        regAddress = SMEM_SIP_5_10_RXDMA_PIP_MAC_DA_PRIORITY_ARRAY_PROFILE_N_REG(
                                        devObjPtr,pipProfile,unitIndex);

                        matched = 1;
                        break;
                    }
                }

                if(0 == matched)
                {
                    __LOG(("PIP : the macDa not matched \n"));
                }
            }/* macDa */
        }

        if(0 == matched)
        {
            __LOG(("PIP : no classification matched the packet ... use default PIP priority [%d] \n",
                Port_Default_PIP_Priority));

            pipPriority = Port_Default_PIP_Priority;
        }
        else
        {
            smemRegFldGet(devObjPtr, regAddress, 2 * (fieldIndex % 16) , 2, &fldValue);

            __LOG(("PIP : the classification resulted PIP priority [%d] \n",
                fldValue));

            pipPriority = fldValue;
        }
    }

    if(pipPriority > 2)
    {
        __LOG(("WARNING : potential configuration ERROR : pipPriority [%d] more them 'max' 2 \n",
            pipPriority));
        __LOG(("Simulation will treat it as 2 'low priority' \n"));
        pipPriority = 2;
    }

got_pip_priority_lbl:

    __LOG(("PIP : the pip priority considered as [%s] \n" ,
        (pipPriority == 0) ? "HIGH" :
            (pipPriority == 1) ? "MEDIUM" : "LOW" ));

    regAddress = SMEM_SIP_5_10_RXDMA_PIP_PRIO_THRESHOLDS_REG(devObjPtr,unitIndex);
    smemRegFldGet(devObjPtr, regAddress, 10*pipPriority, 10, &fldValue);

    __LOG(("PIP : The global threshold value for this pip priority is [%d] \n",
        fldValue));

    if(fldValue == 0)
    {
        __LOG(("PIP : Simulation Dropped the packet as threshold is 0 \n"));

        /* do counting : 'per priority' and 'per port' */

        /* per port */
        regAddress = SMEM_SIP_5_10_RXDMA_PIP_SCDMA_N_DROP_PKT_COUNTER(devObjPtr,portNum);
        smemRegGet(devObjPtr, regAddress, &fldValue);
        __LOG(("PIP : port [%d] counter : Increment PIP drop Counter from [%d] \n",
            portNum,fldValue));
        smemRegSet(devObjPtr, regAddress, ++fldValue);

        /* per priority */
        regAddress = SMEM_SIP_5_10_RXDMA_PIP_PRIORITY_DROP_GLOBAL_COUNTERS_CLEAR_REG(devObjPtr,unitIndex);
        smemRegGet(devObjPtr, regAddress, &fldValue);

        /* bit 0 - low  ---> pipPriority = 2 */
        /* bit 1 - med  ---> pipPriority = 1 */
        /* bit 2 - high ---> pipPriority = 0 */
        if(1 == (fldValue & (1 << (2 - pipPriority))))
        {
            __LOG(("PIP : Global configuration not allow priority [%d] to count the PIP drops \n",
                pipPriority))
        }
        else
        {
            GT_U32  regAddr1,regAddr2,fldValue1,fldValue2;

            if(pipPriority == 0)
            {
                regAddr1 = SMEM_SIP_5_10_RXDMA_PIP_HIGH_PRIORITY_DROP_GLOBAL_COUNTER_MSB_REG(devObjPtr,unitIndex);
                regAddr2 = SMEM_SIP_5_10_RXDMA_PIP_HIGH_PRIORITY_DROP_GLOBAL_COUNTER_LSB_REG(devObjPtr,unitIndex);
            }
            else if (pipPriority == 1)
            {
                regAddr1 = SMEM_SIP_5_10_RXDMA_PIP_MED_PRIORITY_DROP_GLOBAL_COUNTER_MSB_REG(devObjPtr,unitIndex);
                regAddr2 = SMEM_SIP_5_10_RXDMA_PIP_MED_PRIORITY_DROP_GLOBAL_COUNTER_LSB_REG(devObjPtr,unitIndex);
            }
            else
            {
                regAddr1 = SMEM_SIP_5_10_RXDMA_PIP_LOW_PRIORITY_DROP_GLOBAL_COUNTER_MSB_REG(devObjPtr,unitIndex);
                regAddr2 = SMEM_SIP_5_10_RXDMA_PIP_LOW_PRIORITY_DROP_GLOBAL_COUNTER_LSB_REG(devObjPtr,unitIndex);
            }

            SCIB_SEM_TAKE;

            smemRegGet(devObjPtr, regAddr1, &fldValue1);
            smemRegGet(devObjPtr, regAddr2, &fldValue2);
            __LOG(("PIP : priority [%d] counter : Increment PIP drop Counter from [0x%x](high32)[0x%x](low32) \n",
                pipPriority,fldValue1,fldValue2));
            smemRegSet(devObjPtr, regAddr2, ++fldValue2);
            if(fldValue2 == 0)
            {
                smemRegSet(devObjPtr, regAddr1, ++fldValue1);
            }

            SCIB_SEM_SIGNAL;
        }


        return GT_FALSE;
    }

    __LOG(("PIP : processing ended ... packet pass to the ingress pipe \n"));

    return GT_TRUE;
}


/*******************************************************************************
*   snetChtRxPort
*
* DESCRIPTION:
*        Rx Port layer processing of frames
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*       GT_TRUE - continue packet processing
*       GT_FALSE - terminate packet processing
*
*******************************************************************************/
static GT_BOOL snetChtRxPort
(
        IN SKERNEL_DEVICE_OBJECT * devObjPtr,
        IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtRxPort);

    GT_U32 * regPtr;            /* register entry pointer */
    GT_U32 regAddress;          /* register address */
    GT_U32 fldValue;            /* register's field address */
    GT_BOOL retVal;             /* return flag */
    GT_BOOL overSize;           /* frame size oversized flag */
    GT_U32         outputPortBit,outputPortBit1;  /* the bit index for the egress port  */
    GT_BOOL        isSecondRegister;/* is the per port config is in second register -- for bmp of ports */
    SNET_FLOW_CONTROL_PACKET_TYPE_ENT   fcPacketType=SNET_NOT_FC_PACKET_E;   /* classification of Flow Control packet */
    GT_U32  macPort;   /* MAC Port number */
    /* setting of : devObjPtr->descrFreeIndx
       since the simulation actually have single task to process the packets ,
       we can be assure that no 'previous' descriptors for this device/portGroup
       are in use .

       it was moved from the functions of : snetChtFrameProcess
       because the traffic enter the device also from : snetChtFromCpuDmaProcess
    */
    devObjPtr->descrFreeIndx = 1;

    /* state the packet has L2 valid info */
    descrPtr->l2Valid = 1;

    descrPtr->bmpOfHemisphereMapperPtr = &descrPtr->bmpOfHemisphereMapper;

    macPort = descrPtr->ingressGopPortNumber;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) ||
       SKERNEL_XCAT3_FAMILY == devObjPtr->deviceFamily)
    {
        smemDfxRegFldGet(devObjPtr, SMEM_LION2_DFX_SERVER_RESET_CONTROL_REG(devObjPtr), 0, 1, &fldValue);
    }
    else if(SKERNEL_IS_LION2_DEV(devObjPtr))
    {
        smemRegFldGet(devObjPtr, SMEM_LION2_DFX_SERVER_RESET_CONTROL_REG(devObjPtr), 0, 1, &fldValue);
    }
    else
    {
        smemRegFldGet(devObjPtr, SMEM_CHT_GLB_CTRL_REG(devObjPtr), 0, 1, &fldValue);
    }

    /* DeviceEn */
    if (fldValue != 1)
    {
        __LOG(("packet dropped : <DeviceEn> == 0"));
        return GT_FALSE;
    }

    overSize = GT_FALSE;

    if(descrPtr->isFromSdma)
    {
        /* SDMA CPU port not care about mac related issues */
        __LOG(("CPU port as 'SDMA' not have 'link up' and 'port enabled' issues \n"));
    }
    else
    {
        if(descrPtr->ingressGopPortNumber >= SKERNEL_DEV_MAX_SUPPORTED_PORTS_CNS)
        {
            skernelFatalError("snetChtRxPort: invalid MAC number [%d] \n",
                descrPtr->ingressGopPortNumber);
        }

        /* check Port Enable bit for regular ports and MII/RGMII CPU Ports */
        regAddress =
            SMEM_CHT_MAC_CONTROL0_REG(devObjPtr, macPort);

        smemRegFldGet(devObjPtr, regAddress, 0, 1, &fldValue);
        /* PortEn */
        if (fldValue != 1)
        {
            __LOG(("packet dropped : <PortEn> == 0"));
            return GT_FALSE;
        }

        if(macPort != SNET_CHT_CPU_PORT_CNS)
        {
            regAddress =
                SMEM_CHT_PORT_STATUS0_REG(devObjPtr, macPort);

            smemRegFldGet(devObjPtr, regAddress, 0, 1, &fldValue);
            /* LinkUp */
            if (fldValue != 1)
            {
                __LOG(("packet dropped : <LinkUp> == 0"));
                return GT_FALSE;
            }
        }
    }

    descrPtr->packetTimestamp = SIM_OS_MAC(simOsTickGet)();
    descrPtr->ipFixTimeStampValue = descrPtr->packetTimestamp;
    descrPtr->macDaPtr = DST_MAC_FROM_DSCR(descrPtr);
    descrPtr->macSaPtr = SRC_MAC_FROM_DSCR(descrPtr);

    /* Fill MAC data type of descriptor */
    if (SGT_MAC_ADDR_IS_MCST(descrPtr->macDaPtr))
    {
        if (SGT_MAC_ADDR_IS_BCST(descrPtr->macDaPtr))
        {
            descrPtr->macDaType = SKERNEL_BROADCAST_MAC_E;
            __LOG(("macDaType == SKERNEL_BROADCAST_MAC_E"));
        }
        else
        {
            descrPtr->macDaType = SKERNEL_MULTICAST_MAC_E;
            __LOG(("macDaType == SKERNEL_MULTICAST_MAC_E"));
        }
    }
    else
    {
        descrPtr->macDaType = SKERNEL_UNICAST_MAC_E;
        __LOG(("macDaType == SKERNEL_UNICAST_MAC_E"));
    }

    if(descrPtr->isFromSdma)
    {
        /* SDMA CPU port not care about mac related issues */
        __LOG(("CPU port as 'SDMA' not have 'flow control' and 'MAC mib counters' issues \n"));
    }
    else
    if(snetChtDoForwardFcFrame(devObjPtr, descrPtr, &fcPacketType) == GT_FALSE)
    {
        /* protect RX MAC MIB counters from simultaneous access with management. */
        SCIB_SEM_TAKE;

        /* Update pause frame MAC counter */
        snetChtRxMacCountUpdate(devObjPtr, descrPtr, overSize, fcPacketType, macPort);

        SCIB_SEM_SIGNAL;

        __LOG(("packet dropped : not forward FC frame"));

        return GT_FALSE;
    }

    smemRegFldGet(devObjPtr, SMEM_CHT_GLB_CTRL_REG(devObjPtr), 4,
        devObjPtr->flexFieldNumBitsSupport.hwDevNum,
        &fldValue);
    /* ownDevNum[4:0] */
    descrPtr->ownDev = fldValue;

    /* set the 'hard wired' port group Id of the port group */
    descrPtr->srcCoreId = devObjPtr->portGroupId;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* Cascade port enable */
        smemRegFldGet(devObjPtr,
            SMEM_LION3_RXDMA_SCDMA_CONFIG_0_REG(devObjPtr,descrPtr->ingressRxDmaPortNumber),
            3,1,&descrPtr->marvellTagged);
    }
    else if(devObjPtr->txqRevision) /* LionB , Lion2 */
    {
        /* Cascade port enable */
        smemRegFldGet(devObjPtr,
            SMEM_LION_RXDMA_CUT_THROUGH_CASCADING_PORT_REG(devObjPtr),
            (descrPtr->ingressRxDmaPortNumber & 0xf),1,&descrPtr->marvellTagged);
    }
    else
    {
        /* !!! get register from the HA unit !!! */
        __LOG(("!!! get register from the HA unit !!!"));
        snetChtHaPerPortInfoGet(devObjPtr,descrPtr->ingressRxDmaPortNumber,&isSecondRegister,&outputPortBit);

        if (descrPtr->ingressRxDmaPortNumber == SNET_CHT_CPU_PORT_CNS && /* send packet to cpu */
            devObjPtr->supportHa64Ports == 0)
        {
            /* get the cpu port bit index */
            outputPortBit1 = SMEM_CHT_GET_CPU_PORT_BIT_INDEX_IN_CSCD_STATUS(devObjPtr);
        }
        else
        {
            outputPortBit1 = outputPortBit;
        }

        regAddress = SMEM_CHT_CAS_HDR_INS_REG(devObjPtr);
        if(isSecondRegister == GT_TRUE)
        {
            regAddress +=4;
        }

        regPtr = smemMemGet(devObjPtr, regAddress);
        descrPtr->marvellTagged = SMEM_U32_GET_FIELD(regPtr[0],outputPortBit1,1);
    }

    if(descrPtr->isFromSdma)
    {
        /* SDMA CPU port not care about mac related issues */
        retVal = GT_TRUE;

        if(descrPtr->byteCount < 64)
        {
            /* undersize --> drop it */
            retVal = GT_FALSE;
            __LOG(("packet dropped : undersize byteCount[%d] (less then 64 including CRC)",
                   descrPtr->byteCount));
        }
    }
    else
    {
        if(IS_CHT_HYPER_GIGA_PORT(devObjPtr,macPort))
        {
            /* XG port */
            regAddress = SMEM_CHT_MAC_CONTROL_REG(devObjPtr, macPort);
            regPtr = smemMemGet(devObjPtr, regAddress);

            fldValue = SMEM_U32_GET_FIELD(regPtr[0], 0, 13);
        }
        else
        {
            /* Gig port */
            regAddress = SMEM_CHT_MAC_CONTROL0_REG(devObjPtr, macPort);
            regPtr = smemMemGet(devObjPtr, regAddress);

            fldValue = SMEM_U32_GET_FIELD(regPtr[0], 2, 13);
        }

        /* FrameSizeLimit - Maximal Received Packet Size (MRU)*/
        /* The resolution of this field is 2 bytes and
         * the default value is 1522 bytes => 0x2f9
         */
        if ((fldValue * 2) >= descrPtr->byteCount)
        {
            overSize = GT_FALSE;
            retVal = GT_TRUE;
            if(descrPtr->byteCount < 60)
            {
                /* undersize --> drop it */
                retVal = GT_FALSE;
                __LOG(("packet dropped : undersize byteCount[%d] (less then 60)",
                    descrPtr->byteCount));
            }
        }
        else
        {
            retVal = GT_FALSE;
            overSize = GT_TRUE;
            __LOG(("packet dropped : packet oversize : byteCount[%d] more then MRU [%d] \n",
                descrPtr->byteCount,
                (fldValue * 2)));
        }

        if(IS_CHT_HYPER_GIGA_PORT(devObjPtr,macPort))
        {
            /* XG port */
            regAddress = SMEM_CHT_MAC_CONTROL0_REG(devObjPtr, macPort);
            regPtr = smemMemGet(devObjPtr, regAddress);

            /* field is 'MIBCntDis' */
            fldValue = 1 - SMEM_U32_GET_FIELD(regPtr[0], 15, 1);
        }
        else
        {
            /* field is 'MIBCntEn' */
            fldValue = SMEM_U32_GET_FIELD(regPtr[0], 15, 1);
        }

        /* MIBCntEn */
        if (fldValue)
        {
            /* protect RX MAC MIB counters from simultaneous access with management. */
            SCIB_SEM_TAKE;

            snetChtRxMacCountUpdate(devObjPtr, descrPtr, overSize, fcPacketType, macPort);

            SCIB_SEM_SIGNAL;
        }
        else
        {
            __LOG(("MIB counters are not allowed to be update for mac [%d] (update is disabled)\n" , macPort));
        }
    }

    /* Set initial values for target device/port */
    descrPtr->trgEPort = SNET_CHT_NULL_PORT_CNS;
    descrPtr->trgDev = descrPtr->ownDev;
    descrPtr->eArchExtInfo.isTrgPhyPortValid = 0;
    descrPtr->eArchExtInfo.trgPhyPort = SNET_CHT_NULL_PORT_CNS;
    /* Use Ingress VID modification */
    descrPtr->useIngressPipeVid = GT_TRUE;
    descrPtr->tag0Ptr =  NULL;
    descrPtr->tag1Ptr =  NULL;
    /* not initialized yet - the 'per port' is done in the L2I unit */
    descrPtr->sstId = 0;

    /* the bc2 CPU port hold no GOP and value of ingressGopPortNumber == SMAIN_NOT_VALID_CNS,
       so need to avoid access violation into devObjPtr->portsArr[] */
    if( (descrPtr->ingressGopPortNumber < SKERNEL_DEV_MAX_SUPPORTED_PORTS_CNS) &&
        devObjPtr->portsArr[descrPtr->ingressGopPortNumber].
                                physicalToVirtualPortMappingEn == GT_TRUE)
    {
        descrPtr->localDevSrcPort =
            devObjPtr->portsArr[descrPtr->ingressGopPortNumber].virtualMapping;
        __LOG(("Hard-coded mapping from physical port[%d] to virtual port[%d] on the field of <localDevSrcPort>",
                  descrPtr->ingressGopPortNumber,descrPtr->localDevSrcPort));
    }
    else if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        snetLion3RxdmaToTti(devObjPtr, descrPtr);
    }

    /* NOTE: the functionality had errata in EGF of sip5 , and it was decided to
       remove the configuration in sip5_10 */
    if(!SMEM_CHT_IS_SIP5_10_GET(devObjPtr))
    {
        /* get value of 'basic mode' from MG global control register .*/
        smemRegFldGet(devObjPtr, SMEM_CHT_GLB_CTRL_REG(devObjPtr), 3, 1, &descrPtr->basicMode);
    }

    if(retVal == GT_TRUE) /* packet not dropped by the MAC */
    {
        if(!descrPtr->isFromSdma)
        {
            /* check for EEE support */
            snetBobcat2EeeProcess(devObjPtr,macPort,SMAIN_DIRECTION_INGRESS_E);
        }


        if(SMEM_CHT_IS_SIP5_10_GET(devObjPtr))
        {
            /* do Pre-Ingress Prioritization (PIP) */
            retVal = snetSip5_10RxDmaPipCheck(devObjPtr,descrPtr);
        }
    }

    return retVal;
}

/*******************************************************************************
* snetLion3TtiDefaulteEportExceptionMruCheck
*
* DESCRIPTION:
*       sip5 TTI default ePort MRU exception check (in addition to MAC port's MRU check)
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to frame data buffer Id
*
* OUTPUTS:
*       descrPtr     - pointer to updated frame data buffer Id
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetLion3TtiDefaulteEportExceptionMruCheck
(
    IN    SKERNEL_DEVICE_OBJECT             *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   *descrPtr
)
{
    DECLARE_FUNC_NAME(snetLion3TtiDefaulteEportExceptionMruCheck);

    GT_U32 cpuCode;
    GT_U32 exceptionCmd;
    GT_U32 mruProfile;
    GT_U32 mruSize;
    GT_U32 isMruCheckEnabled;

    if( NULL == descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr)
    {
        __LOG(("can never happen but just to be on the safe side \n"));
        return;
    }


    smemRegFldGet(devObjPtr, SMEM_LION_TTI_INTERNAL_CONF_REG(devObjPtr), 4, 1, &isMruCheckEnabled);

    if(!isMruCheckEnabled)
    {
        __LOG(("TTI default ePort MRU Exception check is globally disabled\n"));
        return;
    }


    __LOG(("do TTI MRU Exception check\n"));

        mruProfile = SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MRU_INDEX);

    __LOG(("got default ePort MRU profile: [%d] \n", mruProfile));


    smemRegFldGet(devObjPtr, SMEM_LION3_TTI_MRU_SIZE_REG(devObjPtr, mruProfile/2),  mruProfile % 2 * 14, 14, &mruSize);

    __LOG(("got relevant MRU size: [%d] to compare with byteCount [%d] \n", mruSize, descrPtr->byteCount));


    if(descrPtr->byteCount > mruSize)
    {
        __LOG(("there is MRU exception \n"));

        smemRegFldGet(devObjPtr, SMEM_LION3_TTI_MRU_EXCEPTION_COMMAND_REG(devObjPtr), 0, 8, &cpuCode);
        smemRegFldGet(devObjPtr, SMEM_LION3_TTI_MRU_EXCEPTION_COMMAND_REG(devObjPtr), 8, 3, &exceptionCmd);

        snetChtIngressCommandAndCpuCodeResolution(devObjPtr, descrPtr,
                                                  descrPtr->packetCmd,
                                                  exceptionCmd,
                                                  descrPtr->cpuCode,
                                                  cpuCode,
                                                  SNET_CHEETAH_ENGINE_UNIT_TTI_E,
                                                  GT_FALSE);
    }


}

/*******************************************************************************
*   snetChtL2Parsing_Bpe_ETag_Format
*
* DESCRIPTION:
*        IEEE 802.1 header parsing. (xCat3)
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*       tpid1Offset  - TPID1 offset
*       parseMode - parsing mode : from port/tti /trill..
* RETURN:
*
*******************************************************************************/
static GT_VOID snetChtL2Parsing_Bpe_ETag_Format
(
    IN SKERNEL_DEVICE_OBJECT          * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32                          tpid1Offset,
    IN SNET_CHT_FRAME_PARSE_MODE_ENT   parseMode
)
{
    GT_U32  bits0to15AfterTpid1 ;/* the bits  0..15 the ETag (after TPID)*/
    GT_U32  bits16to31AfterTpid1;/* the bits 16..31 the ETag (after TPID) */
    GT_U32  GRP;                 /* field GRP in the ETag */
    GT_U32  ingress_E_CID_base;  /* field <ingress_E_CID_base> in the ETag*/
    GT_U32  E_CID_base;          /* field <E_CID_base> in the ETag*/

    DECLARE_FUNC_NAME(snetChtL2Parsing_Bpe_ETag_Format);

    if(parseMode != SNET_CHT_FRAME_PARSE_MODE_PORT_E)
    {
        /* not for TT packets */
        return;
    }

    if(devObjPtr->support802_1br_PortExtender == 0)
    {
        /* not supported by this device */
        return;
    }

    if(descrPtr->firstVlanTagExtendedSize <= 4)
    {
        /* ETag was not recognized on this packet */
        return;
    }


    bits0to15AfterTpid1 =
        ((descrPtr->startFramePtr[(tpid1Offset) + 2] << 8) |
         (descrPtr->startFramePtr[(tpid1Offset) + 3]));
    bits16to31AfterTpid1 =
        ((descrPtr->startFramePtr[(tpid1Offset) + 4] << 8) |
         (descrPtr->startFramePtr[(tpid1Offset) + 5]));

    __LOG_PARAM(bits0to15AfterTpid1);
    __LOG_PARAM(bits16to31AfterTpid1);

    /* parse the ETag */
    ingress_E_CID_base = SMEM_U32_GET_FIELD(bits0to15AfterTpid1,0,12);
    E_CID_base = SMEM_U32_GET_FIELD(bits16to31AfterTpid1,0,12);
    GRP = SMEM_U32_GET_FIELD(bits16to31AfterTpid1,12,2);

    __LOG_PARAM(ingress_E_CID_base);
    __LOG_PARAM(E_CID_base);
    __LOG_PARAM(GRP);

    /* the 'standered' vid1 parsing assign vid the value from  <ingress_E-CID_base>
        but we need it from <E-CID_base> .. which located 2 bytes after.

       so we use 'extra' '+2' offset from where we usually take the value
    */

    if(GRP == 0)/* unicast (single destination) */
    {
        __LOG_PARAM_WITH_NAME("ETag with <GRP=0> (unicast (single destination)) --> recognize vid1 from:",E_CID_base);
        descrPtr->vid1 = E_CID_base;
    }
    else
    {
        __LOG_PARAM_WITH_NAME("ETag with <GRP!=0> (multicast (multi destination)) --> recognize vid1 from:",ingress_E_CID_base);
        descrPtr->vid1 = ingress_E_CID_base;
        __LOG_PARAM_WITH_NAME("ETag with <GRP!=0> (multicast (multi destination)) --> recognize vidx from:",E_CID_base);
        descrPtr->eVidx = E_CID_base;
        descrPtr->useVidx = 1;
    }

    /* save GRP for later use ... but this is for TTI unit only !!!
       as the HW device not have such field in descriptor between units
    */
    descrPtr->bpe802_1br_GRP = GRP;

    return;
}

/*******************************************************************************
*   snetChtL2Parsing
*
* DESCRIPTION:
*        L2 header Parsing (vlan tag , ethertype , nested vlan , encapsulation)
*        coming from port interface or comming from tunnel termination interface
*        for Ethernet over MPLS.
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*       parseMode - parsing mode : from port/tti /trill..
*       internalTtiInfoPtr -  pointer to internal TTI info
* RETURN:
*
*******************************************************************************/
extern GT_VOID snetChtL2Parsing
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN SNET_CHT_FRAME_PARSE_MODE_ENT   parseMode,
    IN INTERNAL_TTI_DESC_INFO_STC        * internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtL2Parsing);

    GT_U32 regAddress;              /* register address */
    GT_U32 * regPtr;                /* register entry pointer */
    GT_U32 inVlanEtherType0;        /* VLAN EtherType */
    GT_U32 inVlanEtherType1;        /* VLAN EtherType */
    GT_U32 inVlanEtherType;         /* VLAN EtherType */
    GT_U32 * portVlanCfgEntryPtr;   /* table entry pointer */
    GT_U32 ethTypeOffset;           /* ethernet type byte offset */
    GT_U32 etherType;               /* real frame ethernet type */
    GT_U8 firstNestedTagNum;        /* nested tag order */
    SKERNEL_L2_ENCAPSULATION_TYPE_ENT l2encapsul;  /* encapsulation */
    GT_U8 regularTag;           /* nested VLAN or regular tag */
    GT_U8 i;                        /* index */
    GT_U32 cfiRelayEn;              /* CFI enable relay bit */
    GT_U32 tempSwap;                /* auxiliary variable to perform swapping */
    GT_U8 *tempSwapPtr;             /* auxiliary variable to perform swapping */
    GT_U32  *ttiPreTtiLookupIngressEPortTablePtr = NULL;/* pointer to the entry in : tti - Pre-TTI Lookup Ingress ePort Table  */
    GT_U32  tagLenToDecrement=0;/* number of bytes to decrement from the byte count for the 'overSize Untagged Packets Filter Enable' logic */
    GT_U32  overSizeUntaggedPacketsFilterEnable;/*When Enabled, if the packets
                untagged byte count is greater than 1518, then the packet is hard dropped.
                    0 = Disable , 1 = Enable*/
    GT_U32  enableMruCheckOnCascadePort;
    GT_U32  tagExtendedSize = 0; /* indicates whether tag extended (sip5 only) or not */
    GT_U32  defaultPortUp;/* the UP0 that the 'per' port' hold */
    GT_U32  marvellTaggedUsed = (descrPtr->marvellTagged && parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E) ? 1 : 0;
    GT_U32  dsaTagLength = 0;
    GT_U32  maxVlanTagsToCheck;/* max number of vlan tag that we may recognize */
    GT_U32  tpid1Offset; /* the offset in bytes from start of packet to point to start of TPID1 */

    __LOG_PARAM(marvellTaggedUsed);

    descrPtr->tag1LocalDevSrcTagged = 0;

    if(parseMode < SNET_CHT_FRAME_PARSE_MODE_LAST_E)
    {
        if(descrPtr->didPacketParseFromEngine[parseMode] == GT_TRUE)
        {
            /* eliminate duplications */
            __LOG(("eliminate duplications"));
            return ;
        }
        /* state that this mode did parsing */
        descrPtr->didPacketParseFromEngine[parseMode] = GT_TRUE;
    }

    if(parseMode != SNET_CHT_FRAME_PARSE_MODE_PORT_E)
    {
        /* support parse of the passenger fill MAC data type */
        if (SGT_MAC_ADDR_IS_MCST(descrPtr->macDaPtr))
        {
            if (SGT_MAC_ADDR_IS_BCST(descrPtr->macDaPtr))
            {
                descrPtr->macDaType = SKERNEL_BROADCAST_MAC_E;
                __LOG(("macDaType == SKERNEL_BROADCAST_MAC_E"));
            }
            else
            {
                descrPtr->macDaType = SKERNEL_MULTICAST_MAC_E;
                __LOG(("macDaType == SKERNEL_MULTICAST_MAC_E"));
            }
        }
        else
        {
            descrPtr->macDaType = SKERNEL_UNICAST_MAC_E;
            __LOG(("macDaType == SKERNEL_UNICAST_MAC_E"));
        }

        if(descrPtr->numOfBytesToPop == 0)
        {
            __LOG(("do L2 re-parse for inner packet \n"));

            /* dump the packet after the re-parse of L2 */
            simLogPacketDump(devObjPtr,
                            GT_TRUE/*ingress*/,
                            descrPtr->localDevSrcPort,/* local device source port */
                            descrPtr->macDaPtr,/*start of inner packet*/
                            descrPtr->byteCount);
        }
        else
        {
            __LOG(("do L2 re-parse to 'pop' numOfBytesToPop = [%d] \n",
                descrPtr->numOfBytesToPop));
        }


        /* the re-parse of the L2 need to recalc the 'orig Src tagging' CQ#134872 */
        __LOG(("the re-parse of the L2 need to recalc the 'orig Src tagging'"));
        descrPtr->origSrcTagged = 0;
    }

    ethTypeOffset = SGT_MAC_ADDR_BYTES*2; /* skip 12 bytes of  mac addresses */

    if (marvellTaggedUsed)
    {
        /* take the info about the orig src tagged from the DSA tag info
            use both : tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] or trgTagged because only one of them is
            used per frame.
        */
        descrPtr->origSrcTagged = descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] || descrPtr->trgTagged;

        /* save info in case of 802.1D */
        descrPtr->vlanTag802dot1dInfo.vid = descrPtr->eVid & 0xFFF;
        descrPtr->vlanTag802dot1dInfo.vpt = descrPtr->up;
        descrPtr->vlanTag802dot1dInfo.cfi = descrPtr->cfidei;

        dsaTagLength = 4 * (descrPtr->marvellTaggedExtended + 1);
        __LOG_PARAM(dsaTagLength);

        ethTypeOffset += dsaTagLength;

        descrPtr->srcDevIsOwn =
            SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->srcDev, descrPtr->ownDev,
                                         devObjPtr->dualDeviceIdEnable.tti);
    }
    else
    if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E)
    {
        if(0 == SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            descrPtr->origSrcEPortOrTrnk = descrPtr->localDevSrcPort;
        }
        else
        {
            /* sip5 already asigned origSrcEPortOrTrnk = descrPtr->eArchExtInfo.localDevSrcEPort */
            /* in snetChtFrameParsingVlanAssign */
        }
        descrPtr->srcDev = descrPtr->ownDev;
        descrPtr->srcDevIsOwn = 1;
    }
    /* support both DSA tagged and none DSA tagged packets */
    if(descrPtr->srcDevIsOwn && devObjPtr ->dualDeviceIdEnable.tti)
    {
       /* set the extra bits after 6 bits of the port */
        __LOG(("set the extra bits after 6 bits of the port"));
        descrPtr->extraSrcPortBits = (descrPtr->srcDev & 0x1) << 6;
    }

    /* egressFilterRegistered is not reached from the extended DSA tag when != frw and != from_cpu */
    if(marvellTaggedUsed &&
       (descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_1_WORDS_E ||

        (
           (descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
            descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FROM_CPU_E)
        )
       )
      )
    {
        descrPtr->egressFilterRegistered = 1;
    }

    if(descrPtr->numOfBytesToPop)
    { /* sip5 only */
        __LOG_PARAM(descrPtr->numOfBytesToPop);

        /* skip needed number of tags */
        ethTypeOffset += descrPtr->numOfBytesToPop;

        /* reset the flag , because we now re-parse the L2 parts */
        descrPtr->firstVlanTagExtendedSize = 0;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        if (parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E)
        {
            /* Timestamp tag Detection */
            snetChtTimestampTagDetection(devObjPtr, descrPtr, &ethTypeOffset);
        }
    }

    /* Real ethernet type */
    etherType  =
        SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, ethTypeOffset);
    __LOG_PARAM(etherType);

    if(devObjPtr->supportEArch && devObjPtr->unitEArchEnable.tti)
    {
        /* tti - Pre-TTI Lookup Ingress ePort Table */
        __LOG(("tti - Pre-TTI Lookup Ingress ePort Table"));
        ttiPreTtiLookupIngressEPortTablePtr = descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr;

        portVlanCfgEntryPtr = NULL;
    }
    else
    {
        regAddress = SMEM_CHT_PORT_VLAN_QOS_CONFIG_TBL_MEM(devObjPtr,
                                                            descrPtr->localDevSrcPort);
        portVlanCfgEntryPtr = smemMemGet(devObjPtr, regAddress);
    }

    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        snetXCatIngressVlanTagClassify(devObjPtr, descrPtr, ethTypeOffset,
                                       &inVlanEtherType0, &inVlanEtherType1,
                                       parseMode);

        /* calculate the implied field of descrPtr->srcTagState */
        if(descrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E)
        {
            descrPtr->srcTagState =
                (descrPtr->ingressVlanTag1Type == SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E) ?
                SKERNEL_FRAME_TR101_VLAN_INGR_TAG_UNTAGGED_E :  /* no tags */
                SKERNEL_FRAME_TR101_VLAN_INGR_TAG_TAG1_E;       /* tag 1 only */
        }
        else if(descrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
        {
            descrPtr->srcTagState =
                (descrPtr->ingressVlanTag1Type == SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E) ?
                SKERNEL_FRAME_TR101_VLAN_INGR_TAG_TAG0_E :              /* tag 0 only */
                SKERNEL_FRAME_TR101_VLAN_INGR_TAG_OUT_TAG0_IN_TAG1_E;   /* tag 0 outer tag 1 inner */
        }
        else /*if(descrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_INNER_E)*/
        {
            descrPtr->srcTagState = SKERNEL_FRAME_TR101_VLAN_INGR_TAG_OUT_TAG1_IN_TAG0_E;   /* tag 1 outer tag 0 inner */
        }


        if(descrPtr->ingressVlanTag0Type ==
           SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
        {
            inVlanEtherType = inVlanEtherType0;
        }
        else if(descrPtr->ingressVlanTag1Type ==
                SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
        {
            inVlanEtherType = inVlanEtherType1;
        }
        else
        {
            inVlanEtherType = 0xFFFFFFFF;
        }

        if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E)
        {
            /* save original tagging for the TO_CPU packets */
            descrPtr->origSrcTagState =  descrPtr->srcTagState;
        }
    }
    else
    {
        /* VLAN parsing, nested VLANs */
        __LOG(("VLAN parsing, nested VLANs"));
        regPtr = smemMemGet(devObjPtr, SMEM_CHT_VLAN_ETH_TYPE_REG(devObjPtr));

        /* IngressVLAN Ethertype0 and Ethertype1 */
        inVlanEtherType0 = SMEM_U32_GET_FIELD(regPtr[0], 0, 16);
        inVlanEtherType1 = SMEM_U32_GET_FIELD(regPtr[0], 16, 16);

        if(portVlanCfgEntryPtr == NULL)
        {
            /* fix for coverity warning "FORWARD_NULL" */
            skernelFatalError("snetChtL2Parsing: invalid table entry pointer\n");
        }

        /* Ingress VLANSel */
        descrPtr->portVlanSel = SMEM_U32_GET_FIELD(portVlanCfgEntryPtr[0], 22, 1);
        if (descrPtr->portVlanSel == 0)
        {
            inVlanEtherType = inVlanEtherType0;
        }
        else
        {
            inVlanEtherType = inVlanEtherType1;

        }

        /* this device supports tag0 only from the packet */
        descrPtr->srcTagState =  descrPtr->origSrcTagged ?
            SKERNEL_FRAME_TR101_VLAN_INGR_TAG_TAG0_E :
            SKERNEL_FRAME_TR101_VLAN_INGR_TAG_UNTAGGED_E;

        descrPtr->ingressVlanTag0Type = descrPtr->srcTagState;
        descrPtr->ingressVlanTag1Type = SKERNEL_FRAME_TR101_VLAN_INGR_TAG_UNTAGGED_E;
    }

    /* NestedVLAN AccessPortEn */
    if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E)
    {
        if(ttiPreTtiLookupIngressEPortTablePtr)
        {
            descrPtr->nestedVlanAccessPort =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_NESTED_VLAN_ACCESS_PORT);
        }
        else
        {

            if(portVlanCfgEntryPtr == NULL)
            {
                /* fix for coverity warning "FORWARD_NULL" */
                skernelFatalError("snetChtL2Parsing: invalid table entry pointer\n");
            }

            descrPtr->nestedVlanAccessPort =
                SNET_CHT_PORT_VLAN_QOS_ACCESS_PORT_MAC(devObjPtr, portVlanCfgEntryPtr);
        }
    }


    if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E  && SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        snetLion3TtiDefaulteEportExceptionMruCheck(devObjPtr, descrPtr);
    }

    if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E && SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        if(descrPtr->eArchExtInfo.ttiPhysicalPortAttributePtr)
        {
            enableMruCheckOnCascadePort =
                SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                    SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_ENABLE_MRU_CHECK_ON_CASCADE_PORT);
        }
        else
        {
            enableMruCheckOnCascadePort = snetFieldValueGet(portVlanCfgEntryPtr,64,1);
        }

        if(ttiPreTtiLookupIngressEPortTablePtr)
        {
            overSizeUntaggedPacketsFilterEnable =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OVERSIZE_UNTAGGED_PKTS_FILTER_EN);
        }
        else
        {
            overSizeUntaggedPacketsFilterEnable =
                snetFieldValueGet(portVlanCfgEntryPtr,9,1);
        }

        __LOG(("overSizeUntaggedPacketsFilterEnable[%d] , enableMruCheckOnCascadePort[%d]",
                      overSizeUntaggedPacketsFilterEnable , enableMruCheckOnCascadePort));

        if(marvellTaggedUsed)
        {
            tagLenToDecrement = 4*(descrPtr->marvellTaggedExtended + 1);
        }
        else
        if(descrPtr->srcTagState !=
           SKERNEL_FRAME_TR101_VLAN_INGR_TAG_UNTAGGED_E)
        {
            /* the logic removes only single tag !
               regardless to number of tags recognized */
            tagLenToDecrement = 4;
            if(descrPtr->firstVlanTagExtendedSize > 4)
            {
                tagLenToDecrement += descrPtr->firstVlanTagExtendedSize - 4;
            }
        }
        else
        {
            tagLenToDecrement = 0;
        }

        /* this feature is not take into account any 'Nested Vlan' issues */
        if(overSizeUntaggedPacketsFilterEnable &&
            ((marvellTaggedUsed == 0) || (marvellTaggedUsed == 1 && enableMruCheckOnCascadePort)))
        {
            if((descrPtr->byteCount - tagLenToDecrement) > 1518)
            {
                __LOG(("assign HARD DROP : (descrPtr->byteCount[%d] - tagLenToDecrement[%d]) > 1518",
                              descrPtr->byteCount,tagLenToDecrement));

                /*assigned a HARD_DROP packet*/
                snetChtIngressCommandAndCpuCodeResolution(devObjPtr,descrPtr,
                                                          descrPtr->packetCmd,
                                                          SKERNEL_EXT_PKT_CMD_HARD_DROP_E,
                                                          descrPtr->cpuCode,
                                                          0,/*don't care*/
                                                          SNET_CHEETAH_ENGINE_UNIT_TTI_E,
                                                          GT_TRUE);
            }
        }
    }

    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr) &&
       descrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E)
    {
        /* save the 'per port' UP */
        defaultPortUp = descrPtr->up;
    }
    else
    {
        /* dummy init will not be used */
        defaultPortUp = 0;
    }

    descrPtr->origVlanTagPtr = descrPtr->macSaPtr + SGT_MAC_ADDR_BYTES;
    descrPtr->origVlanTagLength = 0;

    if(marvellTaggedUsed)
    {
        /* the logic did not 'jumped' the tag after the DSA */
        tpid1Offset = dsaTagLength;
    }
    else if(descrPtr->ingressVlanTag1Type == SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
    {
        /* tag1 is outer */
        tpid1Offset = ethTypeOffset;
    }
    else if(descrPtr->firstVlanTagExtendedSize > 4)/* tag0 outer is extended */
    {
        tpid1Offset = ethTypeOffset + descrPtr->firstVlanTagExtendedSize;
    }
    else if (descrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E)
    {
        tpid1Offset = ethTypeOffset;/* tag0 not exists */
    }
    else
    {
        tpid1Offset = ethTypeOffset + 4;/* tag0 exists */
    }
    __LOG_PARAM(tpid1Offset);

    /* The ingress VLAN EtherType */
    if(marvellTaggedUsed)
    {
        firstNestedTagNum = 1;/* first vlan tag already in the DSA */

        /*jump over the DSA tags */
        descrPtr->origVlanTagPtr += dsaTagLength;

    }
    else
    if (etherType == inVlanEtherType)
    {
        /* VLAN Tag found */
        __LOG(("VLAN Tag found"));
        firstNestedTagNum = 1;

        if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
        {
            if( descrPtr->ingressVlanTag0Type !=
                SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E )
            {
                /* packet came 'TAGGED' -- regardless to nested VLAN issues */
                __LOG(("packet came 'TAGGED' -- regardless to nested VLAN issues"));
                descrPtr->origSrcTagged = 1;
            }
        }

        /* NestedVLAN AccessPortEn */
        if (descrPtr->nestedVlanAccessPort)
        {
            descrPtr->up =
                SNET_GET_PCKT_TAG_UP_MAC(descrPtr, ethTypeOffset);
            regularTag = 0;
            SIM_TBD_BOOKMARK/* the nested vlan behavior changed in Sip5. need to fix TTI,PCL and HA */
            descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] = 0;/* do this reset for Lion3 to have legacy behavior */
        }
        else
        {
            descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] = 1;
            regularTag = 1;
        }

        if (regularTag)
        {
            descrPtr->tag0Ptr =  &descrPtr->startFramePtr[ethTypeOffset];

            descrPtr->eVid =
                SNET_GET_PCKT_TAG_VLAN_ID_MAC(descrPtr, ethTypeOffset);
            descrPtr->vlanEtherType =
                SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, ethTypeOffset);
            __LOG_PARAM(descrPtr->vlanEtherType);

            descrPtr->up =
                SNET_GET_PCKT_TAG_UP_MAC(descrPtr, ethTypeOffset);
            descrPtr->cfidei =
                SNET_GET_PCKT_TAG_CFI_DEI_MAC(descrPtr, ethTypeOffset);

            descrPtr->up1 = 0;
            descrPtr->cfidei1 = 0;
            if(descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr)
            {
                /* already initialized vid1 in snetXCatIngressVlanTagClassify */
            }
            else
            {
                descrPtr->vid1 = 0;
            }
            descrPtr->vlanEtherType1 = 0;

            if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E)
            {
                /* save info in case of 802.1D */
                descrPtr->vlanTag802dot1dInfo.vid = descrPtr->eVid;
                descrPtr->vlanTag802dot1dInfo.vpt = descrPtr->up;
                descrPtr->vlanTag802dot1dInfo.cfi = descrPtr->cfidei;
            }
        }

        /* Jump over the vlan tag to the first nested vlan tag */
        __LOG(("Jump over the vlan tag to the first nested vlan tag"));
        ethTypeOffset += 4;

        descrPtr->origVlanTagLength = 4;

        if(descrPtr->firstVlanTagExtendedSize > 4)
        {
            ethTypeOffset += (descrPtr->firstVlanTagExtendedSize - 4);
            descrPtr->origVlanTagLength += (descrPtr->firstVlanTagExtendedSize - 4);
        }
    }
    else
    {
        firstNestedTagNum = 0;
    }

    /* Set CFI relay bit for tagged packets */
    cfiRelayEn = 1;

    if(!SKERNEL_IS_CHEETAH1_ONLY_DEV(devObjPtr))
    {
        if (SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
        {
            /* xCat A1 and above - xCat A1, Lion B0 */
            regPtr = smemMemGet(devObjPtr, SMEM_XCAT_A1_TTI_UNIT_GLB_CONF_REG(devObjPtr));
            cfiRelayEn = SMEM_U32_GET_FIELD(regPtr[0], 28, 1);
        }
        else
        {
            /* Cheetah 2/3 */
            regPtr = smemMemGet(devObjPtr, SMEM_CHT_PCL_GLOBAL_REG(devObjPtr));
            cfiRelayEn = SMEM_U32_GET_FIELD(regPtr[0], 22, 1);
        }
        __LOG(("cfiRelayEn [%d] \n",
            cfiRelayEn));
    }

    /* Set pointer after DSA/VLAN/SA tag before traverse nested VLANs  */
    descrPtr->afterVlanOrDsaTagPtr = &descrPtr->startFramePtr[ethTypeOffset];

    /* allow up to 6 tags recognition for SIP5 device */
    maxVlanTagsToCheck = SMEM_CHT_IS_SIP5_GET(devObjPtr) ? 6 : 4;

    if(descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_4_WORDS_E &&
       devObjPtr->supportEArch == 0)
    {
        maxVlanTagsToCheck = 1;
        __LOG(("Don't parse more than one VLAN tag in packets with eDSA tag for non eArch devices \n"));
    }

    /* Nested VLANs parsing relevant for packet without DSA tag or who's packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E */
    /* allow 'from_cpu' also recognize tags properly. -- nested vlan not relevant to it */
    /*if(marvellTaggedUsed == 0 ||
       (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E ||
        descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FROM_CPU_E))*/
    {
        for (i = firstNestedTagNum; i < maxVlanTagsToCheck; i++,
                ethTypeOffset+=4,descrPtr->origVlanTagLength += 4)
        {
            etherType =
                SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, ethTypeOffset);
            __LOG_PARAM(etherType);

            /* Nested VLAN processing.Up to 4 VLAN tags  may be in the frame */
            if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr) == 0)
            {
                /* ch1,2,3 supports 2 ethertypes */
                __LOG(("ch1,2,3 supports 2 ethertypes"));
                if ( etherType != inVlanEtherType1 &&
                     etherType != inVlanEtherType0 )
                {
                    break;
                }
            }
            else /* xCat and above */
            {
                /* xCat supports 8 ethertypes (TPIDs).
                   Check of full 8 bits of the global configuration */
                if(GT_FALSE == snetXCatVlanTagMatchWithoutTag0Tag1Classification(devObjPtr, descrPtr, etherType, 0xff, i, &tagExtendedSize))
                {
                    break;
                }
            }

            if(firstNestedTagNum != 0 && /* not untagged packet */
               i == firstNestedTagNum)
            {
                descrPtr->tag1Ptr =  &descrPtr->startFramePtr[ethTypeOffset];
                descrPtr->vid1 =
                   SNET_GET_PCKT_TAG_VLAN_ID_MAC(descrPtr, ethTypeOffset);
                descrPtr->vlanEtherType1 =
                    SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, ethTypeOffset);
                __LOG_PARAM(descrPtr->vlanEtherType1);
                descrPtr->up1 =
                   SNET_GET_PCKT_TAG_UP_MAC(descrPtr, ethTypeOffset);
                descrPtr->cfidei1 =
                   SNET_GET_PCKT_TAG_CFI_DEI_MAC(descrPtr, ethTypeOffset);
            }


            if(tagExtendedSize > 4)
            { /* got vlan tpid match, and tag extended, and sip5 only */

                if(i == 0)/* must be the 'outer tag'*/
                {
                    descrPtr->firstVlanTagExtendedSize = tagExtendedSize;
                }

                ethTypeOffset+=(tagExtendedSize-4);
                descrPtr->origVlanTagLength += (tagExtendedSize-4);
            }

            if(i == (maxVlanTagsToCheck - 1))
            {
                /* the last tag was matched so update the Ethertype */
                etherType =
                    SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, (ethTypeOffset+4));
                __LOG_PARAM(etherType);
            }

        }
    }

    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        /* in case tag1 is derived from the outer tag swap between descriptor */
        /* {vid, vlanEtherType, up, cfidei} and {vid1, vlanEtherType1, up1, cfidei1} fields */
        if(descrPtr->ingressVlanTag1Type ==
                SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
        {
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr) &&
                marvellTaggedUsed &&
                descrPtr->tag1LocalDevSrcTagged == 0 &&
                (descrPtr->ingressVlanTag0Type !=
                SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E))
            {
                __LOG(("Do not trust the eDSA that there is second tag ! \n"));
                __LOG(("because we could not recognized it on the local device \n"));

                __LOG(("so not swap value between tag0 and tag1 \n"));


            }
            else
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr) &&
                marvellTaggedUsed &&
                descrPtr->tag1LocalDevSrcTagged == 1 &&
                descrPtr->tag0IsOuterTag == 1)
            {
                __LOG(("consider that TAG 0 is the outer tag \n"));
                __LOG(("so not swap value between tag0 and tag1 \n"));
            }
            else
            {
                __LOG(("swap value between tag0 and tag1 \n"));

                tempSwap = descrPtr->vid1;
                descrPtr->vid1 = descrPtr->eVid & 0xFFF;
                descrPtr->eVid = tempSwap;

                tempSwap = descrPtr->vlanEtherType1;
                descrPtr->vlanEtherType1 = descrPtr->vlanEtherType;
                descrPtr->vlanEtherType = tempSwap;

                tempSwap = descrPtr->up1;
                descrPtr->up1 = descrPtr->up;
                descrPtr->up = tempSwap;

                tempSwap = descrPtr->cfidei1;
                descrPtr->cfidei1 = descrPtr->cfidei;
                descrPtr->cfidei = tempSwap;

                tempSwapPtr    = descrPtr->tag1Ptr;
                descrPtr->tag1Ptr = descrPtr->tag0Ptr;
                descrPtr->tag0Ptr = tempSwapPtr;
            }
        }

        if(descrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E)
        {
            /* restore the 'per port' UP */
            descrPtr->up = defaultPortUp;
        }

        /* check double tag case */
        if((descrPtr->ingressVlanTag1Type !=
                SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E) &&
           (descrPtr->ingressVlanTag0Type !=
                SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E))
        {
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr) &&
                marvellTaggedUsed &&
                descrPtr->tag1LocalDevSrcTagged == 0)
            {
                __LOG(("Do not trust the eDSA that there is second tag ! \n"));
                __LOG(("because we could not recognized it on the local device \n"));
            }
            else
            {
                /* move pointer to be after second tag */
                __LOG(("move afterVlanOrDsaTagPtr to be after second tag \n"));
                descrPtr->afterVlanOrDsaTagPtr +=4;
                /* the length of those 4 bytes was already taken into account !
                if(descrPtr->firstVlanTagExtendedSize > 4 )
                {
                    descrPtr->afterVlanOrDsaTagPtr += (descrPtr->firstVlanTagExtendedSize - 4);
                }
                */
            }
        }
    }

    /* check for IEEE 802.1 header parsing. (xCat3)*/
    /* need to be before save origVid1 */
    snetChtL2Parsing_Bpe_ETag_Format(devObjPtr,descrPtr,tpid1Offset,parseMode);

    descrPtr->originalVid1 = descrPtr->vid1;

    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr)  == 0 ||/*ch3 and below*/
       (SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr) && /*xcat and above for tag 0 only (not for tag1) */
        descrPtr->ingressVlanTag0Type != SKERNEL_FRAME_TR101_VLAN_TAG_NOT_FOUND_E))
    {
        if(descrPtr->origSrcTagged)
        {
            if (cfiRelayEn == 0)
            {
                /* Tagged packets transmitted from the device have their CFI bit set to 0 */
                __LOG(("Tagged packets transmitted from the device have their CFI bit set to 0"));
                descrPtr->cfidei = 0;
            }
        }
        else
        {
            if (cfiRelayEn)
            {
                /* Set to 0 if the received packet is untagged */
                __LOG(("Set CFI bit to 0 if the received packet is untagged"));
                descrPtr->cfidei = 0;
            }
        }
    }

    /* L2 encapsulation parsing */
    if (etherType < 0x0600)
    {
        ethTypeOffset += 2 ;
        etherType = SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, ethTypeOffset);

        if (etherType == 0xAAAA &&
            descrPtr->startFramePtr[ethTypeOffset + 2] == 0x3)
        {
            __LOG(("l2Encaps : IEEE 802.3 LLC/SNAP (LLC-SNAP) \n"));
            l2encapsul = SKERNEL_LLC_SNAP_E;
            ethTypeOffset += 6;
            etherType = (descrPtr->startFramePtr[ethTypeOffset] << 8) |
                         descrPtr->startFramePtr[ethTypeOffset + 1];

        }
        else
        {
            __LOG(("l2Encaps : IEEE 802.3 (LLC Encapsulation) (non-SNAP) \n"));
            l2encapsul = SKERNEL_LLC_E;
            /*ethTypeOffset += 1; cause mess in HA */
        }
    }
    else
    {
        l2encapsul = SKERNEL_ETHERNET_II_E;
        __LOG(("l2Encaps : Ethernet v2 \n"));
    }

    descrPtr->l2Encaps = l2encapsul;

    descrPtr->etherTypeOrSsapDsap = etherType;
    __LOG_PARAM(descrPtr->etherTypeOrSsapDsap); /* the final EtherType */

    if(parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E)
    {
        descrPtr->origInfoBeforeTunnelTermination.origEtherType = etherType;
        descrPtr->origInfoBeforeTunnelTermination.l2Encaps = l2encapsul;
    }

    descrPtr->l3StartOffsetPtr = descrPtr->macDaPtr + ethTypeOffset + 2;

    if(descrPtr->afterVlanOrDsaTagPtr > descrPtr->l3StartOffsetPtr)
    {
        /* we got calculation error !!! --> must fix and not ignore it !! */
        skernelFatalError("snetChtL2Parsing: descrPtr->afterVlanOrDsaTagPtr > descrPtr->l3StartOffsetPtr \n");
    }

    descrPtr->afterVlanOrDsaTagLen =
        descrPtr->l3StartOffsetPtr - descrPtr->afterVlanOrDsaTagPtr;

    /* check for overlapping of the 2 sections - CQ#134872 */
    if(descrPtr->origVlanTagLength &&
       (&descrPtr->origVlanTagPtr[descrPtr->origVlanTagLength]) >
       (&descrPtr->afterVlanOrDsaTagPtr[0]))
    {
        /* make sure that there are no overlapping between the 2 sections */
        __LOG(("synch origVlanTagLength according to afterVlanOrDsaTagPtr \n"));
        descrPtr->origVlanTagLength -= (&descrPtr->origVlanTagPtr[descrPtr->origVlanTagLength]) - (&descrPtr->afterVlanOrDsaTagPtr[0]);
    }


    if(devObjPtr->supportCutThrough && (parseMode == SNET_CHT_FRAME_PARSE_MODE_PORT_E))
    {
        snetLionCutThroughTrigger(devObjPtr, descrPtr);
    }

    __LOG_PARAM(TAG0_EXIST_MAC(descrPtr));
    __LOG_PARAM(TAG1_EXIST_MAC(descrPtr));

}


/*******************************************************************************
*   snetLion3RemotePortAssignmentGet
*
* DESCRIPTION:
*        Remote Physical Port Assignment
*
* INPUTS:
*       devObjPtr          - pointer to device object.
*       descrPtr           - frame descriptor pointer
*
* OUTPUTS:
*       descrPtr           - frame descriptor pointer
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetLion3RemotePortAssignmentGet
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(snetLion3RemotePortAssignmentGet);

    GT_U32                           regAddr;
    GT_U32                           myPhyPortRegAddr;
    GT_U32                           phyPortMode;
    GT_U32                           phyPortBase;
    GT_U32                           srcDevAssignEn;
    GT_U32                           numOfDsaSourcePortBits;
    GT_U32                           numOfDsaSourceDevBits;
    GT_U32                           numBitsPort = 8;

    if( !SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        return;
    }

    myPhyPortRegAddr = SMEM_LION3_TTI_MY_PHY_PORT_ATTRIBUTES_REG(devObjPtr, descrPtr->localDevSrcPort);
    if( SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        numBitsPort = 9;
    }

    smemRegFldGet(devObjPtr, myPhyPortRegAddr, numBitsPort+1, 2, &phyPortMode);

    switch(phyPortMode)
    {
        case 0:
            __LOG(("Physical Port Assignment Mode: disabled, do nothing \n"));
            return;
        case 1:
            __LOG(("Physical Port Assignment Mode: interlaken, TBD, not supported \n"));
            return;
        case 2:
            __LOG(("Physical Port Assignment Mode: DSA \n"));
            if(descrPtr->marvellTagged)
            {
                if(0 == descrPtr->ingressDsa.origIsTrunk)
                {
                    smemRegFldGet(devObjPtr, myPhyPortRegAddr, 1, numBitsPort, &phyPortBase);

                    regAddr = SMEM_LION3_TTI_REMOTE_PHY_PORT_ASSIGN_GLB_CONF_REG(devObjPtr);
                    smemRegFldGet(devObjPtr, regAddr, 0, 4, &numOfDsaSourcePortBits);
                    smemRegFldGet(devObjPtr, regAddr, 4, 4, &numOfDsaSourceDevBits);

                    __LOG_PARAM(phyPortBase);
                    __LOG_PARAM(numOfDsaSourcePortBits);
                    __LOG_PARAM(numOfDsaSourceDevBits);
                    __LOG_PARAM(descrPtr->ingressDsa.srcDev);
                    __LOG_PARAM(descrPtr->ingressDsa.origSrcEPortOrTrnk);

                    descrPtr->localDevSrcPort = phyPortBase +
                        (SMEM_U32_GET_FIELD(descrPtr->ingressDsa.srcDev, 0, numOfDsaSourceDevBits) << numOfDsaSourcePortBits) +
                         SMEM_U32_GET_FIELD(descrPtr->ingressDsa.origSrcEPortOrTrnk, 0, numOfDsaSourcePortBits);

                    __LOG(("new value of descrPtr->localDevSrcPort is [%d] \n",
                        descrPtr->localDevSrcPort));

                    if(devObjPtr->errata.dsaTagOrigSrcPortNotUpdated)
                    {
                        __LOG(("Warning (Errata): the Original Src ePort is not updated to the newly assigned source physical port"));
                        __LOG(("                  but remains the original source ePort from the DSA  \n"));
                    }
                    else
                    {
                        /* override the parsing from the DSA */
                        descrPtr->origSrcEPortOrTrnk = descrPtr->localDevSrcPort;
                        __LOG(("new value of descrPtr->origSrcEPortOrTrnk is [%d] \n",
                            descrPtr->origSrcEPortOrTrnk));
                    }
                }
                else
                {
                    __LOG(("ERROR : packet's origin from trunk ?! \n"));
                }
            }
            else
            {
                __LOG(("ERROR : packet is not DSA tagged ?! \n"));
            }
            break;
        default:
            __LOG(("ERROR : Physical Port Assignment Mode: [%d] not supported \n" , phyPortMode));
    }


    smemRegFldGet(devObjPtr, myPhyPortRegAddr, 0, 1, &srcDevAssignEn);

    if(srcDevAssignEn)
    {
        descrPtr->srcDev = descrPtr->ownDev;
        __LOG(("new value of descrPtr->srcDev is [%d] (own device) \n", descrPtr->srcDev));
    }


}

/*******************************************************************************
*   lion3CentralizedChassisModeSupport
*
* DESCRIPTION:
*        sip5 Centralized Chassis Mode Support,
*           relevant when Centralized Chassis Mode enabled
*
* INPUTS:
*       deviceObj                - pointer to device object.
*       descrPtr                 - pointer to the frame's descriptor.
*
* OUTPUT:
*
* COMMENTS:
*          this function is relevant only for sip5, extended FORWARD DSA tag
*
********************************************************************************/
static GT_VOID lion3CentralizedChassisModeSupport
(
    IN  SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(lion3CentralizedChassisModeSupport);

    GT_U32  value;/*register value*/
    GT_U32  ccLineCardDefaultEportBase,dsaSrcDev2ePortLsb,
            dsaSrcPort2ePortLsb,dsaSrcTrunk2ePortLsb;/* fields relate to centralized Chassis Mode*/
    GT_U32  centralizedChassisDefaultSrcEPort = 0;

    if(descrPtr->marvellTagged == 0 ||
       descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_2_WORDS_E ||
       descrPtr->incomingMtagCmd != SKERNEL_MTAG_CMD_FORWARD_E)
    {
        __LOG(("function is relevant only for sip5, extended FORWARD DSA tag"));
        return;
    }

    /* must be set after dsa tag type check */
    descrPtr->centralizedChassisModeEn = 1;

    /*
        LocalDevSRCePort = Map DSA<SrcPort/Trunk>
        OrigSRCePort/Trunk = Map DSA<SRCePort/Trunk>
    */
    smemRegGet(devObjPtr, SMEM_LION2_TTI_UNIT_GLOBAL_CONF_FOR_CC_PORTS_REG(devObjPtr),&value);
    dsaSrcDev2ePortLsb          = SMEM_U32_GET_FIELD(value,6,3);
    dsaSrcPort2ePortLsb         = SMEM_U32_GET_FIELD(value,3,3);
    dsaSrcTrunk2ePortLsb        = SMEM_U32_GET_FIELD(value,0,3);

    /*
    Desc<OrigIsTrunk> = 0;
    Assign the same new value to both Desc<OrigSRCePort/Trunk> and Desc<LocalDevSRCePort>:
    If DSA<SrcIsTrunk> == 0
        Assign <CC Line-Card Ports Default ePort Base> +
        {DSA<SrcDev>[<CC Default ePort Mapping DSA<SrcDev> LSB Amount>:0],
         DSA<SrcPort>[<CC Default ePort Mapping DSA<SrcPort> LSB Amount>:0]};
    Else // DSA<SrcIsTrunk> == 1
        Assign <CC Line-Card Trunk Default ePort Base> +
                DSA<SrcTrunk>[<CC Default ePort Mapping DSA<SrcTrunk> LSB Amount>:0];
    */
    if(descrPtr->origIsTrunk == 0)
    {
        /*CC Line-Card Ports Default ePort Base*/
        ccLineCardDefaultEportBase   =
            SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_PORTS_DEFAULT_EPORT_BASE);

        SMEM_U32_SET_FIELD(centralizedChassisDefaultSrcEPort,
            dsaSrcPort2ePortLsb ,                      /* port offset */
            dsaSrcDev2ePortLsb,
            descrPtr->srcDev);/*DSA<SrcDev>*/

        SMEM_U32_SET_FIELD(centralizedChassisDefaultSrcEPort,
            0 ,
            dsaSrcPort2ePortLsb,
            descrPtr->origSrcEPortOrTrnk);/*DSA<SrcPort>*/
    }
    else /*came from trunk*/
    {
        /*CC Line-Card Trunk Default ePort Base*/
        ccLineCardDefaultEportBase   =
            SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CC_LINE_CARD_TRUNK_DEFAULT_EPORT_BASE);

        SMEM_U32_SET_FIELD(centralizedChassisDefaultSrcEPort,
            0 ,
            dsaSrcTrunk2ePortLsb,
            descrPtr->origSrcEPortOrTrnk);/*DSA<SrcTrunk>*/

    }

    centralizedChassisDefaultSrcEPort += ccLineCardDefaultEportBase;

    descrPtr->trgEPort = SNET_CHT_NULL_PORT_CNS;/*62*/
    descrPtr->eArchExtInfo.trgPhyPort = descrPtr->trgEPort;
    descrPtr->trgDev = 0;
    descrPtr->targetIsTrunk = 0;
    descrPtr->useVidx = 0;
    descrPtr->eArchExtInfo.isTrgPhyPortValid = 0;


    __LOG(("CC line card changed default Source EPort [%d] (but it will not effect TTI lookup fields)",
                      centralizedChassisDefaultSrcEPort));

    snetLion3IngressReassignSrcEPort(devObjPtr,descrPtr, "CC line card", centralizedChassisDefaultSrcEPort);

    /*
        This assignment is not performed at this initial stage, as the original DSA<SrcDev>
        may be used for the TTI lookup key. This assignment is performed unconditionally
        and after TTI lookup is performed, as part of the post-TTI lookup descriptor field
        assignments
    */
    __LOG(("Restore OrigSrcDev from the DSA info \n"));
    descrPtr->srcDev      = descrPtr->ingressDsa.srcDev;
    descrPtr->srcDevIsOwn = SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->srcDev, descrPtr->ownDev,
                                                         devObjPtr->dualDeviceIdEnable.tti);
    __LOG_PARAM(descrPtr->srcDev);
    __LOG_PARAM(descrPtr->srcDevIsOwn);
}

/*******************************************************************************
*   snetChtFrameParsingVlanAssign
*
* DESCRIPTION:
*        Frames header Parsing and VLAN/QoS Port Protocol or default assignment
*
* INPUTS:
*       devObjPtr          - pointer to device object.
*       descrPtr           - frame data buffer Id
*       internalTtiInfoPtr -  pointer to internal TTI info
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetChtFrameParsingVlanAssign
(
    IN SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtFrameParsingVlanAssign);

    GT_U32 regAddress;
    GT_U32 * portVlanCfgEntryPtr;   /* table entry pointer */
    GT_U32 bypassEn;                /* Bridge Bypass Enable */
    GT_U32 portOamLoopBackEn;       /* Port for IEEE 802.3ah loopback mode enable */
    GT_U32  centralizedChassisModeEn = 0;/*Centralized Chassis mode*/
    GT_U32  *ttiPreTtiLookupIngressEPortTablePtr = NULL;/* pointer to the entry in : tti - Pre-TTI Lookup Ingress ePort Table  */
    GT_U32  oamPduTrapEn;/* Enable OAM-PDU packets trapping to CPU */

    if (descrPtr->marvellTagged)
    {
        __LOG(("Marvell tag parsing"));
        SIM_LOG_PACKET_DESCR_SAVE
        snetChtMarvellTagParsing(devObjPtr, descrPtr, internalTtiInfoPtr);
        SIM_LOG_PACKET_DESCR_COMPARE("snetChtMarvellTagParsing");
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        snetLion3RemotePortAssignmentGet(devObjPtr, descrPtr);

        __LOG(("TTI - Physical Port Attribute Table, index[%d]", descrPtr->localDevSrcPort));
        regAddress = SMEM_LION2_TTI_PHYSICAL_PORT_ATTRIBUTE_TBL_MEM(devObjPtr, descrPtr->localDevSrcPort);
        descrPtr->eArchExtInfo.ttiPhysicalPortAttributePtr = smemMemGet(devObjPtr, regAddress);

        if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
        {
            __LOG(("TTI - Physical Port 2 Attribute Table, index[%d]", descrPtr->localDevSrcPort));
            regAddress = SMEM_SIP5_20_TTI_PHYSICAL_PORT_2_ATTRIBUTE_TBL_MEM(devObjPtr, descrPtr->localDevSrcPort);
            descrPtr->eArchExtInfo.ttiPhysicalPort2AttributePtr = smemMemGet(devObjPtr, regAddress);
        }


        /* check the : Centralized Chassis mode Enable */
        centralizedChassisModeEn =
            SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_CENTRALIZED_CHASSIS_PORT_ENABLE);

        __LOG_PARAM(centralizedChassisModeEn);

        if(centralizedChassisModeEn)
        {
            /* Accessing to table SMEM_LION2_TTI_PHYSICAL_PORT_ATTRIBUTE_TBL_MEM(devObjPtr,descrPtr->localDevSrcPort);
               Is done only after snetLion3RemotePortAssignmentGet that may change descrPtr->localDevSrcPort */
            lion3CentralizedChassisModeSupport(devObjPtr, descrPtr);
        }

        /* set the default ePort of this physical port */
        if(descrPtr->centralizedChassisModeEn == 0)
        {
            descrPtr->eArchExtInfo.localDevSrcEPort =
                SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                    SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_DEFAULT_SOURCE_EPORT_NUMBER);
            if(descrPtr->marvellTagged == 0)
            {
                descrPtr->origSrcEPortOrTrnk = descrPtr->eArchExtInfo.localDevSrcEPort;
            }
        }
        else
        {
            /* already set in lion3CentralizedChassisModeSupport */
        }
        __LOG(("The default ePort of this physical port is[%d] \n", descrPtr->eArchExtInfo.localDevSrcEPort));

        descrPtr->qos.ingressExtendedMode =
                SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_QOS_MODE);

        if(descrPtr->marvellTagged == 0 /* non cascade port*/ &&
           descrPtr->qos.ingressExtendedMode)
        {
            /* we continue as usual but such config can cause non wanted behavior */
            __LOG(("suspected as configuration ERROR! PORT_QOS_MODE = 'extended' on NON cascade port"));
        }

        /* save the info for LOG usage */
        descrPtr->eArchExtInfo.defaultSrcEPort = descrPtr->eArchExtInfo.localDevSrcEPort;

        /* tti - Pre-TTI Lookup Ingress ePort Table */
        regAddress = SMEM_LION2_TTI_PRE_TTI_LOOKUP_INGRESS_EPORT_TABLE_TBL_MEM(devObjPtr,
                descrPtr->eArchExtInfo.localDevSrcEPort);
        descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr = smemMemGet(devObjPtr, regAddress);
        ttiPreTtiLookupIngressEPortTablePtr = descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr;

        portVlanCfgEntryPtr = NULL;
    }
    else
    {
        regAddress = SMEM_CHT_PORT_VLAN_QOS_CONFIG_TBL_MEM(devObjPtr,
                                                            descrPtr->localDevSrcPort);

        portVlanCfgEntryPtr = smemMemGet(devObjPtr, regAddress);

    }

    if(0 == descrPtr->marvellTagged)
    {
        /* moved the UP assignment only for non DSA because :
           1. for DSA we get UP from the DSA
           2. if the port is CC-line card then the 'pre-tti lookup table'
              indexed according to internalTtiInfoPtr->ccLineCard.newSrcEPort
           */
        if(ttiPreTtiLookupIngressEPortTablePtr)
        {
            /*Port UP0*/
            descrPtr->up =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_UP0);

        }
        else
        {
            /* Port Default User Priority */
            descrPtr->up =
                SNET_CHT_PORT_VLAN_QOS_UP_MAC(devObjPtr, portVlanCfgEntryPtr);
        }

        __LOG(("Port UP0 = [%d] \n",
                      descrPtr->up));

        descrPtr->ingressDsa.qosProfile = 0;
    }
    else
    {
        /* this function can be called only after
           descrPtr->eArchExtInfo.ttiPhysicalPortAttributePtr is not NULL */

        /* do logic of <IsLooped> and <DropOnSource> */
        snetChtIngressIsLoopedAndDropOnSource(devObjPtr, descrPtr);
    }


    /* Multi-Port Group FDB Lookup support */
    if(devObjPtr->supportMultiPortGroupFdbLookUpMode)
    {
        SIM_LOG_PACKET_DESCR_SAVE
        snetLionIngressSourcePortGroupIdGet(devObjPtr, descrPtr);
        SIM_LOG_PACKET_DESCR_COMPARE("snetLionIngressSourcePortGroupIdGet");
    }

    /* do L2 parsing (vlan tag , ethertype , nested vlan , encapsulation) */
    __LOG(("do L2 parsing (vlan tag , ethertype , nested vlan , encapsulation)"));
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtL2Parsing(devObjPtr, descrPtr,SNET_CHT_FRAME_PARSE_MODE_PORT_E,internalTtiInfoPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtL2Parsing");

    /*******************************************************/
    /* save original pointer in case of Tunnel termination */
    /*******************************************************/
    descrPtr->origInfoBeforeTunnelTermination.originalL2Ptr = descrPtr->macDaPtr;
    descrPtr->origInfoBeforeTunnelTermination.originalL3Ptr = descrPtr->l3StartOffsetPtr;

    descrPtr->payloadPtr = descrPtr->origInfoBeforeTunnelTermination.originalL3Ptr;
    /* use descrPtr->origByteCount to calculate payload length because
       descrPtr->byteCount may be some constant value for cut through packets */
    descrPtr->payloadLength = descrPtr->origByteCount - (descrPtr->payloadPtr - descrPtr->macDaPtr);

    descrPtr->l2HeaderSize = descrPtr->l3StartOffsetPtr - descrPtr->macDaPtr;

    /* L3, L4 protocols parsing */
    __LOG(("L3, L4 protocols parsing"));
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtL3L4ProtParsing(devObjPtr, descrPtr, descrPtr->etherTypeOrSsapDsap, internalTtiInfoPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtL3L4ProtParsing");

    /* save info that maybe needed by PCL */
    descrPtr->origInfoBeforeTunnelTermination.arp = descrPtr->arp;
    descrPtr->origInfoBeforeTunnelTermination.mpls = descrPtr->mpls;
    descrPtr->origInfoBeforeTunnelTermination.isIp = descrPtr->isIp;
    descrPtr->origInfoBeforeTunnelTermination.isIPv4 = descrPtr->isIPv4;

    if (descrPtr->marvellTagged)
    {
        if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E)
        {
            if (descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E)
            {
                if(ttiPreTtiLookupIngressEPortTablePtr)
                {
                    bypassEn =
                        SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                            SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_EXTENDED_DSA_BYPASS_BRIDGE);
                }
                else
                {
                    /* Bridge BypassEn */
                    bypassEn =
                        SNET_CHT_PORT_VLAN_QOS_DSA_CSCD_BYPASS_BRG_GET_MAC(devObjPtr,
                                                                           portVlanCfgEntryPtr);
                }

                if (bypassEn == 1)
                {
                    __LOG(("Bridge BypassEn == 1"));
                    descrPtr->bypassBridge = bypassEn;
                }
                else
                {
                    /* we are going to do FDB lookup again */
                    __LOG(("Bridge BypassEn == 0 , we are going to do FDB lookup again"));
                    descrPtr->egressFilterRegistered = 0;
                }

                if (descrPtr->nestedVlanAccessPort)
                {
                    descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] = 0;
                }
            }
        }
        else
        {
            descrPtr->bypassBridge = 1;
        }
    }
    else
    {
        if(portVlanCfgEntryPtr)
        {
            /* MirrorToIngress AnalyzerPort */
            __LOG(("MirrorToIngress AnalyzerPort"));
            descrPtr->rxSniff =
                SNET_CHT_PORT_VLAN_QOS_MIRR_INGR_ANALAYZER_GET_MAC(devObjPtr,
                                                                   portVlanCfgEntryPtr);
        }
    }

    /* VLAN and QoS Profile Assign */
    __LOG(("VLAN and QoS Profile Assign"));

    SIM_LOG_PACKET_DESCR_SAVE
    snetChtVlanQosProfAssign(devObjPtr, descrPtr, descrPtr->etherTypeOrSsapDsap, descrPtr->l2Encaps,
                             portVlanCfgEntryPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("snetChtVlanQosProfAssign");

    if(descrPtr->eArchExtInfo.ttiPhysicalPortAttributePtr)
    {
        descrPtr->localDevSrcTrunkId =
            SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_TRUNK_ID);
    }
    else
    {
        descrPtr->localDevSrcTrunkId =
            SNET_CHT_PORT_VLAN_QOS_TRUNK_ID_GET_MAC(devObjPtr,
                                                    portVlanCfgEntryPtr);
    }

    if(descrPtr->localDevSrcTrunkId)
    {
        __LOG(("localDevSrcTrunkId[%d] \n",
                      descrPtr->localDevSrcTrunkId));
    }

    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        /* 802.3ah OAM Loopback Enable Per Port */
        portOamLoopBackEn =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OAM_LINK_LAYER_LOOPBACK_EN);

        /* Enable OAM-PDU packets trapping to CPU */
        oamPduTrapEn =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_OAM_LINK_LAYER_PDU_TRAP_EN);

    }
    else
    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
     /* 802.3ah OAM Loopback Enable Per Port */
        portOamLoopBackEn =
            SMEM_U32_GET_FIELD(portVlanCfgEntryPtr[1], 30, 1);
        oamPduTrapEn =
            SMEM_U32_GET_FIELD(portVlanCfgEntryPtr[1], 31, 1);
    }
    else
    {
        portOamLoopBackEn = 1;
        oamPduTrapEn = 0;
        descrPtr->portVlanSel =
            SNET_CHT_PORT_VLAN_QOS_INGR_VLAN_SELECT_GET_MAC(devObjPtr,
                                                            portVlanCfgEntryPtr);
    }
    __LOG(("OAM Loopback Enable [%d] trap[%d]",portOamLoopBackEn,oamPduTrapEn));

    if ((descrPtr->srcDevIsOwn && descrPtr->localDevSrcTrunkId > 0) &&
        /* for DSA tagged on eArch device we not override the logic of the DSA assignment */
        ((devObjPtr->supportEArch == 0) || (devObjPtr->supportEArch == 1 && descrPtr->marvellTagged == 0)))
    {
        descrPtr->origIsTrunk = 1;
        descrPtr->origSrcEPortOrTrnk = descrPtr->localDevSrcTrunkId;
    }

    if(descrPtr->marvellTagged == 0 ||
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E ||
       descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_4_WORDS_E)
    {
        descrPtr->eArchExtInfo.origSrcPhyIsTrunk   = descrPtr->origIsTrunk;
        descrPtr->eArchExtInfo.origSrcPhyPortTrunk = descrPtr->origSrcEPortOrTrnk;
    }

    if (SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        if ((descrPtr->l3StartOffsetPtr[0]/*subType*/ == 0x03) && (descrPtr->etherTypeOrSsapDsap == SNET_CHT3_ETHERTYPE_OAM_SLOW_PROTOCOL)
            &&
            (descrPtr->macDaPtr[0] == 0x01) &&
            (descrPtr->macDaPtr[1] == 0x80) &&
            (descrPtr->macDaPtr[2] == 0xc2) &&
            (descrPtr->macDaPtr[3] == 0x00) &&
            (descrPtr->macDaPtr[4] == 0x00) &&
            (descrPtr->macDaPtr[5] == 0x02))

        {
            descrPtr->oam = GT_TRUE;
        }

        if(devObjPtr->pclSupport.pclUseCFMEtherType == 0)
        {
            __LOG(("Do CFM classification from TTI unit \n"));
            snetChtCfmEtherTypeCheck(devObjPtr, descrPtr);
        }
        else
        {
            __LOG(("CFM classification could be done in PCL unit \n"));
        }
    }

    if(devObjPtr->portGroupSharedDevObjPtr)
    {
        if(devObjPtr->supportEArch)
        {
            /* the port is already global port , no need to convert */
            descrPtr->localPortGroupPortAsGlobalDevicePort = descrPtr->localDevSrcPort;
        }
        else
        {
            /* set the port */
            descrPtr->localPortGroupPortAsGlobalDevicePort =  /* global port */
                SMEM_CHT_GLOBAL_PORT_FROM_LOCAL_PORT_MAC(devObjPtr,
                            descrPtr->localDevSrcPort);
        }

        /* set the port/trunk */
        if((descrPtr->origIsTrunk == 0) && (descrPtr->marvellTagged == 0))
        {
            /* came from local port group port */
            descrPtr->localPortTrunkAsGlobalPortTrunk =
                descrPtr->localPortGroupPortAsGlobalDevicePort;
        }
        else
        {
            /* came from cascade port / came from trunk*/
            descrPtr->localPortTrunkAsGlobalPortTrunk = descrPtr->origSrcEPortOrTrnk;
        }
    }
    else
    {
        /* set the port */
        descrPtr->localPortGroupPortAsGlobalDevicePort = descrPtr->localDevSrcPort;

        /* set the port/trunk */
        descrPtr->localPortTrunkAsGlobalPortTrunk = descrPtr->origSrcEPortOrTrnk;
    }
    __LOG(("localPortGroupPortAsGlobalDevicePort = [%d]",descrPtr->localPortGroupPortAsGlobalDevicePort));
    __LOG(("localPortTrunkAsGlobalPortTrunk = [%d]",descrPtr->localPortTrunkAsGlobalPortTrunk));

    if(devObjPtr->supportOamPduTrap && descrPtr->oam && oamPduTrapEn)
    {
        /* OAM_TRAP is assigned by the TTI block (but we simulate it here) */
        __LOG(("OAM_TRAP is assigned by the TTI block (but we simulate it here)"));
        descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E;
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            smemRegFldGet(devObjPtr, SMEM_LION3_TTI_UNIT_GLOBAL_CONFIG_EXT_REG(devObjPtr),
                          17, 8, &descrPtr->cpuCode);
        }
        else
        {
            descrPtr->cpuCode = SNET_XCAT_OAM_PDU_TRAP;
        }

    }
    else if(portOamLoopBackEn && devObjPtr->supportPortOamLoopBack)
    {
        /* OAM loopback is forwarded to the pipe with a FROM_CPU DSA tag,
           so it bypasses all ingress/egress filters */
        descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_FROM_CPU_E;
        descrPtr->bypassIngressPipe = 1;

        /* set fields relevant to 'from_CPU' processing */
        descrPtr->egressFilterEn = 0;
        /* modify value so EPCL will not need to recognize OAM */
        descrPtr->ingressDsa.fromCpu_egressFilterEn = descrPtr->egressFilterEn;
        descrPtr->useVidx = 0;
        descrPtr->targetIsTrunk = 0;
        descrPtr->trgDev = descrPtr->ownDev;
        descrPtr->trgEPort = descrPtr->localDevSrcPort;
    }
}

static GT_VOID snetChtCfmEtherTypeCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    GT_U32 * regPtr;                /* register entry pointer */
    GT_U32 cfmEtherType;            /* CFM ethertype */

    DECLARE_FUNC_NAME(snetChtCfmEtherTypeCheck);

    regPtr = smemMemGet(devObjPtr, SMEM_CHT3_CFM_ETHERTYPE_REG(devObjPtr));

    /* CFM Ethertype */
    cfmEtherType = SMEM_U32_GET_FIELD(regPtr[0], 0, 16);

    if (cfmEtherType == descrPtr->etherTypeOrSsapDsap)
    {
        __LOG(("CFM Ethertype \n"));
        descrPtr->cfm  = GT_TRUE;
        descrPtr->udb[0] = descrPtr->l3StartOffsetPtr[0];
        descrPtr->udb[1] = descrPtr->l3StartOffsetPtr[1];
        descrPtr->udb[2] = descrPtr->l3StartOffsetPtr[2];
    }
}

/*******************************************************************************
*   snetChtRxMacCountUpdate
*
* DESCRIPTION:
*        Global update counters function (MAC MIB Counters + CPU port)
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*        overSize   - Flag for packet over size
*                     GT_TRUE: The packet size is bigger then port MRU.
*                     GT_FALSE: The packet size is not bigger then port MRU.
*        fcPacketType - Flow control packet classification
*        macPort    - MAC port number
*
*******************************************************************************/
static GT_VOID snetChtRxMacCountUpdate
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_BOOL overSize,
    IN SNET_FLOW_CONTROL_PACKET_TYPE_ENT fcPacketType,
    IN GT_U32  macPort
)
{
    DECLARE_FUNC_NAME(snetChtRxMacCountUpdate);

    GT_U32 regAddr;                     /* Register address */
    GT_U32 ctrlRegAddr;                 /* Port Control Register address */
    GT_U32 * regPtr;                    /* Register entry pointer */
    GT_U32 fieldVal;                    /* Register field value */
    GT_U32 fieldBit;                    /* Register field offset */
    GT_U32 octets;                      /* Frame size */
    GT_U32 rxHistEnable;                /* This bit enables update of histogram
                                           counters for incoming traffic.
                                            0 = Disabled.  1 = Enabled.*/
    GT_U32 regAddressPfc;               /* port serial params 1 register address - used for PFC frames*/
    GT_U32 forwardPfcFramesEnable;      /* register field value */
    GT_U32 mibCntOffset;                /* MIB counter addr offset */
    GT_U32 mibCtrlRegAddr;              /* port MIB Counters Control Register addr */
    GT_U32 mib4CountSelect; /* 0: 1024to1518, 1518toMax counters are disabled or not supported
                                  1: 1024toMax counter is divided into 1024to1518 and 1519toMax  (xCat2 and above)  */
    GT_U32 mib4LimitSelect;  /*  This bit define threshold between 1024to1518 and 1518toMax counters:
                                    0 => 1518; 1 => 1522. Valid only if mib4CountSelect == 1; */

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) && SNET_NOT_FC_PACKET_E != fcPacketType)
    {
        /* Increment Received Flow Control Packets Counter */
        regAddr = SMEM_LION3_TTI_RECEIVED_FLOW_CONTROL_PACKET_COUNTER_REG(devObjPtr);
        smemRegFldGet(devObjPtr, regAddr, 0, 16, &fieldVal);
        __LOG(("Global counter : Increment Received Flow Control Packets Counter from [%d] \n", fieldVal));
        smemRegFldSet(devObjPtr, regAddr, 0, 16, ++fieldVal);
    }

    __LOG(("Update RX MAC counters on port[%d] \n",macPort));

    if(devObjPtr->cpuPortNoSpecialMac)
    {
        if(GT_TRUE == descrPtr->isFromSdma)
        {
            /* device does not have dedicated MAC counters for CPU port */
            return;
        }
    }
    else
    {
        if (IS_CHT_CPU_PORT(macPort))
        {
            if( GT_FALSE == descrPtr->isFromSdma )
            {
                regAddr = SMEM_CHT_CPU_PORT_GOOD_FRAMES_COUNT_REG(devObjPtr);
                regPtr = smemMemGet(devObjPtr, regAddr);
                (*regPtr)++;

                regAddr = SMEM_CHT_CPU_PORT_GOOD_OCTETS_COUNT_REG(devObjPtr);
                regPtr = smemMemGet(devObjPtr, regAddr);
                (*regPtr) += descrPtr->byteCount;
            }

            return;
        }
    }

    if (CHT_MAC_PORT_MIB_COUNTERS_IS_XG_LOGIC_MAC(devObjPtr,macPort))
    {
        if (SKERNEL_IS_CHEETAH3_DEV(devObjPtr) == 0)
        {
            regAddr = SMEM_CHT_HYPG_MIB_COUNT_XSMII_CONF_REG(devObjPtr);
            if(macPort == 27 )
            {
                fieldBit = 21;
            }
            else
            {
                /* Port24-26Rx HistogramEn */
                __LOG(("Port24-26Rx HistogramEn"));
                fieldBit = (macPort % 24) + 6;
            }
        }
        else
        {
            regAddr = SMEM_CHT3_HGS_PORT_MIB_COUNT_CONTROL_REG(devObjPtr,macPort);
            fieldBit = 2;
        }

        /* get Rx Histogram En */
        smemRegFldGet(devObjPtr, regAddr, fieldBit, 1, &rxHistEnable);
    }
    else
    {
        regAddr = SMEM_CHT_MAC_CONTROL0_REG(devObjPtr, macPort);

        /* check that MIB counters are enabled or not */
        smemRegFldGet(devObjPtr, regAddr, 15, 1, &fieldVal);
        if (fieldVal == 0)
        {
            return;
        }

        /* get Rx Histogram En */
        regAddr = SMEM_CHT_MIB_COUNT_CONTROL_REG(devObjPtr, macPort);

        smemRegFldGet(devObjPtr, regAddr, 5, 1, &rxHistEnable);
    }

    /* address of the start of counters for this port */
    regAddr = CHT_MAC_PORTS_MIB_COUNTERS_BASE_ADDRESS_CNS(devObjPtr,macPort);

    if(fcPacketType == SNET_FC_PACKET_E)
    {
        /* Valid Flow Control packet */
        __LOG(("increment counter of: Valid Flow Control packet \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x58);
        (*regPtr)++;

        return;
    }

    if ( (devObjPtr->supportForwardPfcFrames) &&
         (fcPacketType == SNET_PFC_PACKET_E) &&
         (macPort != SNET_CHT_CPU_PORT_CNS))
    {
        regAddressPfc =
            SMEM_XCAT2_PORT_SERIAL_PARAMS1_REG(devObjPtr, macPort);

        smemRegFldGet(devObjPtr, regAddressPfc, 1, 1, &forwardPfcFramesEnable);
        if (forwardPfcFramesEnable == 1)
        {
            /* PFC packet, processed by Ingress pipe - update 802.3x Received MIB counter */
            __LOG(("increment counter of:PFC packet, processed by Ingress pipe - update 802.3x Received MIB counter \n"));
            regPtr = smemMemGet(devObjPtr, regAddr + 0x58);
            (*regPtr)++;
            return;
        }

        /* Terminated PFC packet - update UknownMacControlFrame MIB counter (multiplexed with Late Collision counter) */
        __LOG(("increment counter of: Terminated PFC packet - update UknownMacControlFrame MIB counter (multiplexed with Late Collision counter) \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x7C);
        (*regPtr)++;
        return;
    }

    if ( (devObjPtr->supportForwardUnknowMacControlFrames) &&
         (fcPacketType == SNET_UNKNOWN_FC_PACKET_E) )
    {
        /* multiplexed with Late Collision counter */
        __LOG(("increment counter of:multiplexed with Late Collision counter \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x7C);
        (*regPtr)++;

        return;
    }

    if(descrPtr->byteCount < 60)
    {
        /* undersize packets received */
        __LOG(("increment counter of: undersize packets received \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x60);
        (*regPtr)++;

        /* bad octets received */
        __LOG(("increment counter of: bad octets received \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x8);
        (*regPtr) += descrPtr->byteCount;

        return;
    }

    if (overSize == GT_TRUE)
    {
        /* oversize packets received */
        __LOG(("increment counter of: oversize packets received \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x68);
        (*regPtr)++;

        /* Read MRU size */
        if(IS_CHT_HYPER_GIGA_PORT(devObjPtr,macPort))
        {
            /* XG port */
            ctrlRegAddr = SMEM_CHT_MAC_CONTROL_REG(devObjPtr, macPort);
            regPtr = smemMemGet(devObjPtr, ctrlRegAddr);

            fieldVal = SMEM_U32_GET_FIELD(regPtr[0], 0, 13);
        }
        else
        {
            /* Gig port */
            ctrlRegAddr = SMEM_CHT_MAC_CONTROL0_REG(devObjPtr, macPort);
            regPtr = smemMemGet(devObjPtr, ctrlRegAddr);

            fieldVal = SMEM_U32_GET_FIELD(regPtr[0], 2, 13);
        }

        /* bad octets received */
        __LOG(("increment counter of: bad octets received \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x8);
        (*regPtr) += (fieldVal * 2);
    }
    else
    if (descrPtr->macDaType == SKERNEL_MULTICAST_MAC_E)
    {
        __LOG(("increment counter of: multicast mac \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x1C);
        (*regPtr)++;
    }
    else
    if (descrPtr->macDaType == SKERNEL_BROADCAST_MAC_E)
    {
        __LOG(("increment counter of: broadcast mac \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x18);
        (*regPtr)++;
    }
    else
    {
        __LOG(("increment counter of: unicast mac \n"));
        regPtr = smemMemGet(devObjPtr, regAddr + 0x10);
        (*regPtr)++;
    }

    /* Good OctetsReceived */
    if (overSize == GT_FALSE)
    {
        __LOG(("increment counter of: Good Octets Received \n"));
        regPtr = smemMemGet(devObjPtr, regAddr);
        (*regPtr) += descrPtr->byteCount;

        if(rxHistEnable)
        {
            octets = SNET_GET_NUM_OCTETS_IN_FRAME(descrPtr->byteCount);
            mibCntOffset = SMAIN_NOT_VALID_CNS;
            switch (octets)
            {
                case SNET_FRAMES_1024_TO_MAX_OCTETS:
                    __LOG(("increment counter of: 1024_TO_MAX_OCTETS \n"));
                    mib4CountSelect = 0; /* old style - 1024to1518 counter not supported */
                    mib4LimitSelect = 0;
                    if (devObjPtr->support1024to1518MibCounter)
                    {
                        if (CHT_MAC_PORT_MIB_COUNTERS_IS_XG_LOGIC_MAC(devObjPtr,macPort))
                        {
                            /* ports 24..27 */
                            mibCtrlRegAddr = SMEM_CHT3_HGS_PORT_MIB_COUNT_CONTROL_REG(devObjPtr,macPort);
                            smemRegFldGet(devObjPtr, mibCtrlRegAddr, 6, 1, &mib4CountSelect);
                            smemRegFldGet(devObjPtr, mibCtrlRegAddr, 7, 1, &mib4LimitSelect);
                        }
                        else
                        {
                            /* ports 0..23 */
                            mibCtrlRegAddr = SMEM_CHT_MIB_COUNT_CONTROL_REG(devObjPtr, macPort);
                            smemRegFldGet(devObjPtr, mibCtrlRegAddr, 16 + (macPort % 6), 1, &mib4CountSelect);
                            smemRegFldGet(devObjPtr, mibCtrlRegAddr, 22 + (macPort % 6), 1, &mib4LimitSelect);
                        }
                    }
                    if (mib4CountSelect == 0)
                    {
                        mibCntOffset = 0x34;  /* Frames1024toMaxOctets */
                    }
                    else
                    {
                        if (descrPtr->byteCount > (GT_U32)(mib4LimitSelect ?
                                     SNET_MIB_CNT_THRESHOLD_1522 : SNET_MIB_CNT_THRESHOLD_1518))
                        {
                            mibCntOffset = 0x34;  /* Frames1519toMaxOctets replace Frames1024toMaxOctets */
                        }
                        else
                        {
                            mibCntOffset = 0x14;  /* Frames1024to1518Octets replace Sent deferred */
                        }
                    }
                    break;
                case SNET_FRAMES_512_TO_1023_OCTETS:
                    __LOG(("increment counter of: 512_TO_1023_OCTETS \n"));
                    mibCntOffset = 0x30;
                    break;
                case SNET_FRAMES_256_TO_511_OCTETS:
                    __LOG(("increment counter of: 256_TO_511_OCTETS \n"));
                    mibCntOffset = 0x2C;
                    break;
                case SNET_FRAMES_128_TO_255_OCTETS:
                    __LOG(("increment counter of: 128_TO_255_OCTETS \n"));
                    mibCntOffset = 0x28;
                    break;
                case SNET_FRAMES_65_TO_127_OCTETS:
                    __LOG(("increment counter of: 65_TO_127_OCTETS \n"));
                    mibCntOffset = 0x24;
                    break;
                case SNET_FRAMES_64_OCTETS:
                    __LOG(("increment counter of: 64_OCTETS \n"));
                    mibCntOffset = 0x20;
                    break;
            }
            if (mibCntOffset != SMAIN_NOT_VALID_CNS)
            {
                regPtr = smemMemGet(devObjPtr, regAddr + mibCntOffset);
                    (*regPtr) ++;
            }
        }
        else
        {
            __LOG(("WARNING : RX histogram counters are not changed by the traffic , on MAC port [%d] \n",
                macPort));
        }
    }
}


/*******************************************************************************
* snetXcatGetGreEtherTypes
*
* DESCRIPTION:
*       check if GRE over IPv4/6, and get the 'GRE ethertypes'
*
* INPUTS:
*       devObjPtr    - pointer to device object
*       descrPtr     - pointer to frame's descriptor
*
* OUTPUTS:
*       greEtherTypePtr  - gre etherType, relevant if function returns GT_TRUE(can be NULL)
*       gre0EtherTypePtr - gre 0 etherType, GRE protocols that are recognized as Ethernet-over-GRE(can be NULL)
*       gre1EtherTypePtr - gre 1 etherType, GRE protocols that are recognized as Ethernet-over-GRE(can be NULL)
*
* RETURN:
*       GT_BOOL      - is gre or not
*
* COMMENTS:
*
*******************************************************************************/
GT_BOOL snetXcatGetGreEtherTypes
(
    IN    SKERNEL_DEVICE_OBJECT             *devObjPtr,
    IN    SKERNEL_FRAME_CHEETAH_DESCR_STC   *descrPtr,
    OUT   GT_U32                            *greEtherTypePtr,
    OUT   GT_U32                            *gre0EtherTypePtr,
    OUT   GT_U32                            *gre1EtherTypePtr
)
{
    DECLARE_FUNC_NAME(snetXcatGetGreEtherTypes);

    GT_U32  regAddress;   /* register addres  */
    GT_U32 *memoryPtr;    /* pointer to memory */
    GT_U32  greEtherType, gre0EtherType, gre1EtherType;
    GT_BOOL  isGre = GT_FALSE;
    GT_U32 globalConfigExt;
    GT_BIT  greHeaderFirst2BytesNonZero;

    if(greEtherTypePtr)
    {
        *greEtherTypePtr = 0;
    }
    if(gre0EtherTypePtr)
    {
        *gre0EtherTypePtr = 0;
    }
    if(gre1EtherTypePtr)
    {
        *gre1EtherTypePtr = 0;
    }


    descrPtr->greHeaderSize = 0;
    descrPtr->greHeaderError = 0;

    if(NULL == descrPtr->l4StartOffsetPtr)
    {
        /* when l4StartOffsetPtr == NULL the function must treat it as 'NOT GRE',
           because l4StartOffsetPtr == NULL when 'recognized as fragment'
           and there is no protocol after the ip header,  only payload. */
        __LOG(("l4StartOffsetPtr == NULL  --> can not recognize GRE \n"));
        return GT_FALSE;
    }


    if(descrPtr->isIPv4)
    {
        regAddress = SMEM_XCAT_TTI_IPV4_GRE_ETHERTYPE_REG(devObjPtr);
    }
    else  /* ipv6 */
    {
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            regAddress = SMEM_LION3_TTI_IPV6_GRE_ETHERTYPE_REG(devObjPtr);
        }
        else
        {
            __LOG(("ipv6 GRE recognition not supported for the device \n"));
            return GT_FALSE;
        }
    }

    /* Get gre etherType */
    greEtherType = (descrPtr->l4StartOffsetPtr[2] << 8) |
                    descrPtr->l4StartOffsetPtr[3];

    if(greEtherTypePtr)
    {
        *greEtherTypePtr = greEtherType;
    }

    if(descrPtr->isIPv4 && greEtherType == SKERNEL_L3_PROT_TYPE_IPV4_E)
    { /* ipv4-O-GRE */
        __LOG(("greEtherType [0x%4.4x] is recognized as IPv4-over-GRE \n",
            greEtherType));
        isGre = GT_TRUE;
    }
    else if((descrPtr->isIPv4 == 0) && greEtherType == SKERNEL_L3_PROT_TYPE_IPV6_E)
    { /* ipv6-O-GRE */
        __LOG(("greEtherType [0x%4.4x] is recognized as IPv6-over-GRE \n",
            greEtherType));
        isGre = GT_TRUE;
    }
    else /* ethernet-O-GRE */
    {
        memoryPtr = smemMemGet(devObjPtr, regAddress);

        /* set gre0EtherType */
        gre0EtherType = SMEM_U32_GET_FIELD(*memoryPtr, 0,  16);

        /* set gre1EtherType */
        gre1EtherType = SMEM_U32_GET_FIELD(*memoryPtr, 16, 16);
        __LOG_PARAM(gre0EtherType);
        __LOG_PARAM(gre1EtherType);

        if(gre0EtherType == 0 && gre1EtherType == 0)
        {
            /* support simulation of legacy devices that not initialized this register */
            isGre = GT_FALSE;
        }
        else
        {
            if(gre0EtherTypePtr)
            {
                *gre0EtherTypePtr = gre0EtherType;
            }

            if(gre1EtherTypePtr)
            {
                *gre1EtherTypePtr = gre1EtherType;
            }

            isGre = ((greEtherType != gre0EtherType) &&
                     (greEtherType != gre1EtherType)) ? GT_FALSE : GT_TRUE;
        }

        __LOG(("greEtherType [0x%4.4x] is %s recognized as Ethernet-over-GRE",
            greEtherType,((isGre == GT_TRUE) ? "" : "not")));
    }


    if(isGre == GT_TRUE)
    {
        greHeaderFirst2BytesNonZero =
            (descrPtr->l4StartOffsetPtr[0] ||
             descrPtr->l4StartOffsetPtr[1]) ? 1 : 0;

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            descrPtr->greHeaderSize = 4; /* Basic size of GRE header */
            descrPtr->greHeaderSize += ((descrPtr->l4StartOffsetPtr[0] >> 7)&0x1) * 4; /* Checksum bit*/
            descrPtr->greHeaderSize += ((descrPtr->l4StartOffsetPtr[0] >> 5)&0x1) * 4; /* Key bit*/
            descrPtr->greHeaderSize += ((descrPtr->l4StartOffsetPtr[0] >> 4)&0x1) * 4; /* Sequence Number Present bit*/
        }
        else
        {
            descrPtr->greHeaderSize = 4;
        }

        if(greHeaderFirst2BytesNonZero)/* GRE Extensions and version 0 check */
        {
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                smemRegGet(devObjPtr,SMEM_LION3_TTI_UNIT_GLOBAL_CONFIG_EXT_REG(devObjPtr), &globalConfigExt);
                if(0 == SMEM_U32_GET_FIELD(globalConfigExt,25,1))/*Enable GRE Extensions*/
                {
                    descrPtr->greHeaderError = 1;
                }
            }
            else
            {
                /* for legacy no EXTENTION support */
                descrPtr->greHeaderError = 1;
            }
        }

        __LOG_PARAM(descrPtr->greHeaderSize);
        __LOG_PARAM(descrPtr->greHeaderError);
    }

    return isGre;
}

/*******************************************************************************
*   snetLion3IpTotalLengthAfterDeduction
*
* DESCRIPTION:
*        ipv4/6 total length after deduction
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*        origLength - original total length
* return:
*        ipv4/6 total length after deduction
*******************************************************************************/
static GT_U32 snetLion3IpTotalLengthAfterDeduction
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 origLength
)
{
    DECLARE_FUNC_NAME(snetLion3IpTotalLengthAfterDeduction);

    GT_U32  regAddr, fldValue, bitNum;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) == 0)
    {
        __LOG(("No deduction of ipv4/6 total length for this device type \n"));
        return origLength;
    }

    if(descrPtr->tunnelTerminated == 1)
    {
        __LOG(("No deduction of ipv4/6 total length for tunnelTerminated == 1 \n"));
        return origLength;
    }


    if (GT_FALSE == snetXcatGetGreEtherTypes(devObjPtr, descrPtr, NULL, NULL, NULL))
    {
        __LOG(("deduction not relevant because --> not GRE"));
        return origLength;
    }

    /*For MACSEC packets over IPv4/6 tunnel, that are to be tunnel
      terminated, this configuration enables aligning the IPv4 total header
      length to the correct offset (taking into account the additional
      MACSEC header).*/

    /*IPv4/6 Total Length Deduction Enable*/
    if(0 == SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_IPV4_6_TOTAL_LENGTH_DEDUCTION_EN))
    {
        __LOG(("deduction not enabled on default eport"));
        return origLength;
    }

    regAddr = SMEM_LION3_TTI_IP_LENGTH_CHECK_REG(devObjPtr);
    bitNum  = descrPtr->isIPv4 ? 0 : 6;

    smemRegFldGet(devObjPtr, regAddr, bitNum, 6,  &fldValue);

    __LOG(("IPv4/6 Total Length Deduction Enabled, with length[%d]", fldValue));
    return (origLength - fldValue);
}

/*******************************************************************************
*   snetChtMplsTransitTunnelsProtParsing
*
* DESCRIPTION:
*        Parsing of transit mpls tunnels
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*        pmode      - parsing mode
*        internalTtiInfoPtr - internal tti info
*
*******************************************************************************/
GT_VOID snetChtMplsTransitTunnelsProtParsing
(
    IN SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_ENT    pmode,
    IN INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtMplsTransitTunnelsProtParsing);

    GT_U32   etherType = 0;
    GT_BIT   l2Parsing;/* indication that we need L2 parsing (beside the L3L4)
                            to support Ethernet parsing */
    SKERNEL_FRAME_CHEETAH_DESCR_STC *innerFrameDescrPtr;/* pointer to the passenger descriptor */

    __LOG(("parsing mode: \n",
                    pmode == LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_IP_ONLY_E ? "IP_ONLY" :
                    pmode == LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_IP_OR_CW_PW_ETHERNET_E ? "IP_OR_CW_PW_ETHERNET" :
                    pmode == LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_ETHERNET_NO_CW_PW_E ? "ETHERNET_NO_CW_PW" :
                    "unknown"
                    ));

    if(pmode != LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_ETHERNET_NO_CW_PW_E)
    {
        l2Parsing = 0;

        __LOG_PARAM(descrPtr->protOverMpls);

        switch(descrPtr->protOverMpls)
        {
            case 0:
                __LOG(("parse passenger as Ipv4 \n"));
                etherType = SKERNEL_L3_PROT_TYPE_IPV4_E; /*Ipv4*/
                break;
            case 1:
                __LOG(("parse passenger as Ipv6 \n"));
                etherType = SKERNEL_L3_PROT_TYPE_IPV6_E; /*Ipv6*/
                break;
            default:
            case 2:
                if(pmode == LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_IP_ONLY_E)
                {
                    /* not recognized option : do not parse passenger */
                    /* not support non IP passenger */
                    __LOG(("WARNING : the 'IP_ONLY' mode NOT parse Ethernet (no passenger parsing) \n"));
                    return;
                }
                __LOG(("parse passenger as Ethernet \n"));
                l2Parsing = 1;
                break;
        }
    }
    else /*LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_ETHERNET_NO_CW_PW_E*/
    {
        __LOG(("parse passenger as Ethernet (no CW_PW) \n"));
        l2Parsing = 1;
    }

    descrPtr->ingressTunnelInfo.innerFrameDescrPtr = snetChtEqDuplicateDescr(devObjPtr, descrPtr);
    innerFrameDescrPtr = descrPtr->ingressTunnelInfo.innerFrameDescrPtr;

    __LOG(("jump the MPLS labels (before parsing the passenger) \n"));

    /* jump the MPLS labels */
    innerFrameDescrPtr->l3StartOffsetPtr =  descrPtr->afterMplsLabelsPtr;

    if(l2Parsing)
    {
        if(LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_IP_OR_CW_PW_ETHERNET_E == pmode)
        {
            __LOG(("jump 4 byte of CW (Control Word) (before parsing the passenger) \n"));
            /* jump 4 byte of CW (Control Word) */
            innerFrameDescrPtr->l3StartOffsetPtr += 4;
        }

        __LOG(("Do L2 passenger parsing (Ethernet parsing) \n"));

        innerFrameDescrPtr->byteCount -= (innerFrameDescrPtr->l3StartOffsetPtr - innerFrameDescrPtr->startFramePtr);
        __LOG_PARAM(innerFrameDescrPtr->byteCount);

        innerFrameDescrPtr->startFramePtr = innerFrameDescrPtr->l3StartOffsetPtr;
        /* reset the L3 pointer , because it is not relevant any more -->
                   will be set inside snetChtL2Parsing(...) for the 'passenger'  */
        innerFrameDescrPtr->l3StartOffsetPtr = NULL;
        innerFrameDescrPtr->macDaPtr = DST_MAC_FROM_TUNNEL_DSCR(innerFrameDescrPtr);
        innerFrameDescrPtr->macSaPtr = SRC_MAC_FROM_TUNNEL_DSCR(innerFrameDescrPtr);

        /* do re-parsing on the passenger , to set the L2 info
                   (must be done prior to setting the VID from the TTI action ,
                   and other QOS setting of TTI) */
        snetChtL2Parsing(devObjPtr, innerFrameDescrPtr,
                         SNET_CHT_FRAME_PARSE_MODE_FROM_TTI_PASSENGER_E, internalTtiInfoPtr);
        innerFrameDescrPtr->passengerLength = innerFrameDescrPtr->byteCount -
                                (innerFrameDescrPtr->l3StartOffsetPtr - innerFrameDescrPtr->startFramePtr);

        __LOG_PARAM(innerFrameDescrPtr->passengerLength);

        /* now after the L2 parsing we know the ethertype for the L3L4 parsing */
        etherType = innerFrameDescrPtr->etherTypeOrSsapDsap;
    }

    /* reset the descriptor regarding fields of L3,L4 , so that fields that
       not set by function snetChtL3L4ProtParsing , will not stay with
       values from previous call to snetChtL3L4ProtParsing */
    snetChtL3L4ProtParsingResetDesc(devObjPtr, innerFrameDescrPtr);

    __LOG(("Do L3L4 passenger parsing according to etherType[0x%4.4x] \n",
                    etherType));
    /* L3, L4 protocols parsing */
    snetChtL3L4ProtParsing(devObjPtr, innerFrameDescrPtr, etherType, internalTtiInfoPtr);

    /*NOTE: the trunk hashing (snetXCatA1TrunkHash(...)) will be according to
        the descrPtr->mplsInfo.l3l4DescrPtr */

    /* the function snetXCatA1TrunkHash(...) updated the descrPtr->mplsInfo.l3l4DescrPtr->pktHash
    and we need it in the original descriptor too. */
    descrPtr->pktHash = innerFrameDescrPtr->pktHash;

    __LOG(("update the pktHash in the original descriptor [0x%8.8x]\n",
                    descrPtr->pktHash));
}

/*******************************************************************************
*   snetLion3TTMplsOamChannelTypeProfile
*
* DESCRIPTION:
*       TT MPLS OAM Channel Type Profile support
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       descrPtr            - pointer to the frame descriptor.
*       firstNibbleAfterSBitLabel - first nibble after sbit label
*       pwe3CwWord          - pseudo wire control word
*
* OUTPUT:
*       descrPtr            - pointer to the frame descriptor.
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetLion3TTMplsOamChannelTypeProfile
(
    IN    SKERNEL_DEVICE_OBJECT             *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   *descrPtr,
    IN    GT_U32                             firstNibbleAfterSBitLabel,
    IN    GT_U32                             pwe3CwWord
)
{
    DECLARE_FUNC_NAME(snetLion3TTMplsOamChannelTypeProfile);

    GT_U32 pwe3ChannelType = pwe3CwWord >> 16;
    GT_U32 tableChannelType;
    GT_U32 index;
    GT_U32 validBit;

   /*
        PWE3_Channel_Type = 2 LSBs of 4B word following the MPLS header
                (PWE3 CW Control Word Format)
        IF (First nibble following the MPLS header = 4b0001) // PWE3 word exists

            TTI-Key[Channel Type Profile] = 0 // default, no match

            FOR EACH entry N in the MPLS OAM Channel Type Profile Table)

                IF ((N[Channel Type] = PWE3_Channel_Type) & (N[Valid] = 1))
                    TTI-Key[Channel Type Profile] = N+1 // Entry 0 is profile 1 etc.
            END FOR
   */

    /* Figure 356: Associated Channel Header (ACH)
         0                             1                             2                             3
         0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1
        -----------------------------------------------------------------------------------------------
        |0  0  0  1 |Version     |       Reserved        |       Channel  Type                        |
        ----------------------------------------------------------------------------------------------
    */

    /* set default value */
    descrPtr->channelTypeProfile = 0;

    if(firstNibbleAfterSBitLabel != 1)
    {
        return;
    }

    for(index = 0; index < 15; index++)
    {
        /* get table channel type */
        smemRegFldGet(devObjPtr, SMEM_LION3_TTI_MPLS_OAM_CHANNEL_TYPE_PROFILE_REG(devObjPtr, index), 1, 16, &tableChannelType);

        if(tableChannelType != pwe3ChannelType)
        {
            continue;
        }

        /* check valid bit first */
        smemRegFldGet(devObjPtr,SMEM_LION3_TTI_MPLS_OAM_CHANNEL_TYPE_PROFILE_REG(devObjPtr, index), 0, 1, &validBit);

        if(validBit)
        {
            /* got match  and valid bit is set */
            descrPtr->channelTypeProfile = index + 1;
            __LOG(("channelTypeProfile: %d", descrPtr->channelTypeProfile));

            /* only one match allowed */
            break;
        }
    }
}


/*******************************************************************************
*   parseMpls
*
* DESCRIPTION:
*        Parsing of mpls protocol header
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*        etherType  - packet ethernet type
*        internalTtiInfoPtr - internal tti info
*
* RETURNS: GT_BOOL - indicates that parsing is done or not
*
********************************************************************************/
static GT_BOOL parseMpls
(
    IN SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN GT_U32                           etherType,
    IN INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(parseMpls);

    GT_U32 regAddress;          /* register address */
    GT_U32 fldValue;            /* register's field address */
    GT_U8  sbit;                /* indication of end of label            */
    GT_U32 firstNibbleAfterMPLS;/* first nibble after MPLS header */
    GT_BIT isMpls = 0;          /* bit to identify if this is MPLS unicast */
    GT_U32 byteOffset;          /* byte offset in the packet */
    GT_U32 mplsIndex,mplsIndexMax;/* mpls index iterator , and mpls index max iterator*/
    GT_U8 ttlArr[6] = {0};      /* TTL from MPLS labels */
    GT_U32 labelArr[6];         /* label from MPLS labels */
    GT_U32 expArr[6];           /* EXP from MPLS labels */

    if (SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        __LOG(("Read the Ethertype used to identify MPLS packets"));
        regAddress = SMEM_XCAT_TTI_MPLS_ETHERTYPES_REG(devObjPtr);
        smemRegFldGet(devObjPtr, regAddress, 0, 16, &fldValue);
        if (etherType == fldValue)
        {
            isMpls = 1;
        }

        if(!isMpls && SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            smemRegFldGet(devObjPtr, regAddress, 16, 16, &fldValue);
            if (etherType == fldValue)
            {
                isMpls = 1;
            }
        }
    }
    else
    {
        if (etherType == 0x8847) /* MPLS unicast */
        {
            isMpls = 1;
        }
    }

    __LOG_PARAM(isMpls);

    if (isMpls == 1)
    {
        __LOG(("this is MPLS\n"));

        descrPtr->isIp = 0;
        descrPtr->isIPv4 = 0;
        descrPtr->mpls = 1;

        __LOG_PARAM(descrPtr->isIp);
        __LOG_PARAM(descrPtr->isIPv4);



        /*save the outer label for PCL key*/
        descrPtr->origInfoBeforeTunnelTermination.origMplsOuterLabel =
                descrPtr->l3StartOffsetPtr[0] << 24 |
                descrPtr->l3StartOffsetPtr[1] << 16 |
                descrPtr->l3StartOffsetPtr[2] <<  8 |
                descrPtr->l3StartOffsetPtr[3] <<  0;

        __LOG_PARAM(descrPtr->origInfoBeforeTunnelTermination.origMplsOuterLabel);

        mplsIndexMax = SMEM_CHT_IS_SIP5_GET(devObjPtr) ? 4 : 3;
        __LOG_PARAM(mplsIndexMax);

        byteOffset = 0;
        descrPtr->numOfLabels = 0;
        for(mplsIndex = 0 ; mplsIndex <= mplsIndexMax ; mplsIndex++,byteOffset+=4)
        {
            labelArr[mplsIndex] = (GT_U32)(descrPtr->l3StartOffsetPtr[byteOffset+0] ) <<  12 |
                                  (GT_U32)(descrPtr->l3StartOffsetPtr[byteOffset+1] ) <<  4 |
                                  (GT_U32)(((descrPtr->l3StartOffsetPtr[byteOffset+2] ) & 0xf0 ) >> 4)  ;

            expArr[mplsIndex]   = (GT_U32)((descrPtr->l3StartOffsetPtr[byteOffset+2] & 0x0e) >> 1);
            sbit                = (GT_U8)(descrPtr->l3StartOffsetPtr[byteOffset+2] & 0x1);
            ttlArr[mplsIndex]   = (GT_U8)(descrPtr->l3StartOffsetPtr[byteOffset+3]);

            if(sbit == 1)
            {
                /* no more labels */
                break;
            }

            if(mplsIndex != mplsIndexMax)
            {
                descrPtr->numOfLabels++; /* value 0 means 1 label
                                            value 1 means 2 labels
                                            value 2 means 3 labels
                                            value 3 means 4 labels (non sip5 --> or more then 4)
                                            value 4 means 5 labels (sip5 --> or more then 5) */
            }
        }

        descrPtr->mplsReservedLabelExist = 0;
        for (mplsIndex = 0 ; mplsIndex <= descrPtr->numOfLabels ; mplsIndex++)
        {
            /* RFC 3032 defines the MPLS label values in the range 0-15 as a reserved label range */
            if ((labelArr[mplsIndex] >= 0) && (labelArr[mplsIndex] <= 15))
            {
                descrPtr->mplsReservedLabelExist = 1;
                /* This field contains the value of the outermost MPLS Reserved label found in the
                   outermost 4 labels in label stack*/
                descrPtr->mplsReservedLabelValue = labelArr[mplsIndex];

                break;
            }
        }
        __LOG_PARAM(descrPtr->mplsReservedLabelExist);
        __LOG_PARAM(descrPtr->mplsReservedLabelValue);

        __LOG_PARAM(descrPtr->numOfLabels);

        firstNibbleAfterMPLS = descrPtr->l3StartOffsetPtr[byteOffset+4] >> 4;
        __LOG_PARAM(firstNibbleAfterMPLS);

          /* 5 bits that immediately follow the bottom of label stack */
        descrPtr->mplsPayloadData = descrPtr->l3StartOffsetPtr[byteOffset+4] >> 3;
        __LOG_PARAM(descrPtr->mplsPayloadData);

        /* pointer to payload data after MPLS lables */
        descrPtr->afterMplsLabelsPtr = &descrPtr->l3StartOffsetPtr[byteOffset+4];

        /* first label */
        mplsIndex = 0;
        descrPtr->ttl = ttlArr[mplsIndex];

        descrPtr->label1    = labelArr[mplsIndex];
        descrPtr->exp1      = expArr[mplsIndex];
        descrPtr->ttl1      = ttlArr[mplsIndex];
        __LOG(("MPLS label [%d] recognized: label[0x%x] exp[%d] ttl[0x%x] \n",
            mplsIndex,
            labelArr[mplsIndex],
            expArr[mplsIndex],
            ttlArr[mplsIndex]));

        if(descrPtr->numOfLabels >= 1)
        {
            /* second label */
            mplsIndex++;
            descrPtr->label2    = labelArr[mplsIndex];
            descrPtr->exp2      = expArr[mplsIndex];
            descrPtr->ttl2      = ttlArr[mplsIndex];

            __LOG(("MPLS label [%d] recognized: label[0x%x] exp[%d] ttl[0x%x] \n",
                mplsIndex,
                labelArr[mplsIndex],
                expArr[mplsIndex],
                ttlArr[mplsIndex]));

            if(descrPtr->numOfLabels >= 2)
            {
                /* third label */
                mplsIndex++;
                descrPtr->label3    = labelArr[mplsIndex];
                descrPtr->exp3      = expArr[mplsIndex];
                descrPtr->ttl3      = ttlArr[mplsIndex];

                __LOG(("MPLS label [%d] recognized: label[0x%x] exp[%d] ttl[0x%x] \n",
                    mplsIndex,
                    labelArr[mplsIndex],
                    expArr[mplsIndex],
                    ttlArr[mplsIndex]));

                if(descrPtr->numOfLabels == mplsIndexMax &&
                    descrPtr->numOfLabels == 3)
                {
                    /* non SIP5 : recognized at least 4 labels */
                    __LOG(("ERROR : Sbit was not set in the third label \n"));
                }
                else
                if(descrPtr->numOfLabels >= 3)
                {
                    /* fourth label */
                    mplsIndex++;
                    descrPtr->ttl4      = ttlArr[mplsIndex];
                    descrPtr->exp4      = expArr[mplsIndex];
                    descrPtr->label4    = labelArr[mplsIndex];

                    __LOG(("MPLS label [%d] recognized: label[0x%x] exp[%d] ttl[0x%x] \n",
                        mplsIndex,
                        labelArr[mplsIndex],
                        expArr[mplsIndex],
                        ttlArr[mplsIndex]));


                    if(descrPtr->numOfLabels == mplsIndexMax &&
                        descrPtr->numOfLabels == 4)
                    {
                        /* SIP5 : recognized at least 5 labels */
                        __LOG(("ERROR : Sbit was not set in the fourth label \n"));
                        descrPtr->l3NotValid = 1;
                    }

                }
            }
        }

        __LOG(("firstNibbleAfterMPLS [0x%x] \n",
            firstNibbleAfterMPLS));

        switch (firstNibbleAfterMPLS)
        {
            case 4:
                descrPtr->protOverMpls = 0; /* protocol over MPLS is IPv4 */
                break;
            case 6:
                descrPtr->protOverMpls = 1; /* protocol over MPLS is IPv6 */
                break;
            default:
                descrPtr->protOverMpls = 2; /* protocol over MPLS is Other */
                break;
        }

        descrPtr->cwFirstNibble = firstNibbleAfterMPLS;

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            regAddress = SMEM_LION3_TTI_UNIT_GLOBAL_CONFIG_EXT_REG(devObjPtr);
            smemRegFldGet(devObjPtr, regAddress, 27, 1, &fldValue);
            descrPtr->enableL3L4ParsingOverMpls = fldValue;
        }
        else
        if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
        {
            /* Get Enable L3 L4 Over MPLS Parsing */
            regAddress = SMEM_XCAT_A1_TTI_UNIT_GLB_CONF_REG(devObjPtr);
            smemRegFldGet(devObjPtr, regAddress, 23, 1, &fldValue);
            descrPtr->enableL3L4ParsingOverMpls = fldValue;
        }

        __LOG(("Enable L3 L4 Over MPLS Parsing: %d \n",
              descrPtr->enableL3L4ParsingOverMpls));

        if(descrPtr->enableL3L4ParsingOverMpls &&
            (descrPtr->protOverMpls == 0 || /*Ipv4*/
             descrPtr->protOverMpls == 1))  /*Ipv6*/
        {
            descrPtr->ingressTunnelInfo.transitType = SNET_INGRESS_TUNNEL_TRANSIT_TYPE_LEGACY_IP_OVER_MPLS_TUNNEL_E;
            __LOG(("transitType = SNET_INGRESS_TUNNEL_TRANSIT_TYPE_LEGACY_IP_OVER_MPLS_TUNNEL_E \n"));

            __LOG(("This packet considered as Ipv4/6 over MPLS transit tunnel (if not tunnel terminated in TTI) \n"));
            snetChtMplsTransitTunnelsProtParsing(devObjPtr, descrPtr,
                LION3_MPLS_TRANSIT_TUNNEL_PARSING_MODE_IP_ONLY_E, internalTtiInfoPtr);

            __LOG(("parsing on passenger is done \n"));
            return GT_TRUE; /* indicates that mpls parsing is done */
        }


        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* the offset from the L3 of the packet of the first byte that come after the recognized MPLS labels */
            GT_U32  offset = 4*(descrPtr->numOfLabels +1);
            __LOG_PARAM(offset);

            /* build the first word after the recognized MPLS labels */
            internalTtiInfoPtr->pwe3CwWord = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[offset]);
            __LOG_PARAM(internalTtiInfoPtr->pwe3CwWord);

            /* get the first nibble (in network order) that come after the recognized MPLS labels */
            internalTtiInfoPtr->firstNibbleAfterSBitLabel = SMEM_U32_GET_FIELD(internalTtiInfoPtr->pwe3CwWord, 28, 4); ;
            __LOG_PARAM(internalTtiInfoPtr->firstNibbleAfterSBitLabel);


            snetLion3TTMplsOamChannelTypeProfile(devObjPtr, descrPtr,
                                                 internalTtiInfoPtr->firstNibbleAfterSBitLabel,
                                                 internalTtiInfoPtr->pwe3CwWord);
        }
    }

    __LOG(("mpls parsing isn't done \n"));
    return GT_FALSE; /* indicates that mpls parsing isn't done */
}

/*******************************************************************************
*   snetChtL3L4ProtParsingArp
*
* DESCRIPTION:
*        Parsing of L3 and L4 protocols header (arp)
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID snetChtL3L4ProtParsingArp
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtL3L4ProtParsingArp);

    GT_U32 startByte;                /* start Byte for ip addresses */

    descrPtr->arp = 1;
    __LOG_PARAM(descrPtr->arp);

    if (descrPtr->macDaType == SKERNEL_BROADCAST_MAC_E)
    {
        __LOG(("macDaType == SKERNEL_BROADCAST_ARP_E"));
        descrPtr->macDaType = SKERNEL_BROADCAST_ARP_E;
    }

    /* SIP */
    startByte = 14;
    descrPtr->sip[0] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);

    startByte = 24;
    descrPtr->dip[0] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);

    __LOG_PARAM(descrPtr->sip[0]);
    __LOG_PARAM(descrPtr->dip[0]);

}


/*******************************************************************************
*   checkIpHeader
*
* DESCRIPTION:
*        Checks ip header (it performes single check)
*
* INPUTS:
*        deviceObj                  - pointer to device object.
*        descrPtr                   - pointer to the frame's descriptor.
*        maskId                     - pre-route exception mask id
*        headerErrorDescriptionPtr  - logger description
* OUTPUTS:
*        descrPtr                   - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID checkIpHeader
(
    IN    SKERNEL_DEVICE_OBJECT               *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC     *descrPtr,
    IN    PRE_ROUT_HEADER_EXCEPTION_CHECK_ENT  maskId,
    IN    GT_CHAR                             *headerErrorDescriptionPtr
)
{
    DECLARE_FUNC_NAME(checkIpHeader);

    GT_U32 maskBit = maskId;
    GT_U32 isMaskEnabled = 0;

    if(descrPtr->ipHeaderError)
    {
        /* 1. support 'priority' of errors
           2. do not allow to set descrPtr->ipHeaderError = 0 after previous 'error' already set it.
        */
        return;
    }

    /* set default value */
    descrPtr->ipHeaderError = 1;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    { /* check pre-route exception mask */

        /* multicast mask bit = unicast mask bit + 1 */
        if(descrPtr->ipm)
        {
            maskBit++;
        }

        smemRegFldGet(devObjPtr, SMEM_LION3_TTI_PRE_ROUTE_EXCEPTION_MASKS_REG(devObjPtr),
                        maskBit, 1, &isMaskEnabled);

        if(isMaskEnabled)
        {
            descrPtr->ipHeaderError = 0; /* doesn't trigger header error exception */
        }
    }

    __LOG(("descrPtr->ipHeaderError = [%d] [%s] \n", descrPtr->ipHeaderError,
         descrPtr->ipHeaderError ? headerErrorDescriptionPtr : "NONE"));
}

/*******************************************************************************
*   checkIpv4Header
*
* DESCRIPTION:
*        Checks ipv4 header
*
* INPUTS:
*        deviceObj    - pointer to device object.
*        descrPtr     - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr     - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID checkIpv4Header
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(checkIpv4Header);

    GT_U32 packetIpCheckSum;    /* calculated checkSum from the ip header */
    GT_U32 headerIpCheckSum;    /* field checkSum from the ip header */
    GT_U32 ipHeadVersion;       /* Ip header version */
    GT_U32 l3TotalLength;       /* Layer 3 total length */
    GT_U32 l3TotalLengthAfterDeduction; /* Layer 3 total length after deduction - for macSec*/
    GT_U32 l3byteOffset;        /* Layer 3 byte offset */
    GT_U32 headerLength;        /* protocol header length (in bytes) */
    GT_U32 crcOnPassengerLength = 0;/* crc bytes of ethernet passenger 'with CRC' */

    /* get protocol header length (in bytes) */
    headerLength = descrPtr->ipxHeaderLength * 4;

    /* the actual checksum received on the packet */
    headerIpCheckSum = (descrPtr->l3StartOffsetPtr[10] << 8) |
                        descrPtr->l3StartOffsetPtr[11];

    descrPtr->l3StartOffsetPtr[10] = 0;
    descrPtr->l3StartOffsetPtr[11] = 0;
    /* calculate the expected checksum */
    packetIpCheckSum = ipV4CheckSumCalc(descrPtr->l3StartOffsetPtr, (GT_U16)headerLength);
    /* restore checksum values */
    descrPtr->l3StartOffsetPtr[10] = (GT_U8)(headerIpCheckSum >> 8);
    descrPtr->l3StartOffsetPtr[11] = (GT_U8)headerIpCheckSum;

    ipHeadVersion = descrPtr->l3StartOffsetPtr[0] >> 4;
    l3TotalLength = (descrPtr->l3StartOffsetPtr[2] << 8) |
                     descrPtr->l3StartOffsetPtr[3];

    /* check deduction due to macsec */
    l3TotalLengthAfterDeduction = snetLion3IpTotalLengthAfterDeduction(devObjPtr, descrPtr, l3TotalLength);

    /* save total ipv4 length (in bytes) */
    descrPtr->ipxLength = l3TotalLengthAfterDeduction;

    l3byteOffset = descrPtr->l2HeaderSize;

    if(headerIpCheckSum != packetIpCheckSum)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV4_UC_HDR_CHKSUM_ERR_MASK_E, "Wrong IP header checksum");
        __LOG_PARAM(headerIpCheckSum);
        __LOG_PARAM(packetIpCheckSum);
    }

    if(ipHeadVersion != 4)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV4_UC_HDR_VER_ERR_MASK_E, "Wrong IP header version");
        __LOG_PARAM(ipHeadVersion);
    }

    if(headerLength < 20 /* 5*4 */)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV4_UC_HDR_LENGTH_ERR_MASK_E, "Wrong IP header header length");
        __LOG_PARAM(headerLength);
    }

    if(headerLength > l3TotalLength)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV4_UC_HDR_LENGTH_ERR_MASK_E,
                            "Header length exceeds total datagram length");
        __LOG_PARAM(headerLength);
        __LOG_PARAM(l3TotalLength);
    }

    if (descrPtr->tunnelTerminated &&
        descrPtr->innerPacketType == SKERNEL_INNER_PACKET_TYPE_ETHERNET_WITH_CRC)
    {
        crcOnPassengerLength = 4;
        __LOG_PARAM(crcOnPassengerLength);
    }

    if((l3TotalLengthAfterDeduction + l3byteOffset + crcOnPassengerLength
              /* + 4 bytes CRC length, but simulation does not create CRC*/ ) > descrPtr->byteCount)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV4_UC_HDR_LENGTH_ERR_MASK_E,
                            "Layer 3 length exceeds total frame length");
    }

    if(descrPtr->sip[0] == descrPtr->dip[0])
    {
        checkIpHeader(devObjPtr, descrPtr, IPV4_UC_HDR_SIP_NE_DIP_ERR_MASK_E,
                                        "Layer 3 header SIP must be != DIP");
    }

    if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        /* extra TTI checking on ch3 and above */
        if(descrPtr->l3StartOffsetPtr[12] == 127 || /*127/8*/
           descrPtr->l3StartOffsetPtr[12] == 224 || /*multicast*/
           descrPtr->sip[0] == 0xffffffff)/* BC */
        {
            descrPtr->ipTtiHeaderError = 1;
            __LOG(("descrPtr->ipTtiHeaderError = 1;"));
        }

        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* extra TTI checking on SIP5 */
            if(((descrPtr->l3StartOffsetPtr[12] == 255)&&
                (descrPtr->l3StartOffsetPtr[13] == 255)&&
                (descrPtr->l3StartOffsetPtr[14] == 255)&&
                (descrPtr->l3StartOffsetPtr[15] == 255)))/*255.255.255.255*/
            {
                descrPtr->ipTtiHeaderError = 1;
                __LOG(("descrPtr->ipTtiHeaderError = 1;"));
            }
        }
        else
        {
            if(descrPtr->l3StartOffsetPtr[12] == 240)/*class E*/
            {
                descrPtr->ipTtiHeaderError = 1;
                __LOG(("descrPtr->ipTtiHeaderError = 1;"));
            }
        }
    }
}


/*******************************************************************************
*   snetChtL3L4ProtParsingIpv4
*
* DESCRIPTION:
*        Parsing of L3 and L4 protocols header (Ipv4)
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID snetChtL3L4ProtParsingIpv4
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtL3L4ProtParsingIpv4);

    GT_U32 startByte;            /* start byte for ip addresses */
    GT_BOOL fragment = GT_FALSE;/* is ipv4/6 considered 'fragment' */

    __LOG(("Internet Protocol, Version 4 (IPv4)"));

    descrPtr->isIp = 1;
    descrPtr->isIPv4 = 1;
    descrPtr->dscp = (descrPtr->l3StartOffsetPtr[1] >> 2) & 0x3f;
    descrPtr->ipProt = descrPtr->l3StartOffsetPtr[9];
    descrPtr->ipv4DontFragmentBit = (descrPtr->l3StartOffsetPtr[6]>>6) & 1;

    __LOG_PARAM(descrPtr->isIp);
    __LOG_PARAM(descrPtr->isIPv4);
    __LOG_PARAM(descrPtr->dscp);
    __LOG_PARAM(descrPtr->ipProt);
    __LOG_PARAM(descrPtr->ipv4DontFragmentBit);

    /* for ipv4 ip header length (in words) = IHL */
    descrPtr->ipxHeaderLength = (descrPtr->l3StartOffsetPtr[0] & 0xf); /* IHL */

    __LOG_PARAM(descrPtr->ipxHeaderLength);

    descrPtr->ipv4HeaderOptionsExists = (descrPtr->ipxHeaderLength > 5) ? 1 : 0;

    __LOG_PARAM(descrPtr->ipv4HeaderOptionsExists);

    descrPtr->ipv4FragmentOffset = ((GT_U32)(descrPtr->l3StartOffsetPtr[6] & 0x1f) << 8) |
                                      (descrPtr->l3StartOffsetPtr[7]);
    __LOG_PARAM(descrPtr->ipv4FragmentOffset);

    fragment = (descrPtr->l3StartOffsetPtr[6] & (1<<5)) == 1 ?
            GT_TRUE :/* fragment */
        /* 13 bits of FragmentOffset in the ip header */
        (( descrPtr->ipv4FragmentOffset) == 0) ?
            GT_FALSE :/* not fragment */
            GT_TRUE;/* fragment */

    __LOG_PARAM(fragment);

    if(fragment == GT_FALSE)
    {
        descrPtr->l4StartOffsetPtr = descrPtr->l3StartOffsetPtr + descrPtr->ipxHeaderLength * 4;
    }

    descrPtr->ttl = descrPtr->l3StartOffsetPtr[8];

    __LOG_PARAM(descrPtr->ttl);

    descrPtr->udpCompatible = (descrPtr->ipProt == SNET_UDP_PROT_E) ||
         ((devObjPtr->supportUdpLite == GT_TRUE) && (descrPtr->ipProt == SNET_UDP_LITE_PROT_E));

    if (descrPtr->udpCompatible && descrPtr->l4StartOffsetPtr)
    {
        if (descrPtr->macDaType == SKERNEL_BROADCAST_MAC_E &&
            descrPtr->l4StartOffsetPtr[2] == 0x02 &&
            descrPtr->l4StartOffsetPtr[3] == 0x08)
        {
            descrPtr->ipv4Ripv1 = 1;
            __LOG(("descrPtr->ipv4Ripv1 = 1;"));
        }
    }
    else if (descrPtr->ipProt == SNET_IGMP_PROT_E && descrPtr->l4StartOffsetPtr)
    {
        if (descrPtr->l4StartOffsetPtr[0] == 0x11)
        {
            descrPtr->igmpQuery = 1;
            __LOG(("descrPtr->igmpQuery = 1;"));
        }
        else
        {
            descrPtr->igmpNonQuery = 1;
            __LOG(("descrPtr->igmpNonQuery = 1;"));
        }
    }
    else if (descrPtr->ipProt == SNET_IPV4_ICMP_PROT_E)
    {
        descrPtr->ipv4Icmp = 1;
        __LOG(("descrPtr->ipv4Icmp = 1;"));
    }

    startByte = 12;

    /* SIP */
    descrPtr->sip[0] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);

    startByte += 4;
    descrPtr->dip[0] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);

    __LOG_PARAM(descrPtr->sip[0]);
    __LOG_PARAM(descrPtr->dip[0]);

    if ((descrPtr->dip[0] & 0xffffff00) == 0xE0000000)
    {
        descrPtr->ipXMcLinkLocalProt = 1;
        __LOG(("descrPtr->ipXMcLinkLocalProt = 1;"));
    }


    if ((descrPtr->dip[0] & 0xf0000000) == 0xE0000000)
    {
        /* DIP is multicast */
        descrPtr->ipm = 1;
        __LOG(("DIP is multicast"));
    }

    /* check header validity */
    checkIpv4Header(devObjPtr, descrPtr);

    descrPtr->l4Valid = 1;

    if(descrPtr->ipTtiHeaderError || descrPtr->ipHeaderError || descrPtr->ipv4FragmentOffset != 0)
    {
        descrPtr->l4Valid = 0;
        descrPtr->l4StartOffsetPtr = NULL;/* CQ#150407 */
    }

    __LOG_PARAM(descrPtr->l4Valid);
}

/*******************************************************************************
*   calcIpv6HeaderLength
*
* DESCRIPTION:
*        calculates ipv6 header length (in words)
*
* INPUTS:
*        deviceObj    - pointer to device object.
*        descrPtr     - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr     - pointer to the frame's descriptor.
*
* RETURNS:
*        ipv6 header length (in words) - 0 means not relevant
*
*******************************************************************************/
static GT_U32 calcIpv6HeaderLength
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    GT_U32 val = 0;
    GT_U32 hdrExtLen = 0;

    if((descrPtr->ipProt == SNET_IPV6_HBH_PROT_E) &&
            (descrPtr->l3StartOffsetPtr[40 + 16*2] == SNET_IPV6_NO_NEXT_HEADER_PROT_E))
    { /* If a single HBH header exists */

        /* get Hdr-Ext-Len -
           Length of HBH header in 8-octet units, not including the first 8 octets. */
        hdrExtLen = descrPtr->l3StartOffsetPtr[40 + 16*2 + 1];

        /* Desc<IPx Header Length> = 10 + (Hdr-Ext-Len+1)*2.
           Where Hdr-Ext-Len is taken from the HBH header */
        val = 10 + (hdrExtLen+1)*2;
    }
    else
    { /* If there are no header extensions Desc<IPx Header Length> = 10 */
        val = 10;
    }

    return val;
}


/*******************************************************************************
*   isIpv6ExtendedHeaderExists
*
* DESCRIPTION:
*        Checks whether ipv6 extended header exists or not
*
* INPUTS:
*        deviceObj    - pointer to device object.
*        descrPtr     - pointer to the frame's descriptor.
*
* OUTPUTS:
*        descrPtr     - pointer to the frame's descriptor.
*
* RETURNS: GT_BIT     - 1 exists, 0 doesn't exists
*
*******************************************************************************/
static GT_BIT isIpv6ExtendedHeaderExists
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(isIpv6ExtendedHeaderExists);

    GT_U32  i;
    GT_U32  regValue;


    /* check standard extended headers */
    for (i = 0; i < ipv6ExtHeadersAmount; i++)
    {
        if (descrPtr->ipProt == ipv6ExtHeaders[i])
        {
            __LOG(("got ipv6 extended header"));
            return 1;
        }
    }

    /*
         Check for extension values
            - <IPv6 Extension Value0>
            - <IPv6 Extension Value1>
    */
    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        smemRegGet(devObjPtr, SMEM_XCAT_TTI_IPV6_EXTENSION_VALUE_REG(devObjPtr) ,&regValue);
        if(SMEM_U32_GET_FIELD(regValue,0,8) == descrPtr->ipProt ||
           SMEM_U32_GET_FIELD(regValue,8,8) == descrPtr->ipProt )
        {
            return 1;
        }
    }

    return 0;
}

/*******************************************************************************
*   checkIpv6Header
*
* DESCRIPTION:
*        Checks ipv6 header
*
* INPUTS:
*        deviceObj    - pointer to device object.
*        descrPtr     - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr     - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID checkIpv6Header
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(checkIpv6Header);

    GT_U32 ipHeadVersion;       /* Ip header version */
    GT_U32 payLoadLength;       /* Ipv6 Payload length */
    GT_U32 l3byteOffset;        /* Layer 3 byte offset */
    GT_U32 l3TotalLengthAfterDeduction; /* Layer 3 total length after deduction - for macSec*/
    GT_U32 sipLoopback;        /* SIP Loopback ?   */
    GT_U32 sipMulticast;       /* SIP Multicast ?  */
    GT_U32 crcOnPassengerLength = 0;/* crc bytes of ethernet passenger 'with CRC' */

    ipHeadVersion = descrPtr->l3StartOffsetPtr[0] >> 4;
    payLoadLength = (descrPtr->l3StartOffsetPtr[4] << 8) |
                     descrPtr->l3StartOffsetPtr[5];

    /* check deduction due to macsec */
    l3TotalLengthAfterDeduction = snetLion3IpTotalLengthAfterDeduction(devObjPtr, descrPtr, payLoadLength);
    __LOG_PARAM(l3TotalLengthAfterDeduction);

    descrPtr->ipxLength = l3TotalLengthAfterDeduction + descrPtr->ipxHeaderLength * 4;

    l3byteOffset = descrPtr->l2HeaderSize;

    if (ipHeadVersion != 6)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV6_UC_HDR_VER_ERR_MASK_E, "Wrong IP header version");
        __LOG_PARAM(ipHeadVersion);
    }

    if (descrPtr->tunnelTerminated &&
        descrPtr->innerPacketType == SKERNEL_INNER_PACKET_TYPE_ETHERNET_WITH_CRC)
    {
        crcOnPassengerLength = 4;
        __LOG_PARAM(crcOnPassengerLength);
    }

    if ((descrPtr->ipxLength + l3byteOffset + crcOnPassengerLength
        /* +  4 bytes CRC length,but simulation does not create CRC*/ ) > descrPtr->byteCount)
    {
        checkIpHeader(devObjPtr, descrPtr, IPV6_UC_HDR_LENGTH_ERR_MASK_E, "Wrong header length");
    }


    if ((descrPtr->sip[0] == descrPtr->dip[0]) && (descrPtr->sip[1] == descrPtr->dip[1]) &&
        (descrPtr->sip[2] == descrPtr->dip[2]) && (descrPtr->sip[3] == descrPtr->dip[3]))
    {
        checkIpHeader(devObjPtr, descrPtr, IPV6_UC_HDR_SIP_NE_DIP_ERR_MASK_E,
                                        "Layer 3 header SIP must be != DIP");
    }


    /*
        An IPv6 TTI SIP Address Error is triggered if ANY of the following TRUE:
        - IPv6 header <SIP> is ::1/128 (Loopback address)
        - IPv6 header <SIP> is FF::/8 (Multicast address)
    */
    sipLoopback =
        ((descrPtr->sip[0] == 0) && (descrPtr->sip[1] == 0)
         && (descrPtr->sip[2] == 0) && (descrPtr->sip[3] == 1));

    sipMulticast = ((descrPtr->sip[0] & 0xFF000000) == 0xFF000000);

    if (sipLoopback || sipMulticast)
    {
        descrPtr->ipTtiHeaderError = 1;
        __LOG(("descrPtr->ipTtiHeaderError = 1;"));
        __LOG_PARAM(sipLoopback);
        __LOG_PARAM(sipMulticast);
    }


    descrPtr->l4Valid = 1;

    if(isIpv6ExtendedHeaderExists(devObjPtr, descrPtr))
    {
        /*If any of the ipv6 extended headers are identified,
          the <Is L4 Valid> indication in the IPCL key is set to NOT VALID: */
        descrPtr->l4Valid = 0;
    }


    if (descrPtr->l4Valid && (descrPtr->ipxHeaderLength > 32))
    { /* For IPv6 if Desc<L4 valid> = 1 then the IP header must be less then 128 bytes */

        checkIpHeader(devObjPtr, descrPtr, IPV6_UC_HDR_LENGTH_ERR_MASK_E, "Wrong header length");
    }

}

/*******************************************************************************
*   snetChtL3L4ProtParsingIpv6
*
* DESCRIPTION:
*        Parsing of L3 and L4 protocols header (Ipv6)
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID snetChtL3L4ProtParsingIpv6
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtL3L4ProtParsingIpv6);

    GT_U32 startByte;            /* start Byte for ip addresses */
    GT_U32 soliciteMask[4];     /* IPv6 Solicited-Node Mcst Mask */
    GT_U32 soliciteValue[4];    /* IPv6 Solicited-Node Mcst Value */
    GT_U32 *regDataPtr;         /* Registers data pointer */
    GT_U32 regNum;              /* Register index */
    GT_BOOL fragment = GT_FALSE;/* is ipv4/6 considered 'fragment' */
    GT_U8 icmpMsgType;

    __LOG(("Internet Protocol, Version 6 (IPv6)"));

    descrPtr->isIp = 1;
    descrPtr->isIPv4 = 0;
    descrPtr->flowLabel = ((descrPtr->l3StartOffsetPtr[1] & 0xf) << 16 |
                           (descrPtr->l3StartOffsetPtr[2] << 8 ) |
                           (descrPtr->l3StartOffsetPtr[3]));

    descrPtr->dscp = ((descrPtr->l3StartOffsetPtr[0] << 2) |
                      (descrPtr->l3StartOffsetPtr[1] >> 6) ) & 0x3f;
    descrPtr->ipProt = descrPtr->l3StartOffsetPtr[6];

    __LOG_PARAM(descrPtr->isIp);
    __LOG_PARAM(descrPtr->isIPv4);
    __LOG_PARAM(descrPtr->flowLabel);
    __LOG_PARAM(descrPtr->dscp);
    __LOG_PARAM(descrPtr->ipProt);

    /* calculate ipv6 header length */
    descrPtr->ipxHeaderLength = calcIpv6HeaderLength(devObjPtr, descrPtr);

    __LOG_PARAM(descrPtr->ipxHeaderLength);

    fragment = (descrPtr->ipProt == 44) ? GT_TRUE : GT_FALSE;

    __LOG_PARAM(fragment);

    if(fragment == GT_FALSE)
    {
        descrPtr->l4StartOffsetPtr = descrPtr->l3StartOffsetPtr + descrPtr->ipxHeaderLength*4;
    }

    descrPtr->ttl = descrPtr->l3StartOffsetPtr[7];

    __LOG_PARAM(descrPtr->ttl);

    descrPtr->udpCompatible = (descrPtr->ipProt == SNET_UDP_PROT_E) ||
         ((devObjPtr->supportUdpLite == GT_TRUE) && (descrPtr->ipProt == SNET_UDP_LITE_PROT_E));

    if (descrPtr->ipProt == SNET_IPV6_ICMP_PROT_E && descrPtr->l4StartOffsetPtr)
    {
        descrPtr->ipv6Icmp = 1;
        descrPtr->ipv6IcmpType = descrPtr->l4StartOffsetPtr[0];
    }
    else if (descrPtr->ipProt == 0 && descrPtr->l4StartOffsetPtr &&
             descrPtr->l4StartOffsetPtr[0] == SNET_IPV6_ICMP_PROT_E)
    {
        descrPtr->ipv6Icmp = 1;
        descrPtr->ipv6IcmpType = descrPtr->l4StartOffsetPtr[8];
    }

    __LOG_PARAM(descrPtr->ipv6Icmp);
    __LOG_PARAM(descrPtr->ipv6IcmpType);

    descrPtr->isIpV6EhExists = isIpv6ExtendedHeaderExists(devObjPtr, descrPtr);

    descrPtr->isIpV6EhHopByHop =
        (descrPtr->ipProt == IPV6_EXT_HDR_HOP_BY_HOP_CNS)
        ? 1 : 0;

    __LOG_PARAM(descrPtr->isIpV6EhExists);
    __LOG_PARAM(descrPtr->isIpV6EhHopByHop);


    if (descrPtr->isIpV6EhExists)
    {
        /* skip extended header */
        GT_U32 payloadSize = (descrPtr->l3StartOffsetPtr[4] << 8) + descrPtr->l3StartOffsetPtr[5];
        icmpMsgType = descrPtr->l3StartOffsetPtr[payloadSize];
    }
    else
    {
        icmpMsgType = descrPtr->l4StartOffsetPtr[0];
    }

    __LOG_PARAM(icmpMsgType);

    switch (icmpMsgType)
    {
        case 131: /* Group Membership Report */
        case 132: /* Group Membership Reduction */
        case 133: /* Router Solicitation */
        case 143: /* MLDv2 Multicast Listener Report */
            descrPtr->isIpv6Mld = 1;
            break;
        default:
            descrPtr->isIpv6Mld = 0;
            break;
    }

    __LOG_PARAM(descrPtr->isIpv6Mld);

    startByte = 8;

    /* SIP */
    __LOG(("SIP"));
    descrPtr->sip[0] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);
    startByte+=4;
    descrPtr->sip[1] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);
    startByte+=4;
    descrPtr->sip[2] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);
    startByte+=4;
    descrPtr->sip[3] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);

    __LOG_PARAM(descrPtr->sip[0]);
    __LOG_PARAM(descrPtr->sip[1]);
    __LOG_PARAM(descrPtr->sip[2]);
    __LOG_PARAM(descrPtr->sip[3]);

    /* DIP */
    __LOG(("DIP"));
    startByte+=4;
    descrPtr->dip[0] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);
    startByte+=4;
    descrPtr->dip[1] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);
    startByte+=4;
    descrPtr->dip[2] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);
    startByte+=4;
    descrPtr->dip[3] = SNET_BUILD_WORD_FROM_BYTES_PTR_MAC(&descrPtr->l3StartOffsetPtr[startByte]);

    __LOG_PARAM(descrPtr->dip[0]);
    __LOG_PARAM(descrPtr->dip[1]);
    __LOG_PARAM(descrPtr->dip[2]);
    __LOG_PARAM(descrPtr->dip[3]);

    if ((descrPtr->dip[0] & 0xffffffff) == 0xFF020000 &&
        (descrPtr->dip[1] & 0xffffffff) == 0 &&
        (descrPtr->dip[2] & 0xffffffff)  == 0 &&
        (descrPtr->dip[3] & 0xffff0000) == 0 )
    {
        descrPtr->ipXMcLinkLocalProt = 1;
    }

    __LOG_PARAM(descrPtr->ipXMcLinkLocalProt);

    regDataPtr = smemMemGet(devObjPtr, SMEM_CHT_SOLIC_NODE_MCST_ADDR_REG(devObjPtr));
    for(regNum = 0; regNum < 4; regNum++)
    {
        soliciteValue[3 - regNum] = regDataPtr[regNum];
    }

    regDataPtr = smemMemGet(devObjPtr, SMEM_CHT_SOLIC_NODE_MCST_MASK_REG(devObjPtr));
    for(regNum = 0; regNum < 4; regNum++)
    {
        soliciteMask[3 - regNum] = regDataPtr[regNum];
    }

    if (((descrPtr->dip[0] & soliciteMask[0]) == (soliciteMask[0] & soliciteValue[0])) &&
        ((descrPtr->dip[1] & soliciteMask[1]) == (soliciteMask[1] & soliciteValue[1])) &&
        ((descrPtr->dip[2] & soliciteMask[2]) == (soliciteMask[2] & soliciteValue[2])) &&
        ((descrPtr->dip[3] & soliciteMask[3]) == (soliciteMask[3] & soliciteValue[3])))
    {
        descrPtr->solicitationMcastMsg = 1;
    }

    __LOG_PARAM(descrPtr->solicitationMcastMsg);

    if((descrPtr->dip[0] & 0xFF000000) == 0xFF000000)
    {
        /* DIP is multicast */
        descrPtr->ipm = 1;
        __LOG(("DIP is multicast"));
    }

    /* check header validity */
    checkIpv6Header(devObjPtr, descrPtr);

    if(descrPtr->ipTtiHeaderError || descrPtr->ipHeaderError)
    {
        __LOG(("ipv6: there are header errors"));

        descrPtr->l4Valid = 0;

        descrPtr->l4StartOffsetPtr = NULL;/* CQ#150407 */
    }
    else
    {
        __LOG(("ipv6: there are no header errors"));
    }


    __LOG_PARAM(descrPtr->ipm);
    __LOG_PARAM(descrPtr->l4Valid);

}

/*******************************************************************************
*   snetChtL3L4ProtParsingMim
*
* DESCRIPTION:
*        Parsing of L3 and L4 protocols header (MIM)
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*        etherType  - packet ethernet type
*        internalTtiInfoPtr - internal tti info
* OUTPUTS:
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
static GT_VOID snetChtL3L4ProtParsingMim
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN    GT_U32                           etherType,
    IN INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtL3L4ProtParsingMim);

    GT_U32 mimIEtherType;         /* MIM I-EtherType */
    GT_U32 startBit;

    if (!SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        return;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        startBit = 0;
    }
    else
    {
        startBit = 16;
    }

    /* MIM packets are identified according to the configurable I-EtherType */
    smemRegFldGet(devObjPtr, SMEM_XCAT_SPECIAL_ETHERTYPES_REG(devObjPtr),
                    startBit, 16, &mimIEtherType);

    __LOG_PARAM(mimIEtherType);

    if (etherType != mimIEtherType)
    {
        __LOG(("packet is NOT MIM (mac in mac) \n"));
        return;
    }

    __LOG(("packet is MIM (mac in mac) \n"));

    descrPtr->mim   = 1;
    descrPtr->iUp   = (GT_U32)((descrPtr->l3StartOffsetPtr[0] >> 5) & 0x7);
    descrPtr->iDp   = (GT_BIT)((descrPtr->l3StartOffsetPtr[0] >> 4) & 0x1);
    descrPtr->iRes1 = (GT_U32)((descrPtr->l3StartOffsetPtr[0] >> 2) & 0x3);
    descrPtr->iRes2 = (GT_U32)((descrPtr->l3StartOffsetPtr[0] >> 0) & 0x3);
    descrPtr->iSid  = (GT_U32)((descrPtr->l3StartOffsetPtr[1] << 16)) |
                      (GT_U32)((descrPtr->l3StartOffsetPtr[2] << 8))  |
                      (GT_U32)((descrPtr->l3StartOffsetPtr[3]));

    __LOG_PARAM(descrPtr->mim);
    __LOG_PARAM(descrPtr->iUp);
    __LOG_PARAM(descrPtr->iDp);
    __LOG_PARAM(descrPtr->iRes1);
    __LOG_PARAM(descrPtr->iRes2);
    __LOG_PARAM(descrPtr->iSid);

    descrPtr->ingressTunnelInfo.innerFrameDescrPtr =
            snetChtEqDuplicateDescr(devObjPtr, descrPtr);
    /*
        6 bytes - Backbone destination address (B-DA) (six bytes)
        6 bytes - Backbone source address (B-SA) (six bytes)
        2 bytes - EtherType 0x88A8 (two bytes)
        2 bytes - B-TAG/B-VID (two bytes), this is the backbone VLAN indicator
            Service encapsulation, that has:
        2 bytes - EtherType 0x88E7 (two bytes)
        1 byte - Flags that contain priority, Drop Eligible Indicator (DEI) and No Customer Address (NCA) indication (e.g. OAM frames).
        3 bytes - I-SID, the service identifier (three bytes)
        =============
        total 22 bytes
    */
    descrPtr->ingressTunnelInfo.innerFrameDescrPtr->startFramePtr =
        descrPtr->startFramePtr + 22;/* start of 'inner frame' */

    /* reset the L3 pointer , because it is not relevant any more -->
               will be set inside snetChtL2Parsing(...) for the 'passenger'  */
    descrPtr->ingressTunnelInfo.innerFrameDescrPtr->l3StartOffsetPtr = NULL;
    descrPtr->ingressTunnelInfo.innerFrameDescrPtr->macDaPtr = DST_MAC_FROM_TUNNEL_DSCR(descrPtr->ingressTunnelInfo.innerFrameDescrPtr);
    descrPtr->ingressTunnelInfo.innerFrameDescrPtr->macSaPtr = SRC_MAC_FROM_TUNNEL_DSCR(descrPtr->ingressTunnelInfo.innerFrameDescrPtr);

    /* do re-parsing on the passenger , to set the L2 info about vlan tag*/
    snetChtL2Parsing(devObjPtr,
        descrPtr->ingressTunnelInfo.innerFrameDescrPtr,
        SNET_CHT_FRAME_PARSE_MODE_FROM_TTI_PASSENGER_E,
        internalTtiInfoPtr);

    descrPtr->ingressTunnelInfo.innerMacDaPtr = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->macDaPtr;
    descrPtr->ingressTunnelInfo.innerPacketL2FieldsAreValid = 1;
    /* set innerTag0Exists,innerPacketTag0Vid,innerPacketTag0CfiDei,innerPacketTag0Up fields in descriptor */
    snetLion3PassengerOuterTagIsTag0_1(devObjPtr,descrPtr);

    /* we not keep this internal frame info to not impact our QOS/hash decisions */
    descrPtr->ingressTunnelInfo.innerFrameDescrPtr = NULL;
}

/*******************************************************************************
*   snetChtL3L4ProtParsing
*
* DESCRIPTION:
*        Parsing of L3 and L4 protocols header
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*        etherType  - packet ethernet type
*        internalTtiInfoPtr - internal tti info
* OUTPUTS:
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
extern GT_VOID snetChtL3L4ProtParsing
(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN    GT_U32                           etherType,
    IN    INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtL3L4ProtParsing);
    GT_U32  Tcp_data_offset;
    GT_U32  stopParsing = 0;

    __LOG(("Dump first 32 bytes of the L3 header \n"));
    /* dump the start of L3 */
    simLogPacketDump(devObjPtr,
                    GT_TRUE/*ingress*/,
                    descrPtr->localDevSrcPort,/* local device source port */
                    descrPtr->l3StartOffsetPtr,/*start of L3 header */
                    32);/* dump 32 bytes of the header */

    __LOG(("************************************************************* \n"));
    __LOG(("************** start parse L3 header of the packet ********** \n"));
    __LOG(("************************************************************* \n"));
    if (etherType == SKERNEL_L3_PROT_TYPE_ARP_E)      /* Address Resolution Protocol (ARP) */
    {
        __LOG(("L3 is ARP \n"));
        snetChtL3L4ProtParsingArp(devObjPtr, descrPtr);
    }
    else if (etherType == SKERNEL_L3_PROT_TYPE_IPV4_E) /* Internet Protocol, Version 4 (IPv4) */
    {
        __LOG(("L3 is Ipv4 \n"));
        snetChtL3L4ProtParsingIpv4(devObjPtr, descrPtr);
    }
    else if (etherType == SKERNEL_L3_PROT_TYPE_IPV6_E) /* Internet Protocol, Version 6 (IPv6) */
    {
        __LOG(("L3 is Ipv6 \n"));
        snetChtL3L4ProtParsingIpv6(devObjPtr, descrPtr);
    }
    else if( parseMpls(devObjPtr, descrPtr, etherType, internalTtiInfoPtr) )/* check if MPLS */
    {
        __LOG(("MPLS passenger (inner frame) parsing is done\n"));
        stopParsing = 1;
    }
    else
    {
        snetChtL3L4ProtParsingMim(devObjPtr, descrPtr, etherType, internalTtiInfoPtr);
    }

    __LOG(("************************************************************* \n"));
    __LOG(("************** end parse L3 header of the packet   ********** \n"));
    __LOG(("************************************************************* \n"));

    if(stopParsing)
    {
        /* do the return after LOG info */
        return;
    }


    if(descrPtr->l4StartOffsetPtr)
    {
        __LOG(("Dump first 16 bytes of the L4 header \n"));
        /* dump the start of L4 */
        simLogPacketDump(devObjPtr,
                        GT_TRUE/*ingress*/,
                        descrPtr->localDevSrcPort,/* local device source port */
                        descrPtr->l4StartOffsetPtr,/*start of L4 header */
                        16);/* dump 32 bytes of the header */
    }
    else
    {
        __LOG(("NO L4 header in this packet \n"));
    }

    __LOG_PARAM(descrPtr->ipProt);

    if((descrPtr->udpCompatible || descrPtr->ipProt == SNET_TCP_PROT_E)
       && descrPtr->l4StartOffsetPtr)
    {
        __LOG(("************************************************************* \n"));
        __LOG(("************** start parse L4 header of the packet ********** \n"));
        __LOG(("************************************************************* \n"));

        descrPtr->l4SrcPort = (descrPtr->l4StartOffsetPtr[0] << 8) |
                     (descrPtr->l4StartOffsetPtr[1]);

        descrPtr->l4DstPort = (descrPtr->l4StartOffsetPtr[2] << 8) |
                     (descrPtr->l4StartOffsetPtr[3]);

        __LOG_PARAM(descrPtr->l4SrcPort);
        __LOG_PARAM(descrPtr->l4DstPort);

        if(descrPtr->ipProt == SNET_TCP_PROT_E)
        {
            __LOG(("L4 is TCP \n"));

            descrPtr->tcpFlags = descrPtr->l4StartOffsetPtr[13] & 0x3F;/*6 bits*/
            descrPtr->tcpSyn = SMEM_U32_GET_FIELD(descrPtr->tcpFlags,1,1);
            if(descrPtr->tcpSyn)
            {
                Tcp_data_offset = descrPtr->l4StartOffsetPtr[12] >> 4;/*4 MSBits*/

                if(descrPtr->ipxLength  != ((Tcp_data_offset*4) + descrPtr->ipxLength))
                {
                    /* there are bytes abter the TCP header .. so we consider it as "SYN with data" */
                    descrPtr->tcpSynWithData = 1;
                }
            }

            __LOG_PARAM(descrPtr->tcpFlags);
            __LOG_PARAM(descrPtr->tcpSyn);
            __LOG_PARAM(descrPtr->tcpSynWithData);
        }
        else
        {
            __LOG(("L4 is UDP \n"));
        }

        __LOG(("************************************************************* \n"));
        __LOG(("************** end parse L4 header of the packet   ********** \n"));
        __LOG(("************************************************************* \n"));
    }

    if(descrPtr->l4StartOffsetPtr)
    {
        descrPtr->l23HeaderSize = descrPtr->l4StartOffsetPtr - descrPtr->startFramePtr;
    }

    __LOG(("****Start Trunk Hash (simple hash) calculation \n"));
    /* Trunk Hash calculation */
    if (SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        snetXCatA1TrunkHash(devObjPtr, descrPtr);
    }
    else
    {
        snetChtTrunkHash(devObjPtr, descrPtr);
    }
    __LOG(("****End Trunk Hash (simple hash) calculation \n"));
}

/*******************************************************************************
*   snetChtL3L4ProtParsingResetDesc
*
* DESCRIPTION:
*       reset the fileds that involved in Parsing of L3 and L4 protocols header
*       this is needed since the TTI need to reparse the L3,L4 when it terminates
*       the tunnel.
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
extern GT_VOID snetChtL3L4ProtParsingResetDesc
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    if(descrPtr->macDaType == SKERNEL_BROADCAST_ARP_E)
    {
        descrPtr->macDaType = SKERNEL_BROADCAST_MAC_E;
    }

    descrPtr->arp = 0;
    descrPtr->isIp = 0;
    descrPtr->isIPv4 = 0;
    descrPtr->isFcoe = 0;
    descrPtr->l4StartOffsetPtr = NULL;
    descrPtr->udpCompatible = GT_FALSE;
    descrPtr->igmpQuery = 0;
    descrPtr->ipv4Ripv1 = 0;
    descrPtr->igmpNonQuery = 0;
    descrPtr->ipv4Icmp = 0;
    descrPtr->ipXMcLinkLocalProt = 0;
    descrPtr->ipm = 0;
    descrPtr->ipv6Icmp = 0;
    descrPtr->solicitationMcastMsg = 0;
    descrPtr->mpls = 0;
    descrPtr->numOfLabels = 0;
    descrPtr->ipProt = 0;
    descrPtr->mim = 0;
    descrPtr->l4Valid = 0;
    descrPtr->ipHeaderError = 0;
    descrPtr->tcpFlags = 0;
    descrPtr->tcpSyn = 0;
    descrPtr->tcpSynWithData = 0;
    descrPtr->ttl = 0;

}

/*******************************************************************************
*   snetChtL3L4ProtCopyDesc
*
* DESCRIPTION:
*       copy ONLY L3/L4 relevant fields from source to target descriptor
*
* INPUTS:
*        trgDescrPtr   - pointer to the target frame's descriptor.
*        srcDescrPtr   - pointer to the source frame's descriptor.
*
*******************************************************************************/
extern GT_VOID snetChtL3L4ProtCopyDesc
(
    OUT SKERNEL_FRAME_CHEETAH_DESCR_STC * trgDescrPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC * srcDescrPtr
)
{
    /* scibAccessLock the needed for __LOG_NO_LOCATION_META_DATA inside CPY_DESC_FIELD_MAC */
    scibAccessLock();
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    macDaType                );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    isIp                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    isIPv4                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    dscp                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    l3StartOffsetPtr         );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    l4StartOffsetPtr         );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ttl                      );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    udpCompatible            );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipv4Ripv1                );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    igmpQuery                );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    igmpNonQuery             );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipv4Icmp                 );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipXMcLinkLocalProt       );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipm                      );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipTtiHeaderError         );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipHeaderError            );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    flowLabel                );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipv6Icmp                 );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipv6IcmpType             );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    sip[0]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    sip[1]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    sip[2]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    sip[3]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    dip[0]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    dip[1]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    dip[2]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    dip[3]                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipXMcLinkLocalProt       );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    solicitationMcastMsg     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    mpls                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    label1                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    exp1                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ttl1                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    label2                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    exp2                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ttl2                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    label3                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    exp3                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ttl3                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    numOfLabels              );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    protOverMpls             );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    mim                      );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    iUp                      );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    iDp                      );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    iRes1                    );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    iRes2                    );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    iSid                     );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipProt                   );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    l4SrcPort                );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    l4DstPort                );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    l23HeaderSize            );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    pktHash                  );
    CPY_DESC_FIELD_MAC(trgDescrPtr,srcDescrPtr,    ipv4FragmentOffset       );
    scibAccessUnlock();
}
/*******************************************************************************
*   snetChtDsaTag4WordsTagParsing
*
* DESCRIPTION:
*        Parsing of Marvell tag of 4 words. extra/update parse according to 4
*        words DSA tag format
*        NOTE: words 0,1 already parsed before calling this function.
*
* INPUTS:
*       deviceObj        - pointer to device object.
*       descrPtr         - pointer to the frame's descriptor.
*       mtag[]           - 4 words DSA tag (in little endian format)
* OUTPUT:
*       none
*
*   NOTE : this function do only "parsing" not more , no read of registers and
*          no setting fields that not relate to DSA parsing
*
********************************************************************************/
static GT_VOID snetChtDsaTag4WordsTagParsing
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32   mtag[/*4*/]
)
{
    DECLARE_FUNC_NAME(snetChtDsaTag4WordsTagParsing);

    switch(descrPtr->packetCmd)
    {
        case SKERNEL_EXT_PKT_CMD_FORWARD_E:/*SKERNEL_MTAG_CMD_FORWARD_E*/
            /**********/
            /* word 1 */
            /**********/

            if(descrPtr->origIsTrunk == 0)
            {
                /* Src ePort[6] */
                SMEM_U32_SET_FIELD(descrPtr->origSrcEPortOrTrnk,6,1,
                    SMEM_U32_GET_FIELD(mtag[1],30,1));
            }

            if(descrPtr->useVidx == 0)
            {
                /*TrgPort[0..6]*/
                __LOG(("TrgPort[0..6]"));
                descrPtr->eArchExtInfo.trgPhyPort = SMEM_U32_GET_FIELD(mtag[1],5,7);

                descrPtr->trgEPort = SNET_CHT_NULL_PORT_CNS;/* not valid yet */
            }

            /**********/
            /* word 2 */
            /**********/
            if(descrPtr->useVidx == 0)
            {
                /*Indicates whether the target physical port field <TrgPort> in this DSA tag is valid*/
                descrPtr->eArchExtInfo.isTrgPhyPortValid = SMEM_U32_GET_FIELD(mtag[2],29,1);
                /*TrgPort[7]*/
                SMEM_U32_SET_FIELD(descrPtr->eArchExtInfo.trgPhyPort,7,1,
                    SMEM_U32_GET_FIELD(mtag[2],28,1));
            }

            SMEM_U32_SET_FIELD(descrPtr->sstId,5,7,
                SMEM_U32_GET_FIELD(mtag[2],21,7));

            SMEM_U32_SET_FIELD(descrPtr->srcDev,5,7,
                SMEM_U32_GET_FIELD(mtag[2],14,7));
            if(descrPtr->origIsTrunk)
            {
                SMEM_U32_SET_FIELD(descrPtr->origSrcEPortOrTrnk,7,5,
                    SMEM_U32_GET_FIELD(mtag[2],3,5));
            }
            else
            {
                SMEM_U32_SET_FIELD(descrPtr->origSrcEPortOrTrnk,7,10,
                    SMEM_U32_GET_FIELD(mtag[2],3,10));
            }
            /*The TPID index of Tag0*/
            descrPtr->tpidIndex[SNET_CHT_TAG_0_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[2],0,3);

            /**********/
            /* word 3 */
            /**********/
            SMEM_U32_SET_FIELD(descrPtr->eVid,12,4,
                SMEM_U32_GET_FIELD(mtag[3],27,4));

            /*Indicates if the packet was received tagged with tag1*/
            descrPtr->tagSrcTagged[SNET_CHT_TAG_1_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[3],26,1);
            /* When both <SrcTagged / Tag0SrcTagged> = 1 (which is Tag0 SrcTagged) AND <Tag1 SrcTagged> = 1,
               indicating that the packet was received tagged with both Tag0 and Tag1, this bit indicates
               which of these two tags is the outer tag */
            descrPtr->tag0IsOuterTag = SMEM_U32_GET_FIELD(mtag[3],25,1);

            if(descrPtr->useVidx)
            {
                SMEM_U32_SET_FIELD(descrPtr->eVidx,12,4,
                    SMEM_U32_GET_FIELD(mtag[3],20,4));


                descrPtr->eArchExtInfo.origSrcPhyIsTrunk   = SMEM_U32_GET_FIELD(mtag[3],19,1);
                if(descrPtr->eArchExtInfo.origSrcPhyIsTrunk)
                {
                    /* trunkId */
                    descrPtr->eArchExtInfo.origSrcPhyPortTrunk = SMEM_U32_GET_FIELD(mtag[3],7,12);
                }
                else
                {
                    /* port */
                    descrPtr->eArchExtInfo.origSrcPhyPortTrunk = SMEM_U32_GET_FIELD(mtag[3],7,8);
                }
                /* Indicates to the remote device whether to perform VIDX MC source filtering based on <OrigSrcPhyPort/Trunk>
                    0 = Do not perform VIDX physical source filtering
                    1 = Perform VIDX physical source filtering */
                descrPtr->eArchExtInfo.phySrcMcFilterEn = SMEM_U32_GET_FIELD(mtag[3],6,1);

            }
            else
            {
                descrPtr->eArchExtInfo.phySrcMcFilterEn = 0;
                descrPtr->trgEPort = SMEM_U32_GET_FIELD(mtag[3],7,17);
                SMEM_U32_SET_FIELD(descrPtr->trgDev,5,7,
                    SMEM_U32_GET_FIELD(mtag[3],0,7));
            }



            break;

        case SKERNEL_EXT_PKT_CMD_FROM_CPU_E:/*SKERNEL_MTAG_CMD_FROM_CPU_E*/
            /**********/
            /* word 0 */
            /**********/
            /* NOTE: parsed from the DSA even if descrPtr->useVidx == 0 !!! */
            descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] =
                SMEM_U32_GET_FIELD(mtag[0], 29, 1);
            if(descrPtr->useVidx)
            {
                /* this field is not relevant when useVidx = 1 */
                descrPtr->trgTagged = 0;
            }

            /**********/
            /* word 1 */
            /**********/
            if(descrPtr->useVidx == 0)
            {
                /*TrgPort[0..5]*/
                descrPtr->eArchExtInfo.trgPhyPort = descrPtr->trgEPort;

                /*TrgPort[5..6]*/
                SMEM_U32_SET_FIELD(descrPtr->eArchExtInfo.trgPhyPort,5,2,
                    SMEM_U32_GET_FIELD(mtag[1],10,2));
            }

            /**********/
            /* word 2 */
            /**********/
            if(descrPtr->useVidx == 0)
            {
                /*Indicates whether the target physical port field <TrgPort> in this DSA tag is valid*/
                descrPtr->eArchExtInfo.isTrgPhyPortValid = SMEM_U32_GET_FIELD(mtag[2],29,1);
                /*TrgPort[7]*/
                SMEM_U32_SET_FIELD(descrPtr->eArchExtInfo.trgPhyPort,7,1,
                    SMEM_U32_GET_FIELD(mtag[2],28,1));
            }

            SMEM_U32_SET_FIELD(descrPtr->sstId,5,7,
                SMEM_U32_GET_FIELD(mtag[2],21,7));

            SMEM_U32_SET_FIELD(descrPtr->srcDev,5,7,
                SMEM_U32_GET_FIELD(mtag[2],14,7));

            if(descrPtr->useVidx)
            {
                if(descrPtr->excludeIsTrunk)
                {
                    SMEM_U32_SET_FIELD(descrPtr->excludedTrunk,7,5,
                        SMEM_U32_GET_FIELD(mtag[2],3,5));
                }
                else /*excluded port */
                {
                    SMEM_U32_SET_FIELD(descrPtr->excludedPort,6,11,
                        SMEM_U32_GET_FIELD(mtag[2],3,11));
                }
            }

            /*The TPID index of Tag0*/
            descrPtr->tpidIndex[SNET_CHT_TAG_0_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[2],0,3);

            /**********/
            /* word 3 */
            /**********/
            SMEM_U32_SET_FIELD(descrPtr->eVid,12,4,
                SMEM_U32_GET_FIELD(mtag[3],27,4));

            /* NOTE: parsed from the eDSA even if descrPtr->useVidx == 0 !!! */
            /*Indicates if the packet was received tagged with tag1*/
            descrPtr->tagSrcTagged[SNET_CHT_TAG_1_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[3],26,1);
            /* When both <SrcTagged / Tag0SrcTagged> = 1 (which is Tag0 SrcTagged) AND <Tag1 SrcTagged> = 1,
               indicating that the packet was received tagged with both Tag0 and Tag1, this bit indicates
               which of these two tags is the outer tag */
            descrPtr->tag0IsOuterTag = SMEM_U32_GET_FIELD(mtag[3],25,1);
            if(descrPtr->useVidx)
            {
                SMEM_U32_SET_FIELD(descrPtr->eVidx,12,4,
                    SMEM_U32_GET_FIELD(mtag[3],20,4));

                if(descrPtr->excludeIsTrunk == 0)
                {
                    /* This field determines whether the value in <ExcludedPort /ExcludedePort> contains a 20b
                        ePort number to exclude from an L2MLL multicast group, or a physical 8b port number to
                        exclude from an L2 MC group
                        0 = ePort: The <ExcludedPort /ExcludedePort> field contains a 20b ePort number to exclude
                        1 = Port: The <ExcludedPort /ExcludedePort> field contains an 8b Physical port number to
                        exclude */
                    descrPtr->eArchExtInfo.fromCpu.excludedIsPhyPort =
                        SMEM_U32_GET_FIELD(mtag[3],19,1);

                    SMEM_U32_SET_FIELD(descrPtr->excludedDevice,5,7,
                        SMEM_U32_GET_FIELD(mtag[3],0,7));
                }
            }
            else
            {
                descrPtr->trgEPort = SMEM_U32_GET_FIELD(mtag[3],7,17);
                SMEM_U32_SET_FIELD(descrPtr->trgDev,5,7,
                    SMEM_U32_GET_FIELD(mtag[3],0,7));
            }

            break;
        case SKERNEL_EXT_PKT_CMD_FROM_CSCD_TO_CPU_E:/*SKERNEL_MTAG_CMD_TO_CPU_E*/

            /**********/
            /* word 1 */
            /**********/
            /*SrcPort[6]/TrgPort[6]/SrcTrunk[6]*/
            SMEM_U32_SET_FIELD(descrPtr->srcTrgPhysicalPort,6,1,
                SMEM_U32_GET_FIELD(mtag[1],11,1));

            /**********/
            /* word 2 */
            /**********/
            descrPtr->eArchExtInfo.packetIsTT = SMEM_U32_GET_FIELD(mtag[2],25,1);

            /*TrgPort[7]*/
            SMEM_U32_SET_FIELD(descrPtr->srcTrgPhysicalPort,7,1,
                SMEM_U32_GET_FIELD(mtag[2],20,1));

            if(descrPtr->origIsTrunk)
            {
                descrPtr->origSrcEPortOrTrnk = SMEM_U32_GET_FIELD(mtag[2],3,12);
                descrPtr->eArchExtInfo.srcTrgEPort = SMEM_U32_GET_FIELD(mtag[2],3,12);
            }
            else
            {
                descrPtr->eArchExtInfo.srcTrgEPort = SMEM_U32_GET_FIELD(mtag[2],3,17);

                descrPtr->origSrcEPortOrTrnk = (descrPtr->srcTrg == 0) ?
                        descrPtr->eArchExtInfo.srcTrgEPort :
                        0;
            }

            /*The TPID index of Tag0*/
            descrPtr->tpidIndex[SNET_CHT_TAG_0_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[2],0,3);

            /**********/
            /* word 3 */
            /**********/
            SMEM_U32_SET_FIELD(descrPtr->eVid,12,4,
                SMEM_U32_GET_FIELD(mtag[3],27,4));

            descrPtr->flowId = SMEM_U32_GET_FIELD(mtag[3],7,20);
            if(descrPtr->eArchExtInfo.packetIsTT)
            {
                descrPtr->tunnelTerminationOffset = descrPtr->flowId;
                descrPtr->flowId = 0;
            }


            /*srcTrgDev[11:5]*/
            SMEM_U32_SET_FIELD(descrPtr->srcTrgDev,5,7,
                SMEM_U32_GET_FIELD(mtag[3],0,7));

            if (descrPtr->srcTrg == 1)
            {
                descrPtr->trgDev = descrPtr->srcTrgDev;
            }

            /*TrgPort*/
            descrPtr->eArchExtInfo.trgPhyPort = (descrPtr->srcTrg == 1) /*target*/?
                                  descrPtr->srcTrgPhysicalPort :
                                  SNET_CHT_NULL_PORT_CNS;

            descrPtr->trgEPort  = descrPtr->eArchExtInfo.trgPhyPort;/*Dont care (assign same logic as used for <TrgPort>)*/

            descrPtr->srcDev = descrPtr->srcTrgDev;
            break;

        case SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E:/*SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E*/
            /**********/
            /* word 1 */
            /**********/
            /*TrgPort[6]/SrcPort[6]*/
            SMEM_U32_SET_FIELD(descrPtr->srcTrgPhysicalPort,6,1,
                SMEM_U32_GET_FIELD(mtag[1],11,1));

            /*Analyzer_UseVIDX*/
            descrPtr->useVidx =
                SMEM_U32_GET_FIELD(mtag[1],26,1);

            if(descrPtr->useVidx == 0)
            {
                /*Analyzer_isTrgPhyPortValid*/
                descrPtr->eArchExtInfo.isTrgPhyPortValid =
                    SMEM_U32_GET_FIELD(mtag[1],27,1);
            }
            /*Analyzer_TrgDev*/
            descrPtr->trgDev =
                SMEM_U32_GET_FIELD(mtag[1],14,12);
            /*Analyzer_TrgPort*/
            descrPtr->eArchExtInfo.trgPhyPort =
                SMEM_U32_GET_FIELD(mtag[1],0,8);

            /**********/
            /* word 2 */
            /**********/
            /*TrgPort[7]/SrcPort[7]*/
            SMEM_U32_SET_FIELD(descrPtr->srcTrgPhysicalPort,7,1,
                SMEM_U32_GET_FIELD(mtag[2],20,1));

            descrPtr->eArchExtInfo.srcTrgEPort = SMEM_U32_GET_FIELD(mtag[2],3,17);

            /*The TPID index of Tag0*/
            descrPtr->tpidIndex[SNET_CHT_TAG_0_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[2],0,3);

            /**********/
            /* word 3 */
            /**********/
            /* next note from the eBook 1.7 */
            /* NOTE: In TO_ANALYZER eDSA tag, instead of setting the eVLAN, the header alteration
                sets 12 bits Tag0 VID. eVLAN[15:12] bits are set in this tag as well, but are not
                used by the ingress assignment

                descrPtr->eVid = {4b0, DSA<VID>}*/
            /*SMEM_U32_SET_FIELD(descrPtr->eVid,12,4,
                SMEM_U32_GET_FIELD(mtag[3],27,4));*/


            if(descrPtr->useVidx == 0)
            {
                descrPtr->trgEPort =
                    SMEM_U32_GET_FIELD(mtag[3],7,17);
            }
            else
            {
                descrPtr->eVidx =
                    SMEM_U32_GET_FIELD(mtag[3],7,16);
            }

            /*TrgDev[11:5]/SrcDev[11:5]*/
            SMEM_U32_SET_FIELD(descrPtr->srcTrgDev,5,7,
                SMEM_U32_GET_FIELD(mtag[3],0,7));

            /* next fields not used any more in sip5 */
            {  SIM_TBD_BOOKMARK /* sip 5 : need to remove use of those */
                descrPtr->eArchExtInfo.toTargetSniffInfo.sniffUseVidx = descrPtr->useVidx;
                descrPtr->eArchExtInfo.toTargetSniffInfo.sniffisTrgPhyPortValid = descrPtr->eArchExtInfo.isTrgPhyPortValid;
                descrPtr->sniffTrgDev = descrPtr->trgDev;
                descrPtr->sniffTrgPort = descrPtr->eArchExtInfo.trgPhyPort;
                descrPtr->eArchExtInfo.toTargetSniffInfo.sniffTrgEPort = descrPtr->trgEPort;
                descrPtr->eArchExtInfo.toTargetSniffInfo.sniffEVidx = descrPtr->eVidx;
            }

            descrPtr->srcDev = descrPtr->srcTrgDev;
            break;
        default:
            skernelFatalError("snetChtDsaTag4WordsTagParsing: should not happen \n");
    }
}

/*******************************************************************************
*   snetChtIngressIsLoopedAndDropOnSource
*
* DESCRIPTION:
*        check the 'is looped' and 'drop on source' for packets that came with DSA tag.
*
* INPUTS:
*       deviceObj                - pointer to device object.
*       descrPtr                 - pointer to the frame's descriptor.
*
* OUTPUT:
*
*
********************************************************************************/
static GT_VOID snetChtIngressIsLoopedAndDropOnSource
(
    IN  SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngressIsLooped);

    GT_BIT  fastStackEn;
    SKERNEL_PORTS_BMP_STC   portsBmp;
    GT_BIT ingressPortIsLooped;
    GT_U32  *regPtr;
    GT_BIT  final_pktIsLooped = 0;
    GT_BIT  final_dropOnSource = 0;
    GT_BIT srcDevIsOwn = SKERNEL_IS_MATCH_DEVICES_MAC(descrPtr->srcDev, descrPtr->ownDev,
                                         devObjPtr->dualDeviceIdEnable.tti);

    if(0 == SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        /* the ch1,2 not supported those bits (pktIsLooped,dropOnSource) */
        return;
    }


    /*Enable for fast stack recovery.*/
    smemRegFldGet(devObjPtr, SMEM_CHT3_FAST_STACK_REG(devObjPtr) , 0, 1, &fastStackEn);

    __LOG_PARAM(fastStackEn);
    __LOG_PARAM(descrPtr->pktIsLooped);
    __LOG_PARAM(descrPtr->dropOnSource);
    __LOG_PARAM(srcDevIsOwn);


    if(fastStackEn == 0)
    {
        __LOG(("TTI global setting of 'fast stack recovery' is disabled : pktIsLooped,dropOnSource considered 0 \n"
               "(regardless on those bits in the ingress DSA tag) \n"));

        goto  final_pktIsLooped_lbl;
    }

    if(descrPtr->dropOnSource && srcDevIsOwn)
    {
        __LOG(("WARNING : packet returned to source device with drop on source , meaning it got here for the second time ! \n"
               "need to drop it \n"));

        if(devObjPtr->errata.fastStackFailover_Drop_on_source == 0)
        {
            /*assigned a HARD_DROP packet*/
            snetChtIngressCommandAndCpuCodeResolution(devObjPtr,descrPtr,
                                                      descrPtr->packetCmd,
                                                      SKERNEL_EXT_PKT_CMD_HARD_DROP_E,
                                                      descrPtr->cpuCode,
                                                      0,/* unknown drop code */
                                                      SNET_CHEETAH_ENGINE_UNIT_TTI_E,
                                                      GT_TRUE);/* not care */
        }
        else
        {
            __LOG(("WARNING : ERRATA : Fast Stack Failover - drop_on_source packets not dropped \n"));
        }
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* bit per ingress physical port , in per port table entry */
        ingressPortIsLooped =
            SMEM_LION3_TTI_PHYSICAL_PORT_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                SMEM_LION3_TTI_PHYSICAL_PORT_TABLE_FIELDS_PORT_IS_LOOPED);
    }
    else
    {
        /* bit per ingress physical port , in bmp of ports */
        regPtr = smemMemGet(devObjPtr, SMEM_CHT3_LOOP_PORT_REG(devObjPtr));
        /* fill the bmp of ports */
        SKERNEL_FILL_PORTS_BITMAP_MAC(devObjPtr, &portsBmp, regPtr);

        /* check if the port is set in the bmp */
        ingressPortIsLooped =
            SKERNEL_PORTS_BMP_IS_PORT_SET_MAC(&portsBmp,descrPtr->localDevSrcPort);
    }

    if(ingressPortIsLooped)
    {
        __LOG(("Ingress physical port [%d] set for 'Fast Failover on the ring port' (Port is looped) \n" ,
            descrPtr->localDevSrcPort));

        __LOG((" NOTE: that packets from this ingress port will be directed by the device to the 'backup ring physical port' (defined at txq/egf) \n"));
    }
    else
    {
        __LOG(("Ingress physical port [%d] in not set for 'Fast Failover on the ring port' (Port is NOT looped) \n",
            descrPtr->localDevSrcPort));
    }

    if(descrPtr->pktIsLooped)
    {
        if(ingressPortIsLooped)
        {
            __LOG(("ingress packet came with dsa stated as 'pktIsLooped = 1' , we need to 'terminate the loop' and consider it as 'overcome the stack fail' \n"));

            final_pktIsLooped = 0;
        }
        else
        {
            __LOG(("ingress packet came with dsa stated as 'pktIsLooped = 1' , from non looped port meaning it looking for target device to 'overcome the stack fail' \n"));

            final_pktIsLooped = 1;
        }
    }
    else  /*pktIsLooped = 0*/
    {
        if(ingressPortIsLooped)
        {
            __LOG(("ingress packet considered to start the road to 'overcome the stack fail' \n"));
            final_pktIsLooped = 1;
        }
        else
        {
            __LOG(("ingress packet came from port that not relevant to 'stack fail over' and with 'pktIsLooped = 0' \n"));
            final_pktIsLooped = 0;
        }
    }

final_pktIsLooped_lbl:

    __LOG_PARAM(final_pktIsLooped);

    if(fastStackEn && final_pktIsLooped && (descrPtr->dropOnSource == 0) && srcDevIsOwn)
    {
        final_dropOnSource = 1;
    }
    else
    {
        final_dropOnSource = descrPtr->dropOnSource;
    }

    __LOG_PARAM(final_dropOnSource);

    if(final_pktIsLooped != descrPtr->pktIsLooped)
    {
        __LOG(("logic of pktIsLooped changed value from [%d] to [%d] \n",
            descrPtr->pktIsLooped ,
            final_pktIsLooped));
    }
    else
    {
        __LOG(("logic of pktIsLooped keep value [%d] \n",
            final_pktIsLooped));
    }

    if(final_dropOnSource != descrPtr->dropOnSource)
    {
        __LOG(("logic of dropOnSource changed value from [%d] to [%d] \n",
            descrPtr->dropOnSource ,
            final_dropOnSource));
    }
    else
    {
        __LOG(("logic of dropOnSource keep value [%d] \n",
            final_dropOnSource));
    }

    descrPtr->pktIsLooped  = final_pktIsLooped;
    descrPtr->dropOnSource = final_dropOnSource;

    return;
}


/*******************************************************************************
*   snetChtMarvellTagParsing
*
* DESCRIPTION:
*        Parsing of Marvell tag
*
* INPUTS:
*       deviceObj                - pointer to device object.
*       descrPtr                 - pointer to the frame's descriptor.
*       internalTtiInfoPtr       - pointer to internal TTI info
*
* OUTPUT:
*
*   NOTE : this function do DSA "parsing" .
*          no setting fields that not relate to DSA parsing
*
********************************************************************************/
static GT_VOID snetChtMarvellTagParsing
(
    IN  SKERNEL_DEVICE_OBJECT           *devObjPtr,
    IN  SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr,
    IN  INTERNAL_TTI_DESC_INFO_STC      *internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtMarvellTagParsing);

    GT_U32 mtag[4] = {0,0,0,0}; /* 4 words DSA tag (in little endian format) */
    GT_U32 * mtagPtr;           /* pointer to marvell tag */
    GT_U32 * regPtr;            /* register pointer */
    GT_U32  index=0;/* dsa tag word index*/
    GT_U32  treatMirroredAsIngressMirrored;
    GT_U32  mtagQosProfile = 0;

    if(devObjPtr->supportEArch)
    {
        /* When enabled, all incoming TO_ANALYZER and TO_CPU DSA tagged packets are treated internally as ingress mirrored
           Internal note: when this field is enabled, the TTI assigns Desc<RxSniff>=1 in TO_ANALYZER, and Desc<SrcTrg>=Src in TO_CPU. */
        smemRegFldGet(devObjPtr, SMEM_XCAT_A1_TTI_UNIT_GLB_CONF_REG(devObjPtr),31,1,&treatMirroredAsIngressMirrored);

        /* for none eDSA tag info , set 'srcTrgPhysicalPort' as 'src' and of local device */
        descrPtr->srcTrgPhysicalPort = descrPtr->localDevSrcPort;
    }
    else
    {
        treatMirroredAsIngressMirrored = 0;
    }

    descrPtr->tag0Ptr =  &descrPtr->startFramePtr[12];

    descrPtr->marvellTaggedExtended = SKERNEL_EXT_DSA_TAG_1_WORDS_E;
    /* check DSA tag format : TO_CPU ? */
     if((descrPtr->startFramePtr[12] >> 6) == 0)
     {
        if((descrPtr->startFramePtr[13] & 7) == 7 &&
           (descrPtr->startFramePtr[14] & 0x10))
        {
            descrPtr->marvellTaggedExtended = SKERNEL_EXT_DSA_TAG_2_WORDS_E;
        }
     }
     else
     {
          if(descrPtr->startFramePtr[14] & 0x10)
          {
            descrPtr->marvellTaggedExtended = SKERNEL_EXT_DSA_TAG_2_WORDS_E;
          }
     }

    mtagPtr = (GT_U32 *)(&descrPtr->startFramePtr[12]);

    /* Set init values */
    memset(mtag, 0, sizeof(mtag));

    mtag[index++] = SGT_LIB_SWAP_BYTES_AND_WORDS_MAC(*mtagPtr);
    if (descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E)
    {
        mtagPtr++;
        mtag[index++] = SGT_LIB_SWAP_BYTES_AND_WORDS_MAC(*mtagPtr);

        if(SMEM_U32_GET_FIELD(mtag[1], 31, 1))
        {
            mtagPtr++;
            mtag[index++] = SGT_LIB_SWAP_BYTES_AND_WORDS_MAC(*mtagPtr);

            if(SMEM_U32_GET_FIELD(mtag[1], 31, 1))
            {
                mtagPtr++;
                mtag[index++] = SGT_LIB_SWAP_BYTES_AND_WORDS_MAC(*mtagPtr);

                descrPtr->marvellTaggedExtended = SKERNEL_EXT_DSA_TAG_4_WORDS_E;
            }
            else
            {
                descrPtr->marvellTaggedExtended = SKERNEL_EXT_DSA_TAG_3_WORDS_E;
                skernelFatalError("snetChtMarvellTagParsing: not supported 3 words DSA tag \n");
            }
        }
    }

    if(simLogIsOpen())
    {
        scibAccessLock();

        __LOG(("[%s]",
                    descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_1_WORDS_E ? "SKERNEL_EXT_DSA_TAG_1_WORDS_E" :
                    descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_2_WORDS_E ? "SKERNEL_EXT_DSA_TAG_2_WORDS_E" :
                    descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_3_WORDS_E ? "SKERNEL_EXT_DSA_TAG_3_WORDS_E" :
                    descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_4_WORDS_E ? "SKERNEL_EXT_DSA_TAG_4_WORDS_E" :
                    "unknown DSA length format ?!"
                      ));

        __LOG(("dump the bytes of the DSA : (network order)" ));
        /* dump the bytes of the DSA */
        simLogPacketDump(devObjPtr,GT_TRUE/*ingress*/,
            descrPtr->localDevSrcPort,
            &descrPtr->startFramePtr[12] ,
            index * 4);

        scibAccessUnlock();
    }

    /* TagCommand */
    /* save the DSA incoming command for later use */
    descrPtr->incomingMtagCmd = SMEM_U32_GET_FIELD(mtag[0], 30, 2);

    descrPtr->eVid       = SMEM_U32_GET_FIELD(mtag[0], 0, 12);
    descrPtr->up        = SMEM_U32_GET_FIELD(mtag[0], 13, 3);
    descrPtr->cfidei    = SMEM_U32_GET_FIELD(mtag[0], 16, 1);

    switch(descrPtr->incomingMtagCmd)
    {
        case SKERNEL_MTAG_CMD_FORWARD_E:
            __LOG(("[%s]","SKERNEL_MTAG_CMD_FORWARD_E"));
            descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_FORWARD_E;

            /* SrcTagged */
            descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] = SMEM_U32_GET_FIELD(mtag[0], 29, 1);

            descrPtr->srcDev =
                SMEM_U32_GET_FIELD(mtag[0], 24, 5);
            descrPtr->origIsTrunk =
                SMEM_U32_GET_FIELD(mtag[0], 18, 1);

            if(SKERNEL_IS_LION2_DEV(devObjPtr))
            {
                descrPtr->dsaCoreIdBit2 =
                    SMEM_U32_GET_FIELD(mtag[0], 17, 1);
            }

            descrPtr->origSrcEPortOrTrnk =
                SMEM_U32_GET_FIELD(mtag[0], 19, 5);

            if (descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E)
            {
                descrPtr->origSrcEPortOrTrnk |=
                    SMEM_U32_GET_FIELD(mtag[1], 29, (descrPtr->origIsTrunk ? 2 : 1)) << 5;
                descrPtr->egressFilterRegistered =
                    SMEM_U32_GET_FIELD(mtag[1], 28, 1);
                if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
                {
                    descrPtr->pktIsLooped =
                        SMEM_U32_GET_FIELD(mtag[1], 26, 1);
                    descrPtr->dropOnSource =
                        SMEM_U32_GET_FIELD(mtag[1], 27, 1);
                }
                descrPtr->routed =
                    SMEM_U32_GET_FIELD(mtag[1], 25, 1);
                descrPtr->sstId =
                    SMEM_U32_GET_FIELD(mtag[1], 20, 5);
                descrPtr->useVidx =
                    SMEM_U32_GET_FIELD(mtag[1], 12, 1);
                if (descrPtr->useVidx)
                {
                    descrPtr->eVidx =
                        SMEM_U32_GET_FIELD(mtag[1], 0, 12);
                }
                else
                {
                    descrPtr->trgEPort =
                        SMEM_U32_GET_FIELD(mtag[1], 5, 6);
                    descrPtr->trgDev =
                        SMEM_U32_GET_FIELD(mtag[1], 0, 5);
                }
                /* QoSProfile */
                mtagQosProfile = SMEM_U32_GET_FIELD(mtag[1], 13, 7);
            }
            else
            {
                /* non-extended DSA tag */
                /* the value of 'cpu port' (31) in non extended DSA tag systems
                   is converted to the 'cpu port' (63) of the extended DSA tag
                   system
                */
                if((!descrPtr->origIsTrunk) &&
                    descrPtr->origSrcEPortOrTrnk == (SNET_CHT_CPU_PORT_CNS & 0x1f))
                {
                    /* update the port to be 'cpu port num' ! */
                    descrPtr->origSrcEPortOrTrnk = SNET_CHT_CPU_PORT_CNS;
                }
            }

            descrPtr->eArchExtInfo.srcTrgEPort = descrPtr->origSrcEPortOrTrnk;
            break;
        case SKERNEL_MTAG_CMD_TO_CPU_E:
            __LOG(("[%s]","SKERNEL_MTAG_CMD_TO_CPU_E"));
            descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_FROM_CSCD_TO_CPU_E;

            if (descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_1_WORDS_E)
            {
                descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] =
                    SMEM_U32_GET_FIELD(mtag[0], 29, 1);

                descrPtr->srcTrgDev =
                    SMEM_U32_GET_FIELD(mtag[0], 24, 5);
                descrPtr->origSrcEPortOrTrnk =
                    SMEM_U32_GET_FIELD(mtag[0], 19, 5);
                descrPtr->cpuCode =
                    SMEM_U32_GET_FIELD(mtag[0], 12, 1) |
                    SMEM_U32_GET_FIELD(mtag[0], 16, 3) << 1;
            }
            else
            {
                descrPtr->srcTrg =
                    SMEM_U32_GET_FIELD(mtag[1], 8, 1);

                if(treatMirroredAsIngressMirrored == 1)
                {
                    if(descrPtr->srcTrg == 1)
                    {
                        __LOG(("descrPtr->srcTrg = 1 was changed to 0 because <treatMirroredAsIngressMirrored>"));
                    }
                    descrPtr->srcTrg = 0;
                }

                if (descrPtr->srcTrg == 1)
                {
                    descrPtr->trgTagged =
                        SMEM_U32_GET_FIELD(mtag[0], 29, 1);
                    descrPtr->trgDev =
                        SMEM_U32_GET_FIELD(mtag[0], 24, 5);
                    descrPtr->srcTrgDev = descrPtr->trgDev;
                    descrPtr->trgEPort =
                        SMEM_U32_GET_FIELD(mtag[0], 19, 5);
                    descrPtr->trgEPort |=
                        SMEM_U32_GET_FIELD(mtag[1], 10, 1) << 5;
                }
                else
                {
                    descrPtr->origIsTrunk =
                        SMEM_U32_GET_FIELD(mtag[1], 27, 1);
                    descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] =
                        SMEM_U32_GET_FIELD(mtag[0], 29, 1);
                    descrPtr->srcTrgDev =
                        SMEM_U32_GET_FIELD(mtag[0], 24, 5);
                    descrPtr->origSrcEPortOrTrnk =
                        SMEM_U32_GET_FIELD(mtag[0], 19, 5);
                    descrPtr->origSrcEPortOrTrnk |=
                        SMEM_U32_GET_FIELD(mtag[1], 10, 1) << 5;
                    if(descrPtr->origIsTrunk)
                    {
                        descrPtr->origSrcEPortOrTrnk |=
                            SMEM_U32_GET_FIELD(mtag[1], 11, 1) << 6;
                    }
                }

                descrPtr->inDsaPktOrigBC = SMEM_U32_GET_FIELD(mtag[1], 12, 14);
                descrPtr->cpuCode =
                    SMEM_U32_GET_FIELD(mtag[1], 0, 8);

                if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
                {
                    descrPtr->pktIsLooped =
                        SMEM_U32_GET_FIELD(mtag[1], 28, 1);
                    descrPtr->dropOnSource =
                        SMEM_U32_GET_FIELD(mtag[1], 29, 1);
                }
                descrPtr->cfidei =
                    SMEM_U32_GET_FIELD(mtag[1], 30, 1);

                /* DSA_Cmd == TO_CPU */
                descrPtr->sstId = 0;
                descrPtr->sstIdPrecedence = SKERNEL_PRECEDENCE_ORDER_HARD;
            }

            if(devObjPtr->supportEArch)
            {
                descrPtr->srcDev = descrPtr->srcTrgDev;
                /*descrPtr->srcDev = descrPtr->ownDev;*//*not from the DSA tag*/

                if (descrPtr->srcTrg == 1)
                {
                    descrPtr->eArchExtInfo.srcTrgEPort = descrPtr->trgEPort;
                }
                else
                {
                    descrPtr->eArchExtInfo.srcTrgEPort = descrPtr->origSrcEPortOrTrnk;
                }

                descrPtr->srcTrgPhysicalPort = descrPtr->eArchExtInfo.srcTrgEPort;

                /*TrgPort*/
                descrPtr->eArchExtInfo.trgPhyPort = (descrPtr->srcTrg == 1) /*target*/?
                                      descrPtr->eArchExtInfo.srcTrgEPort :
                                      SNET_CHT_NULL_PORT_CNS;

                descrPtr->trgEPort  = descrPtr->eArchExtInfo.trgPhyPort;/*Don't care (assign same logic as used for <TrgPort>)*/

                descrPtr->origSrcEPortOrTrnk = descrPtr->eArchExtInfo.localDevSrcEPort;/* not from the DSA tag */
            }
            else
            {
                descrPtr->srcDev = descrPtr->srcTrgDev;
            }

            break;
        case SKERNEL_MTAG_CMD_FROM_CPU_E:
            __LOG(("[%s]","SKERNEL_MTAG_CMD_FROM_CPU_E"));
            descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_FROM_CPU_E;

            descrPtr->trgTagged =
                SMEM_U32_GET_FIELD(mtag[0], 29, 1);
            descrPtr->useVidx =
                SMEM_U32_GET_FIELD(mtag[0], 18, 1);
            if (descrPtr->useVidx)
            {
                descrPtr->eVidx =
                    SMEM_U32_GET_FIELD(mtag[0], 19, 10);
            }
            else
            {
                descrPtr->trgDev =
                    SMEM_U32_GET_FIELD(mtag[0], 24, 5);
                descrPtr->trgEPort =
                    SMEM_U32_GET_FIELD(mtag[0], 19, 5);
            }

            descrPtr->qos.fromCpuQos.fromCpuTc = (GT_U8)
                SMEM_U32_GET_FIELD(mtag[0], 17, 1);
            if (descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E)
            {
                descrPtr->qos.fromCpuQos.fromCpuTc |=
                   (SMEM_U32_GET_FIELD(mtag[1], 14, 1) << 1 |
                    SMEM_U32_GET_FIELD(mtag[1], 27, 1) << 2);

                descrPtr->qos.fromCpuQos.contolTc =
                    SMEM_U32_GET_FIELD(mtag[1], 29, 1);
                /* DSA_Cmd == FROM_CPU */
                descrPtr->sstId =
                    SMEM_U32_GET_FIELD(mtag[1], 20, 5);
                descrPtr->egressFilterRegistered =
                    SMEM_U32_GET_FIELD(mtag[1], 28, 1);
                descrPtr->srcDev =
                    SMEM_U32_GET_FIELD(mtag[1], 15, 5);
                descrPtr->egressFilterEn =
                    SMEM_U32_GET_FIELD(mtag[1], 30, 1);

                /*save value for the EPCL !! */
                descrPtr->ingressDsa.fromCpu_egressFilterEn = descrPtr->egressFilterEn;

                if (descrPtr->useVidx)
                {
                    descrPtr->excludeIsTrunk =
                        SMEM_U32_GET_FIELD(mtag[1], 11, 1);
                    if(descrPtr->excludeIsTrunk)
                    {
                        descrPtr->excludedTrunk =
                            SMEM_U32_GET_FIELD(mtag[1], 0, 7);

                        descrPtr->mirrorToAllCpus =
                            SMEM_U32_GET_FIELD(mtag[1], 10, 1);
                    }
                    else
                    {
                        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
                        {
                            /* for non-eDSA the default is 'excludedIsPhyPort = 1' */
                            descrPtr->eArchExtInfo.fromCpu.excludedIsPhyPort = 1;
                        }

                        descrPtr->excludedDevice =
                            SMEM_U32_GET_FIELD(mtag[1], 0, 5);
                        descrPtr->excludedPort =
                            SMEM_U32_GET_FIELD(mtag[1], 5, 6);
                    }

                    descrPtr->eVidx |=
                        SMEM_U32_GET_FIELD(mtag[1], 12, 2) << 10;
                }
                else
                {
                    descrPtr->mailBoxToNeighborCPU =
                        SMEM_U32_GET_FIELD(mtag[1], 13, 1);
                    descrPtr->trgEPort |=
                        SMEM_U32_GET_FIELD(mtag[1], 10, 1) << 5;
                }

                if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
                {
                    descrPtr->pktIsLooped =
                        SMEM_U32_GET_FIELD(mtag[1], 25, 1);
                    descrPtr->dropOnSource =
                        SMEM_U32_GET_FIELD(mtag[1], 26, 1);

                    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
                    {
                        regPtr =
                            smemMemGet(devObjPtr, SMEM_CHT3_FAST_STACK_REG(devObjPtr));
                        descrPtr->qos.fromCpuQos.fromCpuDp =
                            (GT_U8) (SMEM_U32_GET_FIELD(regPtr[0], 1, 2));
                    }
                }
                else
                {
                    /* ch and ch2 --> dp in those bits */
                    descrPtr->qos.fromCpuQos.fromCpuDp = (GT_U8)
                       (SMEM_U32_GET_FIELD(mtag[1], 25, 2));
                }

#if 0  /* there is no such "802.11 Decryption" device */
                /*  for the section of : 7.1 Ingress 802.11 Decryption

                    The CPU returns the packet with the 802.11 payload unencrypted,
                    specifying in the DSA tag the packets original source port,
                    and a special destination port 60 indicating that this packet
                    was OSM redirected.
                    Note the packet is subject to normal ingress processing as
                    if it was received on the original ingress port.
                */
                if(descrPtr->eVidx == 0 &&
                   descrPtr->srcDev == descrPtr->ownDev &&
                   descrPtr->trgEPort == SNET_CHT_OSM_PORT_CNS)
                {
                    /* we need to continue to treat the frame as it was coming
                      from the port of: ??? */
                    descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_FORWARD_E;

                    /* set fields that relevant to "forward" info ,
                       that conflict with the "from CPU" , */
                    descrPtr->origIsTrunk = 0;
                    descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] = 1;
                    #define NOT_CLEAR_YET   0
                    descrPtr->origSrcEPortOrTrnk = NOT_CLEAR_YET;
                    descrPtr->localDevSrcPort = descrPtr->origSrcEPortOrTrnk;

                    /* set flag to ignore the QOS index from the DSA tag ,
                    so we will force QosIndex from the regular assignment */
                    /* because we don't know how to set mtagQosProfile */
                    descrPtr->ignoreQosIndexFromDsaTag = 1;
                }
#endif /* 0 */
            }
            break;
        default:    /*SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E*/
            __LOG(("[%s]","SKERNEL_MTAG_CMD_TO_TRG_SNIFFER_E"));
            descrPtr->packetCmd = SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E;

            descrPtr->rxSniff =
                SMEM_U32_GET_FIELD(mtag[0], 18, 1);

            if(treatMirroredAsIngressMirrored == 1)
            {
                if(descrPtr->rxSniff == 0)
                {
                    __LOG(("descrPtr->rxSniff = 0 was changed to 1 because <treatMirroredAsIngressMirrored>"));
                }
                descrPtr->rxSniff = 1;
            }

            if (descrPtr->rxSniff)
            {
                descrPtr->trgTagged = 0;
                descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] =
                    SMEM_U32_GET_FIELD(mtag[0], 29, 1);
            }
            else
            {
                descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] = 0;
                descrPtr->trgTagged =
                    SMEM_U32_GET_FIELD(mtag[0], 29, 1);
            }

            /* for ALL DSA tags */
            descrPtr->srcTrgDev =
                SMEM_U32_GET_FIELD(mtag[0], 24, 5);
            descrPtr->origSrcEPortOrTrnk =
                SMEM_U32_GET_FIELD(mtag[0], 19, 5);
            descrPtr->srcTrgPhysicalPort = descrPtr->origSrcEPortOrTrnk;

            if (descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E)
            {
                descrPtr->origSrcEPortOrTrnk |=
                        SMEM_U32_GET_FIELD(mtag[1], 10, 1) << 5;
                descrPtr->srcTrgPhysicalPort = descrPtr->origSrcEPortOrTrnk;

                if (descrPtr->rxSniff == 0)
                {
                    descrPtr->trgDev = descrPtr->srcTrgDev;
                    descrPtr->trgEPort = descrPtr->origSrcEPortOrTrnk;
                }

                if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
                {
                    descrPtr->pktIsLooped =
                        SMEM_U32_GET_FIELD(mtag[1], 28, 1);
                    descrPtr->dropOnSource =
                        SMEM_U32_GET_FIELD(mtag[1], 29, 1);
                }

                /* DSA_Cmd == TO_ANALYSER */
                descrPtr->sstId = 0;
                descrPtr->sstIdPrecedence = SKERNEL_PRECEDENCE_ORDER_HARD;
            }

            if(devObjPtr->supportEArch)
            {
                descrPtr->srcDev = descrPtr->srcTrgDev;
                /*descrPtr->srcDev = descrPtr->ownDev;*//*not from the DSA tag*/
                descrPtr->eArchExtInfo.srcTrgEPort = descrPtr->srcTrgPhysicalPort;
                descrPtr->origIsTrunk = 0;
                descrPtr->origSrcEPortOrTrnk = descrPtr->eArchExtInfo.localDevSrcEPort;/* not from the DSA tag */
                descrPtr->eArchExtInfo.trgPhyPort = 0;
                descrPtr->trgDev = 0;
                descrPtr->useVidx = 0;
                descrPtr->trgEPort = 0;

                descrPtr->eArchExtInfo.isTrgPhyPortValid = 0;
            }
            else
            {
                descrPtr->srcDev = descrPtr->srcTrgDev;
            }

            break;
    }

    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        /* the per port can FORCE it's sstId on DSA tagged packets */
        __LOG(("the per port can FORCE it's sstId on DSA tagged packets"));
        descrPtr->sstIdPrecedence = SKERNEL_PRECEDENCE_ORDER_SOFT;
    }

    switch(descrPtr->incomingMtagCmd)
    {
        case SKERNEL_MTAG_CMD_FORWARD_E:
        case SKERNEL_MTAG_CMD_FROM_CPU_E:
            descrPtr->eArchExtInfo.trgPhyPort = descrPtr->trgEPort;
            descrPtr->eArchExtInfo.isTrgPhyPortValid = 0;
            break;
        case SKERNEL_MTAG_CMD_TO_CPU_E:
            descrPtr->eArchExtInfo.trgPhyPort = descrPtr->trgEPort;
            break;
        default:
            break;
    }

    if(descrPtr->marvellTaggedExtended == SKERNEL_EXT_DSA_TAG_4_WORDS_E &&
       devObjPtr->supportEArch)
    {
        /* extra/update parse according to 4 words DSA tag format */
        __LOG(("extra/update parse according to 4 words DSA tag format"));
        SIM_LOG_PACKET_DESCR_SAVE
        snetChtDsaTag4WordsTagParsing(devObjPtr,descrPtr,mtag);

        /* fixing descrPtr->eArchExtInfo.trgPhyPort when isTrgPhyPortValid == 0 */

        if (descrPtr->eArchExtInfo.isTrgPhyPortValid == 0)
        {
            descrPtr->eArchExtInfo.trgPhyPort = SNET_CHT_NULL_PORT_CNS;
        }

        SIM_LOG_PACKET_DESCR_COMPARE("snetChtDsaTag4WordsTagParsing");

        /* force reduced number of bits from the eDSA (like actual device !!!) */
        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->origSrcEPortOrTrnk,ePort);
        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->trgEPort,ePort);
        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->eArchExtInfo.srcTrgEPort,ePort);
        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->eArchExtInfo.toTargetSniffInfo.sniffTrgEPort,ePort);

        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->eVid,eVid);

        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->eVidx,eVidx);
        REDUCE_NUM_BIT_FROM_EDSA_MAC(devObjPtr,descrPtr->eArchExtInfo.toTargetSniffInfo.sniffEVidx,eVidx);

    }
    else if(devObjPtr->supportEArch) /* non eDSA -- no valid trg physical port info (info is eport: descrPtr->trgEPort)*/
    {
        descrPtr->eArchExtInfo.isTrgPhyPortValid = 0;
        descrPtr->eArchExtInfo.trgPhyPort = SNET_CHT_NULL_PORT_CNS;
    }

    /* save DSA info */
    descrPtr->ingressDsa.origIsTrunk        = descrPtr->origIsTrunk;
    descrPtr->ingressDsa.origSrcEPortOrTrnk = descrPtr->origSrcEPortOrTrnk;
    descrPtr->ingressDsa.srcDev             = descrPtr->srcDev;
    descrPtr->ingressDsa.qosProfile         = mtagQosProfile;
    descrPtr->ingressDsa.srcId              = descrPtr->sstId;

    descrPtr->ingressDsa.dsaWords[0] = mtag[0];
    descrPtr->ingressDsa.dsaWords[1] = mtag[1];
    descrPtr->ingressDsa.dsaWords[2] = mtag[2];
    descrPtr->ingressDsa.dsaWords[3] = mtag[3];

}

/*******************************************************************************
*   snetChtVlanQosProfAssign
*
* DESCRIPTION:
*        VLAN and QoS/CoS assign
*
* INPUTS:
*       deviceObj       - pointer to device object.
*       descrPtr        - pointer to the frame's descriptor.
*       etherType       - packet ethernet type
*       l2encapsul      - layer 2 encapsulation
*       portVlanCfgEntryPtr
*                       - VLAN configuration table entry pointer
*
********************************************************************************/
static GT_VOID snetChtVlanQosProfAssign
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    GT_U32 etherType,
    IN SKERNEL_L2_ENCAPSULATION_TYPE_ENT l2encapsul,
    IN GT_U32 * portVlanCfgEntryPtr
)
{
    DECLARE_FUNC_NAME(snetChtVlanQosProfAssign);

    GT_U8 pvidAssign;               /* force PVID assign */
    GT_U32 pvidMode;                /* PVID assignment mode */
    GT_U32 pvidPrec;                /* PVID Precedence */
    GT_U32 protBaseQosEn;           /* ProtBased QoS Enabled */
    GT_U32 protBaseVlanEn;          /* ProtBased VLAN Enabled */
    GT_U32 regAddress;              /* register address */
    GT_U32 regValue;                /* register value */
    GT_U32  *ttiPreTtiLookupIngressEPortTablePtr = NULL;/* pointer to the entry in : tti - Pre-TTI Lookup Ingress ePort Table  */
    GT_BOOL bypassVlanAssignment;/* do we bypass vlan assignment ? support fix for CQ#129303 */

    /* tti - Pre-TTI Lookup Ingress ePort Table */
    ttiPreTtiLookupIngressEPortTablePtr = descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr;

    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        portVlanCfgEntryPtr = NULL;
    }

    if((descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E) ||
       (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FROM_CSCD_TO_CPU_E) ||
       (descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FROM_CPU_E))
    {
        /* non forward commands - no vlan re-assignment (with DSA to_cpu/to_analyzer/from_cpu) */
        __LOG(("non forward commands - no vlan re-assignment (with DSA to_cpu/to_analyzer/from_cpu)"));
        bypassVlanAssignment = GT_TRUE;
    }
    else  /* Packets received on DSA-tagged ports are subject to the
            VLAN assignment mechanisms only if the DSA tag command is FORWARD*/
    {
        if (descrPtr->eVid == 0 &&
                TAG0_EXIST_MAC(descrPtr)) /* tag 0 exists -- (DSA tags considered tag 0) */
        {
            descrPtr->srcPriorityTagged = 1;
        }

        bypassVlanAssignment = GT_FALSE;
    }

    if (bypassVlanAssignment == GT_FALSE)
    {
        /* Process VLAN assign */
        __LOG(("Process VLAN assign"));
        if (descrPtr->nestedVlanAccessPort == 0)
        {
            __LOG(("NOT nested vlan \n"));
            /* Regular port */
            if(ttiPreTtiLookupIngressEPortTablePtr)
            {
                pvidMode =
                    SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                        SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_EVLAN_MODE);
            }
            else
            {
                if(portVlanCfgEntryPtr == NULL)
                {
                    /* fix for coverity warning "FORWARD_NULL" */
                    skernelFatalError("snetChtVlanQosProfAssign: invalid table entry pointer\n");
                }

                pvidMode = SNET_CHT_PORT_VLAN_QOS_PVID_MODE_GET_MAC(devObjPtr,
                                                                portVlanCfgEntryPtr);
            }

            __LOG(("pvidMode [%d] \n",
                          pvidMode));

            if (pvidMode == 0)
            {
                /* Not Force PVID assign */

                /* if DSA state that remote device device got the packet ''
                    then we assign it pvid as if came untagged from local port */
                if(descrPtr->centralizedChassisModeEn &&
                   (0 == descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS]))
                {
                    __LOG(("centralizedChassisModeEn : packet received untagged on line card port - treat it as if it was received untagged locally \n"));
                    pvidAssign = 1;
                }
                else
                if ((0 == TAG0_EXIST_MAC(descrPtr)) || descrPtr->srcPriorityTagged)
                {
                    /* tag 0 not exists or priority tag0 - assign PVID */
                    if(0 == TAG0_EXIST_MAC(descrPtr))
                    {
                        __LOG(("tag 0 not exists - assign PVID \n"));
                    }
                    else
                    {
                        __LOG(("tag 0 is 'priority tagged' - assign PVID \n"));
                    }
                    pvidAssign = 1;
                }
                else
                {
                    /* Vid is already in descriptor therefore descrPtr->preserveVid = 0  */
                    __LOG(("No PVID assign \n"));
                    descrPtr->preserveVid = 0;
                    pvidAssign = 0;
                }
            }
            else
            {
                /* Force PVID assign */
                __LOG(("Force PVID assign to all packets \n"));
                pvidAssign = 1;
            }
        }
        else
        {
            __LOG(("Nested vlan (access port) \n"));
            /* Access Port */
            pvidAssign = 1;
        }

        if (pvidAssign)
        {
            if(ttiPreTtiLookupIngressEPortTablePtr)
            {
                descrPtr->eVid =
                    SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                        SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_EVLAN);
            }
            else
            {
                descrPtr->eVid = SNET_CHT_PORT_VLAN_QOS_PVID_GET_MAC(devObjPtr,
                                                                    portVlanCfgEntryPtr);
            }

            __LOG(("Assigned PVID (port's default vid) - value : [%d] \n",
                descrPtr->eVid));

            if (descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS])
            {
                descrPtr->vidModified = 1;
            }

            if(ttiPreTtiLookupIngressEPortTablePtr)
            {
                pvidPrec =
                    SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                        SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_P_VID_PRECEDENCE);
            }
            else
            {
                pvidPrec =
                    SNET_CHT_PORT_VLAN_QOS_PVID_PRECEDENCE_GET_MAC(devObjPtr,
                                                                   portVlanCfgEntryPtr);
            }

            if (pvidPrec == 1)
            {
                descrPtr->preserveVid = 1;
            }
        }

        if (SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
        {
            if (pvidAssign == 0)
            {
                if(ttiPreTtiLookupIngressEPortTablePtr)
                {
                    regValue =
                        SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                            SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_VLAN_TRANSLATION);
                }
                else
                {
                    regValue =
                        SNET_CHT_PORT_VLAN_QOS_VLAN_TRANSLATION_GET_MAC(devObjPtr,
                                                                        portVlanCfgEntryPtr);
                }

                /* The packet Vlan is translated to Internal Vlan */
                if (regValue)
                {
                    regAddress =
                        SMEM_CHT3_INGR_VLAN_TRANS_TBL_MEM(devObjPtr,
                            SMEM_U32_GET_FIELD(descrPtr->eVid,0,12));

                    smemRegFldGet(devObjPtr, regAddress, 0,
                        devObjPtr->flexFieldNumBitsSupport.eVid,
                        &regValue);

                    descrPtr->eVid = regValue;
                    descrPtr->vidModified = 1;
                    __LOG(("The packet Vlan is translated to Internal Vlan [0x%3.3x]",
                        descrPtr->eVid));
                }
            }
        }

        /* get two bits ProtBasedQoSEn and ProtBasedVLANEn */
        if(ttiPreTtiLookupIngressEPortTablePtr)
        {
            protBaseQosEn =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_QOS_EN);
            protBaseVlanEn =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_VLAN_EN);
        }
        else
        {
            protBaseQosEn  =
                SNET_CHT_PORT_VLAN_QOS_PROT_BASED_QOS_MAC(
                    devObjPtr, portVlanCfgEntryPtr);
            protBaseVlanEn =
                SNET_CHT_PORT_VLAN_QOS_PROT_BASED_VLAN_MAC(
                    devObjPtr, portVlanCfgEntryPtr);
        }

        if (protBaseVlanEn | protBaseQosEn)
        {
            /* Port Protocol VLANs */
            __LOG(("Port Protocol VLANs"));
            snetChtPortProtVlans(devObjPtr, descrPtr, etherType, l2encapsul,
                                 protBaseVlanEn);
        }
    }

    /* QoS/CoS assign Part 1 */
    __LOG(("QoS/CoS assign Part 1"));
    snetChtQoSAssignPart1(devObjPtr, descrPtr, portVlanCfgEntryPtr);

    /* QoS/CoS assign Part 2 */
    __LOG(("QoS/CoS assign Part 2"));
    snetChtQoSAssignPart2(
        devObjPtr, descrPtr, portVlanCfgEntryPtr,GT_TRUE);

}

/*******************************************************************************
*   snetChtPortProtVlans
*
* DESCRIPTION:
*        Port Protocol VLANs
*
* INPUTS:
*       deviceObj       - pointer to device object.
*       descrPtr        - pointer to the frame's descriptor.
*       etherType       - packet ethernet type
*       l2encapsul      - layer 2 encapsulation
*       portProtVlanEnabled - Protocol based VLANs enabled on port
*                             1 - enabled, 0 - disabled
* OUTPUTS:
*
********************************************************************************/
static GT_VOID snetChtPortProtVlans
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 etherType,
    IN SKERNEL_L2_ENCAPSULATION_TYPE_ENT l2encapsul,
    IN GT_U32     portProtVlanEnabled
)
{
    DECLARE_FUNC_NAME(snetChtPortProtVlans);

    GT_U32 protNum;                 /* Zero based protocol index */
    GT_U32 isProtValid;             /* Protocol enable */
    GT_U32 protEncapsBmp;           /* Protocols encapsulation bitmap */
    GT_U32 protValue;               /* Protocol value */
    GT_U32 setProtVid;              /* Set protocol VLAN id */
    GT_U32 regAddr;                 /* Register's address */
    GT_U32 * regPtr;                /* Register's entry pointer */
    SNET_VLAN_MODE_ENT vlanMode;    /* VLAN assignment mode */
    GT_U32 * protCfgRegsPtr;        /* Protocols Configuration Register pointer*/
    GT_U32 numOfProt;               /* Number of supported protocols */
    GT_U32 protInReg;               /* Number of protocol in register */

    /* get number of protocols */
    numOfProt = (SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr)) ? 12 : 8;

    /* Protocols Encapsulation Configuration 0 Register */
    regAddr = SMEM_CHT_PROT_ENCAP_CONF_REG(devObjPtr);
    regPtr = smemMemGet(devObjPtr, regAddr);

    /* Protocol Configuration Register */
    regAddr = SMEM_CHT_PROT_CONF_REG(devObjPtr);
    protCfgRegsPtr = smemMemGet(devObjPtr, regAddr);

    for (protNum = 0; protNum < numOfProt; protNum++)
    {
        /* jump to next Protocols Encapsulation Configuration Register
           for Xcat A1 and above */
        if (protNum == 8)
        {
            /* Protocols Encapsulation Configuration 1 Register  */
            regAddr = SMEM_XCAT_TTI_PROT_ENCAP_CONF1_REG(devObjPtr);
            regPtr = smemMemGet(devObjPtr, regAddr);
        }

        /* each registers has 8 protocols configuration */
        protInReg = protNum % 8;
        if(protNum >= 8)
        {
            isProtValid = (*regPtr >> (12 + protInReg)) & 0x1;
        }
        else
        {
            isProtValid = (*regPtr >> (24 + protInReg)) & 0x1;
        }

        protEncapsBmp = (*regPtr >> (protInReg * 3)) & 0x7;
        if (isProtValid &&
           (protEncapsBmp & l2encapsul))
        {
            protValue = (protCfgRegsPtr[protNum / 2] >> ((protNum % 2) * 16))
                         & 0xffff;

            if (protValue == etherType)
            {
                break;
            }
        }
    }

    if(protNum == numOfProt)
    {
        /* no match */
        return;
    }

    /* Port<n> Protocol<m> VID and QoS Configuration Entry  */
    __LOG(("the etherType[0x%4.4x] matched protocol index[%d]",etherType,protNum));
    regAddr =
        SMEM_CHT_PROT_VLAN_QOS_TBL_MEM(devObjPtr,
                                        protNum,
                                        descrPtr->localDevSrcPort);

    regPtr = smemMemGet(devObjPtr, regAddr);

    /* save the pointer to the entry , for the use of the QoS classification */
    descrPtr->perProtocolInfo.portProtMatchedMemoryPointer = regPtr;

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        isProtValid =
            SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                devObjPtr,descrPtr,
                SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_VALID);
    }
    else
    {
        isProtValid = SNET_CHT_PORT_PROT_IS_VALID_MAC(devObjPtr, *regPtr);
    }

    if (isProtValid)
    {
        descrPtr->perProtocolInfo.portProtMatch = GT_TRUE;
        setProtVid = GT_FALSE;
    }
    else
    {
        __LOG(("the matched protocol index[%d] is not valid",protNum));
        return;
    }

    /* check that Protocol Based VLAN assignment enabled on ingress port*/
    if(portProtVlanEnabled == 0)
    {
        __LOG(("Protocol Based VLAN assignment disabled on ingress port"));
        return;
    }

    if (descrPtr->preserveVid == 0)
    {
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            vlanMode  =
                SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                    devObjPtr,descrPtr,
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_EVLAN_COMMAND);
            descrPtr->preserveVid =
                SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                    devObjPtr,descrPtr,
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_EVLAN_PRECEDENCE);
        }
        else
        {
            vlanMode = SNET_CHT_PORT_PROT_VLAN_MODE_MAC(devObjPtr, *regPtr);
            descrPtr->preserveVid = SNET_CHT_PORT_PROT_VID_PRECEDENCE_MAC(devObjPtr, *regPtr);
        }


        if (vlanMode == SNET_UNTAGGED_ONLY_E)
        {
            if (descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] == 0)
            {
                setProtVid = GT_TRUE;
            }
        }
        else
        if (vlanMode == SNET_TAGGED_ONLY_E)
        {
            if (descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS])
            {
                setProtVid = GT_TRUE;
            }
        }
        else
        if (vlanMode == SNET_ALL_PACKETS_E)
        {
            setProtVid = GT_TRUE;
        }
    }

    if (setProtVid == GT_TRUE)
    {
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            descrPtr->eVid =
                SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                    devObjPtr,descrPtr,
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_EVLAN);
        }
        else
        {
            descrPtr->eVid = SMEM_U32_GET_FIELD(*regPtr, 0, 12);
        }

        if (descrPtr->tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] == 1)
        {
            descrPtr->vidModified = 1;
        }
    }
}

/*******************************************************************************
*   snetChtQoSAssignPart1
*
* DESCRIPTION:
*        QoS assign - part 1
*
* INPUTS:
*       deviceObj           - pointer to device object.
*       descrPtr            - pointer to the frame's descriptor.
*       portVlanCfgEntryPtr - port VLAN configuration entry
*
********************************************************************************/
static GT_VOID  snetChtQoSAssignPart1
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * portVlanCfgEntryPtr
)
{
    DECLARE_FUNC_NAME(snetChtQoSAssignPart1);

    GT_U32 trustDsaTagQos;                /* trust Dsa Tag Qos */
    GT_U32  *ttiPreTtiLookupIngressEPortTablePtr;/* pointer to the entry in : tti - Pre-TTI Lookup Ingress ePort Table  */

    /* tti - Pre-TTI Lookup Ingress ePort Table */
    ttiPreTtiLookupIngressEPortTablePtr = descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr;
    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        portVlanCfgEntryPtr = NULL;
    }

    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        /* default value */
        __LOG(("default value"));
        descrPtr->qos.qosProfile =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_QOS_PROFILE);
        /* Trust DSA tag QoS */
        trustDsaTagQos =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSA_TAG_QOS);

        /*UP2QoS-Profile Mapping Table Index*/
        descrPtr->up2QosProfileMappingMode =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_UP_CFI_TO_QOS_TABLE_SELECT_MODE);

        /*Trust QoS Mapping Table Index*/
        descrPtr->trustQosMappingTableIndex =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_QOS_MAPPING_TABLE_INDEX);
    }
    else
    {
        if(portVlanCfgEntryPtr == NULL)
        {
            /* fix for coverity warning "FORWARD_NULL" */
            skernelFatalError("snetChtQoSAssignPart1: invalid table entry pointer\n");
        }

        /* default value */
        descrPtr->qos.qosProfile =
            SNET_CHT_PORT_VLAN_QOS_QOS_PROFILE_MAC(
                devObjPtr, portVlanCfgEntryPtr);

        /* TrustMarvellTagQoS */
        trustDsaTagQos = SNET_CHT_PORT_VLAN_QOS_TRUST_DSA_QOS_MAC(
            devObjPtr, portVlanCfgEntryPtr);
    }

    if (descrPtr->ignoreQosIndexFromDsaTag == 0 &&
        descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E &&
        descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E && trustDsaTagQos)
    {
        descrPtr->qos.qosProfile = descrPtr->ingressDsa.qosProfile;
    }
    else
    if(descrPtr->marvellTagged/* cascade port*/ &&
       descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E &&
       descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E &&
       descrPtr->qos.ingressExtendedMode &&
       (trustDsaTagQos == 0))
    {
        /* we continue as usual but such config can cause non wanted behavior */
        __LOG(("suspected as configuration ERROR! PORT_QOS_MODE = 'extended' but TRUST_DSA_TAG_QOS = 0 \n"));
    }



    /* Enables the modification of the packet's DSCP field */
    __LOG(("Enables the modification of the packet's DSCP field"));
    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        descrPtr->modifyDscp =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_MODIFY_DSCP);
        descrPtr->modifyUp =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_MODIFY_UP);
        descrPtr->qosProfilePrecedence =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PORT_QOS_PRECEDENCE);
    }
    else
    {
        descrPtr->modifyDscp =
            SNET_CHT_PORT_VLAN_QOS_MODIFY_DSCP_MAC(
                devObjPtr, portVlanCfgEntryPtr);

        /* Enables the modification of the packet's 802.1p User Priority field */
        __LOG(("Enables the modification of the packet's 802.1p User Priority field"));
        descrPtr->modifyUp =
            SNET_CHT_PORT_VLAN_QOS_MODIFY_UP_MAC(
                devObjPtr, portVlanCfgEntryPtr);

        /* Port Marking of the QoS Precedence */
        descrPtr->qosProfilePrecedence =
            SNET_CHT_PORT_VLAN_QOS_QOS_PECEDENCE_MAC(
                devObjPtr, portVlanCfgEntryPtr);

    }
}

/*******************************************************************************
*   snetChtQoSAssignPart2
*
* DESCRIPTION:
*        QoS assign - part 2  -- get the 'descrPtr->trustTag1Qos' and act according to it
*
* INPUTS:
*       deviceObj           - pointer to device object.
*       descrPtr            - pointer to the frame's descriptor.
*       portVlanCfgEntryPtr - port VLAN configuration entry
*       usePortBasedQos     - use port or TTI based Qos index
*                           GT_TRUE : port
*                           GT_FALSE : TTI
*
********************************************************************************/
static GT_VOID  snetChtQoSAssignPart2
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 * portVlanCfgEntryPtr,
    IN GT_BIT   usePortBasedQos
)
{
    DECLARE_FUNC_NAME(snetChtQoSAssignPart2);

    GT_U32 trustDsaTag;             /* trust DSA tag */
    GT_U32 trustExp;                /* trust MPLS Exp */
    GT_U32 takeProtQos;             /* Do protocol QoS */
    GT_U32 regAddr = 0;                 /* Register's address */
    GT_U32 fldFirstBit;             /* Register field's first bit */
    GT_U32 remapValid = 1;          /* do we do remap of parameter */
    GT_U32 upProfileIndex;          /* up profile index */
    GT_U32 fieldVal;                /* Register's field value */
    GT_U32 mappingParam=0;          /* QoS mapping parameter : DSCP/EXP/UP/UP1 ...*/
    GT_U32  *ttiPreTtiLookupIngressEPortTablePtr = NULL;/* pointer to the entry in : tti - Pre-TTI Lookup Ingress ePort Table  */
    GT_BIT mpls,isIp,tagSrcTagged[2],marvellTagged;/* flags from the descriptor*/
    GT_U32 exp1,dscp,vlanEtherType1,up1,cfidei1,up,cfidei;/* fields from the descriptor*/
    GT_U32  *memPtr;/*pointer to memory*/
    GT_U32  trustQosMappingTableIndex;/* QoS mapping table index */
    GT_U32  qosPrifileNumBits;/* number of bits that the qos profile uses in next tables */

    usePortBasedQos = usePortBasedQos;/* not used parameter */

    /* get the 'frame parser fields' form the descriptor/'TRILL info' :
       for TRILL :
        based on the inner Ethernet packet*/
    SKERNEL_CHT_DESC_INNER_FRAME_FIELD_GET_MAC(descrPtr,mpls);
    SKERNEL_CHT_DESC_INNER_FRAME_FIELD_GET_MAC(descrPtr,isIp);
    SKERNEL_CHT_DESC_INNER_FRAME_FIELD_GET_MAC(descrPtr,tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS]);
    SKERNEL_CHT_DESC_INNER_FRAME_FIELD_GET_MAC(descrPtr,marvellTagged);
    SKERNEL_CHT_DESC_INNER_FRAME_FIELD_GET_MAC(descrPtr,vlanEtherType1);

    /* get the 'Qos fields' form the descriptor/'TRILL info' :
       for TRILL :
       QoS Trust Mode
       - Trust L2 and/or L3 QoS is based on the inner Ethernet packet*/
    SKERNEL_CHT_DESC_INNER_FRAME_QOS_FIELD_GET_MAC(descrPtr,dscp);
    SKERNEL_CHT_DESC_INNER_FRAME_QOS_FIELD_GET_MAC(descrPtr,exp1);
    SKERNEL_CHT_DESC_INNER_FRAME_QOS_FIELD_GET_MAC(descrPtr,up1);
    SKERNEL_CHT_DESC_INNER_FRAME_QOS_FIELD_GET_MAC(descrPtr,cfidei1);
    SKERNEL_CHT_DESC_INNER_FRAME_QOS_FIELD_GET_MAC(descrPtr,up);
    SKERNEL_CHT_DESC_INNER_FRAME_QOS_FIELD_GET_MAC(descrPtr,cfidei);

    /* tti - Pre-TTI Lookup Ingress ePort Table */
    ttiPreTtiLookupIngressEPortTablePtr = descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr;
    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        qosPrifileNumBits = 10;

        trustExp =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_EXP);
        /* Trust DSA tag QoS */
        trustDsaTag =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSA_TAG_QOS);

        descrPtr->trustTag1Qos =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_L2_QOS_TAG0_OR_TAG1);
    }
    else
    {
        qosPrifileNumBits = 7;

        if(portVlanCfgEntryPtr == NULL)
        {
            /* fix for coverity warning "FORWARD_NULL" */
            skernelFatalError("snetChtQoSAssignPart2: invalid table entry pointer\n");
        }

        trustExp = SNET_CHT_PORT_VLAN_QOS_TRUST_PKT_MPLS_EXP_MAC(
            devObjPtr, portVlanCfgEntryPtr);

        /* TrustMarvellTagQoS */
        trustDsaTag = SNET_CHT_PORT_VLAN_QOS_TRUST_DSA_QOS_MAC(
            devObjPtr, portVlanCfgEntryPtr);

        if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
        {
            descrPtr->trustTag1Qos =
                        SNET_CHT_PORT_VLAN_QOS_TRUST_VLAN_TAG1_QOS_MAC(
                            devObjPtr, portVlanCfgEntryPtr);
        }
    }

    /*Trust L2 QoS Tag0 or Tag1*/
    __LOG(("trustExp[%d] , trustDsaTag[%d] , descrPtr->trustTag1Qos[%d]",trustExp,trustDsaTag,descrPtr->trustTag1Qos));

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        trustQosMappingTableIndex = descrPtr->trustQosMappingTableIndex;
        __LOG(("trustQosMappingTableIndex[%d]",trustQosMappingTableIndex));
    }
    else
    {
        trustQosMappingTableIndex = 0;
    }

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr) && trustQosMappingTableIndex > 11)
    {
        /* only 12 profiles in the device */
        skernelFatalError("snetChtQoSAssignPart2: invalid trustQosMappingTableIndex [%d] > 11 \n",
            trustQosMappingTableIndex);
    }

    if (descrPtr->ignoreQosIndexFromDsaTag == 0 &&
        descrPtr->marvellTaggedExtended != SKERNEL_EXT_DSA_TAG_1_WORDS_E&&
        descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FORWARD_E && trustDsaTag)
    {
        /* nothing more */
    }
    else
    {
        if (mpls && trustExp)
        {
            __LOG(("selected mode: mpls && trustExp , exp1[%d]",exp1));

            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                memPtr = smemMemGet(devObjPtr,SMEM_CHT_EXP_2_QOS_PROF_MAP_TBL_MEM(devObjPtr,0,trustQosMappingTableIndex));

                descrPtr->qos.qosProfile = snetFieldValueGet(memPtr,qosPrifileNumBits * exp1,qosPrifileNumBits);
                goto qosProfilDone_lbl;
            }
            /* MPLS Exp trust mode - XCAT A1 and above */
            regAddr = SMEM_CHT_EXP_2_QOS_PROF_MAP_TBL_MEM(devObjPtr, exp1,0);
            mappingParam = exp1;
        }
        else
        {
            /* not MPLS L2 and L3 trust modes */
            if(ttiPreTtiLookupIngressEPortTablePtr)
            {
                GT_U32  _dscp =
                    SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                        SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_DSCP);
                GT_U32  _up =
                    SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                        SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TRUST_UP);

                /* QoSTrustMode */
                fieldVal = (_dscp << 1) | /*DSCP*/
                            _up;          /*UP*/
            }
            else
            {
                /* QoSTrustMode */
                fieldVal = SNET_CHT_PORT_VLAN_QOS_TRUST_PKT_QOS_MODE_MAC(
                    devObjPtr, portVlanCfgEntryPtr);
            }

            if ((fieldVal & SNET_TRUST_L3_E) && /* trust L3 */
                 isIp)
            {
                __LOG(("selected mode: L3 trust"));

                /* ReMapDSCP */
                if(ttiPreTtiLookupIngressEPortTablePtr)
                {
                    fieldVal =
                        SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                            SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_MAP_DSCP_TO_DSCP);
                }
                else
                {
                    fieldVal = SNET_CHT_PORT_VLAN_QOS_MAP_DSCP_TO_DSCP_MAC(
                        devObjPtr, portVlanCfgEntryPtr);
                }

                __LOG(("ReMapDSCP[%d]",fieldVal));

                if (fieldVal)
                {
                    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
                    {
                        memPtr = smemMemGet(devObjPtr,SMEM_CHT_DSCP_2_DSCP_MAP_TBL_MEM(devObjPtr,0,trustQosMappingTableIndex));
                        fieldVal = snetFieldValueGet(memPtr,6 * dscp,6);
                    }
                    else
                    {
                        regAddr = SMEM_CHT_DSCP_2_DSCP_MAP_TBL_MEM(devObjPtr, dscp,0);
                        fldFirstBit = (dscp % 4) * 8;
                        smemRegFldGet(devObjPtr, regAddr, fldFirstBit, 6, &fieldVal);
                    }

                    __LOG(("old dscp[%d] , new dscp after remap [%d]",dscp,fieldVal));

                    /* DSCP2DSCP */
                    dscp = fieldVal;
                }
                else
                {
                    dscp = dscp;
                }

                if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
                {
                    memPtr = smemMemGet(devObjPtr,SMEM_CHT_DSCP_2_QOS_PROF_MAP_REG(devObjPtr,0,trustQosMappingTableIndex));

                    descrPtr->qos.qosProfile = snetFieldValueGet(memPtr,qosPrifileNumBits * dscp,qosPrifileNumBits);
                    goto qosProfilDone_lbl;
                }

                regAddr = SMEM_CHT_DSCP_2_QOS_PROF_MAP_REG(devObjPtr, dscp,0);

                mappingParam = dscp;
            }
            else
            if ((fieldVal & SNET_TRUST_L2_E) && /* trust L2 */
                (tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS] || marvellTagged))
            {
                if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
                {
                    if (descrPtr->trustTag1Qos && vlanEtherType1)
                    {
                        __LOG(("selected mode: L2 trust , use up1[%d] cfi1[%d]",up1,cfidei1));

                        up = up1;
                        cfidei = cfidei1;
                    }
                    else
                    {
                        __LOG(("selected mode: L2 trust , use up[%d] cfi[%d]",up,cfidei));
                        up = up;
                        cfidei = cfidei;
                    }
                }
                else
                {
                    __LOG(("selected mode: L2 trust , use up[%d] (cfi not used)",up));
                    up = up;
                    cfidei = 0;
                }

                if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
                {

                    if(descrPtr->up2QosProfileMappingMode)
                    {
                        trustQosMappingTableIndex = descrPtr->trustTag1Qos ? up1 : up;
                        __LOG(("trustQosMappingTableIndex[%d] from [%s]",trustQosMappingTableIndex,descrPtr->trustTag1Qos ? "up1" : "up0"));
                    }

                    memPtr = smemMemGet(devObjPtr,SMEM_CHT_UP_2_QOS_PROF_MAP_TBL_MEM(devObjPtr,0,0,trustQosMappingTableIndex));

                    descrPtr->qos.qosProfile = snetFieldValueGet(memPtr,qosPrifileNumBits * ((cfidei*8) + up),qosPrifileNumBits);
                    goto qosProfilDone_lbl;
                }

                if(SKERNEL_IS_LION_REVISON_B0_DEV(devObjPtr))
                {
                    regAddr = SMEM_LION_TTI_CFI_UP_TO_QOS_PROFILE_MAPPING_TABLE_SELECTOR_REG(devObjPtr,
                        descrPtr->localDevSrcPort);
                    fldFirstBit = up + (descrPtr->localDevSrcPort % 4) * 8;
                    smemRegFldGet(devObjPtr, regAddr, fldFirstBit, 1, &upProfileIndex);

                    __LOG(("upProfileIndex[%d]\n",upProfileIndex));
                }
                else
                {
                    /* the device not support the upProfileIndex parameter */
                    __LOG(("the device not support the upProfileIndex parameter"));
                    upProfileIndex = 0;
                }

                regAddr = SMEM_CHT_UP_2_QOS_PROF_MAP_TBL_MEM(devObjPtr,up,cfidei,upProfileIndex);

                mappingParam = up;
            }
            else
            {
                __LOG(("selected mode: not trust COS info from the packet"));

                remapValid = 0;
            }
        }

        if(remapValid == 1)
        {
            /* 4 QoS profiles in register */
            fldFirstBit = (mappingParam % 4) * 8;
            smemRegFldGet(devObjPtr, regAddr, fldFirstBit, 7,  &fieldVal);
            descrPtr->qos.qosProfile = fieldVal;
        }
    }

qosProfilDone_lbl:
    __LOG(("new descrPtr->qos.qosProfile[%d]",descrPtr->qos.qosProfile));

    /* when we do 'port based' we need to also do 'port protocol' */

    if(ttiPreTtiLookupIngressEPortTablePtr)
    {
        fieldVal =
            SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_PROT_BASED_QOS_EN);
    }
    else
    {
        fieldVal =
            SNET_CHT_PORT_VLAN_QOS_PROT_BASED_QOS_MAC(
                devObjPtr, portVlanCfgEntryPtr);
    }
    /* Protocol based QoS enable */
    __LOG(("Protocol based QoS enabled [%d] \n",fieldVal));

    if (descrPtr->qosProfilePrecedence == SKERNEL_QOS_PROF_PRECED_SOFT &&
        descrPtr->perProtocolInfo.portProtMatch == GT_TRUE &&
        fieldVal && descrPtr->packetCmd <= SKERNEL_EXT_PKT_CMD_SOFT_DROP_E &&
        descrPtr->perProtocolInfo.portProtMatchedMemoryPointer)
    {
        takeProtQos = GT_FALSE;
        if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
        {
            /* Protocol Modify QoS Profile */
            fieldVal =
                SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                    devObjPtr,descrPtr,
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_QOS_PROFILE);
        }
        else
        {
            /* Protocol QoSProfile Mode */
            fieldVal =
                SNET_CHT_PORT_PROT_VLAN_QOS_QOS_PROFILE_MODE_MAC(
                    devObjPtr, *descrPtr->perProtocolInfo.portProtMatchedMemoryPointer);
        }

        __LOG(("Protocol Modify QoS Profile Mode [%s]",
                        (fieldVal == SNET_NOT_CHANGE_E) ? "SNET_NOT_CHANGE_E" :
                        (fieldVal == SNET_UNTAGGED_ONLY_E) ? "SNET_UNTAGGED_ONLY_E" :
                        (fieldVal == SNET_TAGGED_ONLY_E) ? "SNET_TAGGED_ONLY_E" :
                        "SNET_ALL_PACKETS_E"
                      ));

        if (tagSrcTagged[SNET_CHT_TAG_0_INDEX_CNS])
        {
            if (fieldVal == SNET_TAGGED_ONLY_E ||
                fieldVal == SNET_ALL_PACKETS_E)
            {
                takeProtQos = GT_TRUE;
            }
        }
        else
        {
            if (fieldVal == SNET_UNTAGGED_ONLY_E ||
                fieldVal == SNET_ALL_PACKETS_E)
            {
                takeProtQos = GT_TRUE;
            }
        }

        if (takeProtQos == GT_TRUE)
        {
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                descrPtr->qos.qosProfile =
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                        devObjPtr,descrPtr,
                        SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_QOS_PROFILE);
                descrPtr->modifyDscp =
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                        devObjPtr,descrPtr,
                        SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_DSCP);
                descrPtr->modifyUp =
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                        devObjPtr,descrPtr,
                        SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_MODIFY_UP);
                descrPtr->qosProfilePrecedence =
                    SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_ENTRY_FIELD_GET(
                        devObjPtr,descrPtr,
                        SMEM_LION3_TTI_DEFAULT_PORT_PROTOCOL_EVLAN_AND_QOS_CONFIGURATION_TABLE_FIELDS_PROTOCOL_QOS_PRECEDENCE);
            }
            else
            {
                descrPtr->qos.qosProfile =
                    SNET_CHT_PORT_PROT_VLAN_QOS_QOS_PROFILE_MAC(
                        devObjPtr, *descrPtr->perProtocolInfo.portProtMatchedMemoryPointer);
                descrPtr->modifyDscp =
                    SNET_CHT_PORT_PROT_VLAN_QOS_MODIFY_DSCP_MAC(
                        devObjPtr, *descrPtr->perProtocolInfo.portProtMatchedMemoryPointer);
                descrPtr->modifyUp =
                    SNET_CHT_PORT_PROT_VLAN_QOS_MODIFY_UP_MAC(
                        devObjPtr, *descrPtr->perProtocolInfo.portProtMatchedMemoryPointer);
                descrPtr->qosProfilePrecedence =
                    SNET_CHT_PORT_PROT_VLAN_QOS_QOS_PECEDENCE_MAC(
                        devObjPtr, *descrPtr->perProtocolInfo.portProtMatchedMemoryPointer);
            }

            __LOG(("port protocol modify qos parameters: "
                          "descrPtr->qos.qosProfile[%d] "
                          "descrPtr->modifyDscp[%d] "
                          "descrPtr->modifyUp[%d] "
                          "descrPtr->qosProfilePrecedence[%d] \n"
                          ,descrPtr->qos.qosProfile
                          ,descrPtr->modifyDscp
                          ,descrPtr->modifyUp
                          ,descrPtr->qosProfilePrecedence));
        }
        else
        {
            __LOG(("port protocol not applicable for the traffic type \n"));
        }
    }
}

/*******************************************************************************
*   snetChtTrunkHash
*
* DESCRIPTION:
*        Hash Index Generation Procedure
*
* INPUTS:
*       deviceObj           - pointer to device object.
*       descrPtr            - pointer to the frame's descriptor.
*
********************************************************************************/
static GT_VOID snetChtTrunkHash
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtTrunkHash);

    GT_U32 * regPtr;                /* Pointer to register's entry */
    GT_U32 fieldVal;                /* Register's field value */
    GT_U32 hashVal = 0;             /* hashing trunk value */
    GT_U32 srcTcpPort;              /* source TCP/UDP port */
    GT_U32 dstTcpPort;              /* destination TCP/UDP port */

    regPtr = smemMemGet(devObjPtr, SMEM_CHT_PCL_GLOBAL_REG(devObjPtr));

    fieldVal = SMEM_U32_GET_FIELD(*regPtr, 9, 1);
    /* TrunkLBH Mode */
    if (fieldVal == 0)
    {
        /* Hash is based on the packets data */
        __LOG(("Hash is based on the packets data"));
        if (descrPtr->isIp && (descrPtr->ipHeaderError == 0))
        {
            fieldVal = SMEM_U32_GET_FIELD(*regPtr, 3, 1);
            /* EnIPHash */
            __LOG(("EnIPHash"));
            if (fieldVal)
            {
                /* IPV6 packet */
                __LOG(("IPV6 packet"));
                if (descrPtr->isIPv4 == 0)
                {
                    fieldVal = SMEM_U32_GET_FIELD(*regPtr, 10, 2);
                    if (fieldVal == SNET_IPV6_TRUNK_HASH0_E)
                    {
                        hashVal = (descrPtr->sip[3] & 0x3f) ^
                                  ((descrPtr->sip[3] >> 16) & 0x3f) ^
                                  (descrPtr->dip[3] & 0x3f) ^
                                  ((descrPtr->dip[3] >> 16) & 0x3f) ^
                                  (descrPtr->flowLabel & 0x1f);
                    }
                    else
                    if (fieldVal == SNET_IPV6_TRUNK_HASH1_E)
                    {
                        hashVal = (descrPtr->sip[1] & 0x3f) ^
                                  ((descrPtr->sip[1] >> 24) & 0x3f) ^
                                  (descrPtr->dip[1] & 0x3f) ^
                                  ((descrPtr->dip[1] >> 24) & 0x3f) ^
                                  ((descrPtr->flowLabel >> 8) & 0x3f);
                    }
                    else
                    if (fieldVal == SNET_IPV6_TRUNK_HASH2_E)
                    {
                        hashVal = (descrPtr->sip[3] & 0x3f) ^
                                  ((descrPtr->sip[3] >> 16) & 0x3f) ^
                                  (descrPtr->dip[3] & 0x3f) ^
                                  ((descrPtr->dip[3] >> 16) & 0x3f) ^
                                  (descrPtr->flowLabel & 0x1f) ^
                                  (descrPtr->sip[1] & 0x3f) ^
                                  ((descrPtr->sip[0] >> 24) & 0x3f) ^
                                  (descrPtr->dip[1] & 0x3f) ^
                                  ((descrPtr->dip[1] >> 24) & 0x3f) ^
                                  ((descrPtr->flowLabel >> 8) & 0x3f);
                    }
                    else
                    if (fieldVal == SNET_IPV6_TRUNK_HASH3_E)
                    {
                        hashVal = (descrPtr->sip[3] & 0x3f) ^
                                  ((descrPtr->sip[3] >> 16) & 0x3f) ^
                                  (descrPtr->dip[3] & 0x3f) ^
                                  ((descrPtr->dip[3] >> 16) & 0x3f);
                    }
                }
                else
                {
                        hashVal = (descrPtr->sip[0] & 0x3f) ^
                                  ((descrPtr->sip[0] >> 16) & 0x3f) ^
                                  (descrPtr->dip[0] & 0x3f) ^
                                  ((descrPtr->dip[0] >> 16) & 0x3f);
                }

                /* EnL4Hash */
                __LOG(("EnL4Hash"));
                fieldVal = SMEM_U32_GET_FIELD(*regPtr, 4, 1);
                if (fieldVal &&
                   (descrPtr->udpCompatible ||
                    descrPtr->ipProt == SNET_TCP_PROT_E) &&
                    descrPtr->l4StartOffsetPtr)
                {
                    srcTcpPort = descrPtr->l4SrcPort;

                    dstTcpPort = descrPtr->l4DstPort;

                    hashVal = hashVal ^
                        (srcTcpPort & 0x3f) ^ (dstTcpPort & 0x3f);

                    /* L4LongTrunk LBH */
                    __LOG(("L4LongTrunk LBH"));
                    fieldVal = SMEM_U32_GET_FIELD(*regPtr, 14, 1);
                    if (fieldVal)
                    {
                        hashVal = hashVal ^
                            ((srcTcpPort >> 8) & 0x3f) ^
                            ((dstTcpPort >> 8) & 0x3f);
                    }
                }
                /* AddMACHash */
                fieldVal = SMEM_U32_GET_FIELD(*regPtr, 2, 1);
                if (fieldVal)
                {
                    hashVal = hashVal ^
                        (descrPtr->macSaPtr[5] & 0x3f) ^
                        (descrPtr->macDaPtr[5] & 0x3f);
                }
            }
            else
            {
                hashVal = hashVal ^
                    (descrPtr->macSaPtr[5] & 0x3f) ^
                    (descrPtr->macDaPtr[5] & 0x3f);
            }
        }
        else
        {
            hashVal = (descrPtr->macSaPtr[5] & 0x3f) ^
                      (descrPtr->macDaPtr[5] & 0x3f);
        }
    }
    else
    {
        /* Hash is based on the packet's Source Port# or Source Trunk# */
        __LOG(("Hash is based on the packet's Source Port# or Source Trunk#"));
        hashVal = descrPtr->origSrcEPortOrTrnk & 0x3f;
    }

    descrPtr->pktHash = hashVal;
}

/*******************************************************************************
*   snetXCatA1TrunkHash
*
* DESCRIPTION:
*        Hash Index Generation Procedure
*
* INPUTS:
*       deviceObj           - pointer to device object.
*       descrPtr            - pointer to the frame's descriptor.
*
********************************************************************************/
static GT_VOID snetXCatA1TrunkHash
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetXCatA1TrunkHash);

    GT_U32 *regPtr;                 /* Pointer to register's entry */
    GT_U32 hashVal;                 /* hashing trunk value         */
    /* 6-bit values to use in HASH function      */
    GT_U32 hFlowLabel;     /* Hash part of IPV6 header flow label   */
    GT_U32 hSrcTcpPort;    /* Hash part of source TCP/UDP port      */
    GT_U32 hDstTcpPort;    /* Hash part of destination TCP/UDP port */
    GT_U32 hDstMac;        /* Hash part of destination MAC address  */
    GT_U32 hSrcMac;        /* Hash part of source MAC address       */
    GT_U8* hSip;            /* pointer to source IP address         */
    GT_U8* hDip;            /* pointer to destination IP address    */
    GT_U32 hMplsLabel0;    /* Hash part of MPLS label0              */
    GT_U32 hMplsLabel1;    /* Hash part of MPLS label0              */
    GT_U32 hMplsLabel2;    /* Hash part of MPLS label0              */
    /* HASH configuration fields */
    GT_U32 l4LongHash;              /* L4 long Hash             */
    GT_U32 ipv6HashMode;            /* IPV6 Hash mode           */
    GT_U32 trunkLbhMode;            /* trunk Lbh  mode          */
    GT_U32 addL4Hash;               /* add L4 Hash              */
    GT_U32 addIpHash;               /* add IP Hash              */
    GT_U32 addMplsHash;             /* add MPLS Hash            */
    GT_U32 addMacHash;              /* add MAC Hash             */
    GT_U32 ipv6SipMask;             /* ipv6 Sip Mask            */
    GT_U32 ipv6DipMask;             /* ipv6 Dip Mask            */
    GT_U32 ipv4DipShift;            /* ipv4 Dip Shift           */
    GT_U32 ipv4SipShift;            /* ipv4 Sip Shift           */
    GT_U32 ipv6DipShift;            /* ipv6 Dip Shift           */
    GT_U32 ipv6SipShift;            /* ipv6 Sip Shift           */
    GT_U32 macSaMask;               /* MAC SA Mask              */
    GT_U32 macDaMask;               /* MAC DA Mask              */
    GT_U32 ipv6FlowMask;            /* ipv6 Flow Mask           */
    GT_U32 ipv4SipMask;             /* ipv4 Sip Mask            */
    GT_U32 ipv4DipMask;             /* ipv4 Dip Mask            */
    GT_U32 mplsLab0Mask;            /* MPLS Label0 Mask         */
    GT_U32 mplsLab1Mask;            /* MPLS Label1 Mask         */
    GT_U32 mplsLab2Mask;            /* MPLS Label2 Mask         */
    GT_U32 l4SrcPortMask;           /* L4 Source port Mask      */
    GT_U32 l4DstPortMask;           /* L4 Destination port Mask */

    /* retrieve HASH control parameters */
    regPtr = smemMemGet(devObjPtr, SMEM_XCAT_TRUNK_HASH_CONF_REGISTER0(devObjPtr));
    l4LongHash    = SMEM_U32_GET_FIELD(regPtr[0], 0, 1);
    ipv6HashMode  = SMEM_U32_GET_FIELD(regPtr[0], 1, 2);
    trunkLbhMode  = SMEM_U32_GET_FIELD(regPtr[0], 3, 1);
    addL4Hash     = SMEM_U32_GET_FIELD(regPtr[0], 4, 1);
    addIpHash     = SMEM_U32_GET_FIELD(regPtr[0], 5, 1);
    addMplsHash   = SMEM_U32_GET_FIELD(regPtr[0], 6, 1);
    addMacHash    = SMEM_U32_GET_FIELD(regPtr[0], 7, 1);
    ipv6SipMask   = SMEM_U32_GET_FIELD(regPtr[0], 8, 6);
    ipv6DipMask   = SMEM_U32_GET_FIELD(regPtr[0], 14, 6);
    ipv4DipShift  = SMEM_U32_GET_FIELD(regPtr[0], 20, 2);
    ipv4SipShift  = SMEM_U32_GET_FIELD(regPtr[0], 22, 2);
    ipv6DipShift  = SMEM_U32_GET_FIELD(regPtr[0], 24, 4);
    ipv6SipShift  = SMEM_U32_GET_FIELD(regPtr[0], 28, 4);
    macSaMask     = SMEM_U32_GET_FIELD(regPtr[1], 0, 6);
    macDaMask     = SMEM_U32_GET_FIELD(regPtr[1], 6, 6);
    ipv4SipMask   = SMEM_U32_GET_FIELD(regPtr[1], 12, 6);
    ipv4DipMask   = SMEM_U32_GET_FIELD(regPtr[1], 18, 6);
    ipv6FlowMask  = SMEM_U32_GET_FIELD(regPtr[1], 24, 6);
    mplsLab0Mask  = SMEM_U32_GET_FIELD(regPtr[2], 0, 6);
    mplsLab1Mask  = SMEM_U32_GET_FIELD(regPtr[2], 6, 6);
    mplsLab2Mask  = SMEM_U32_GET_FIELD(regPtr[2], 12, 6);
    l4SrcPortMask = SMEM_U32_GET_FIELD(regPtr[2], 18, 6);
    l4DstPortMask = SMEM_U32_GET_FIELD(regPtr[2], 24, 6);

    if(simLogIsOpen())
    {
        __LOG_PARAM(l4LongHash   );
        __LOG_PARAM(ipv6HashMode );
        __LOG_PARAM(trunkLbhMode );
        __LOG_PARAM(addL4Hash    );
        __LOG_PARAM(addIpHash    );
        __LOG_PARAM(addMplsHash  );
        __LOG_PARAM(addMacHash   );
        __LOG_PARAM(ipv6SipMask  );
        __LOG_PARAM(ipv6DipMask  );
        __LOG_PARAM(ipv4DipShift );
        __LOG_PARAM(ipv4SipShift );
        __LOG_PARAM(ipv6DipShift );
        __LOG_PARAM(ipv6SipShift );
        __LOG_PARAM(macSaMask    );
        __LOG_PARAM(macDaMask    );
        __LOG_PARAM(ipv4SipMask  );
        __LOG_PARAM(ipv4DipMask  );
        __LOG_PARAM(ipv6FlowMask );
        __LOG_PARAM(mplsLab0Mask );
        __LOG_PARAM(mplsLab1Mask );
        __LOG_PARAM(mplsLab2Mask );
        __LOG_PARAM(l4SrcPortMask);
        __LOG_PARAM(l4DstPortMask);
    }


    /* TrunkLBH Mode */
    if (trunkLbhMode == 0)
    {
        /* Hash is based on the packets data */
        __LOG(("Hash is based on the packets data \n"));

        hDstMac = descrPtr->macDaPtr[5] & macDaMask;
        hSrcMac = descrPtr->macSaPtr[5] & macSaMask;

        __LOG_PARAM(hDstMac);
        __LOG_PARAM(hSrcMac);

        if(descrPtr->isIp && addIpHash && descrPtr->ipHeaderError)
        {
            __LOG(("WARNING : the IP hash parameters are not used for hash when 'ip header error' !!!"));
        }

        if ((descrPtr->isIp == 0) && descrPtr->mpls && addMplsHash)
        {
            /* MPLS hash function */
            __LOG(("hashing for MPLS packet \n"));
            hMplsLabel0 = descrPtr->label1 & mplsLab0Mask;
            hMplsLabel1 = descrPtr->label2 & mplsLab1Mask;
            hMplsLabel2 = descrPtr->label3 & mplsLab2Mask;

            __LOG_PARAM(hMplsLabel0);
            __LOG_PARAM(hMplsLabel1);
            __LOG_PARAM(hMplsLabel2);

            hashVal = hMplsLabel0 ^ hMplsLabel1 ^ hMplsLabel2;

            __LOG_PARAM(hashVal);

            /* AddMACHash */
            if (addMacHash)
            {
                __LOG(("Add MAC Hash \n"));
                hashVal = hashVal ^ hSrcMac ^ hDstMac;
                __LOG_PARAM(hashVal);
            }
        }
        else if (descrPtr->isIp && addIpHash && (descrPtr->ipHeaderError == 0))
        {
            /* IP hash function */
            if (descrPtr->isIPv4 == 0)
            {
                /* IPV6 packet */
                __LOG(("hashing for IPV6 packet \n"));
                hSip = &descrPtr->l3StartOffsetPtr[8];
                hDip = &descrPtr->l3StartOffsetPtr[8+16];

                switch (ipv6HashMode)
                {
                    default:
                    case SNET_IPV6_TRUNK_HASH0_E:
                        __LOG(("ipv6HashMode = SNET_IPV6_TRUNK_HASH0_E \n"));
                        __LOG(("SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] ^ flow[5:0] \n"));
                        /* SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] ^ flow[5:0] */
                        hFlowLabel = descrPtr->flowLabel & ipv6FlowMask;

                        hashVal = (hSip[IPV6_SHIFT_INDEX_MAC(15,ipv6SipShift)] & ipv6SipMask) ^
                                  (hSip[IPV6_SHIFT_INDEX_MAC(13,ipv6SipShift)] & ipv6SipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(15,ipv6DipShift)] & ipv6DipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(13,ipv6DipShift)] & ipv6DipMask) ^
                                  hFlowLabel;
                        break;
                    case SNET_IPV6_TRUNK_HASH1_E:
                        __LOG(("ipv6HashMode = SNET_IPV6_TRUNK_HASH1_E \n"));
                        __LOG(("SIP[69:64] ^ SIP[125:120] ^ DIP[69:64] ^ DIP[125:120 ^ flow[13:8] \n"));
                        /* SIP[69:64] ^ SIP[125:120] ^ DIP[69:64] ^ DIP[125:120 ^ flow[13:8] */
                        hFlowLabel = (descrPtr->flowLabel >> 8) & ipv6FlowMask;
                        hashVal = (hSip[IPV6_SHIFT_INDEX_MAC(7,ipv6SipShift)] & ipv6SipMask) ^
                                  (hSip[IPV6_SHIFT_INDEX_MAC(0,ipv6SipShift)] & ipv6SipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(7,ipv6DipShift)] & ipv6DipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(0,ipv6DipShift)] & ipv6DipMask) ^
                                  hFlowLabel;
                        break;
                    case SNET_IPV6_TRUNK_HASH2_E:
                        __LOG(("ipv6HashMode = SNET_IPV6_TRUNK_HASH2_E \n"));
                        __LOG(("SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] ^ flow[5:0] \n"));
                        __LOG(("SIP[69:64] ^ SIP[125:120] ^ DIP[69:64] ^ DIP[125:120 ^ flow[13:8] \n"));
                        /* hashVal_for_case_0 ^ hashVal_for_case_1 */
                        /* SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] ^ flow[5:0] */
                        /* SIP[69:64] ^ SIP[125:120] ^ DIP[69:64] ^ DIP[125:120 ^ flow[13:8] */

                        /* hashVal_for_case_0 */
                        hFlowLabel = descrPtr->flowLabel & ipv6FlowMask;

                        hashVal = (hSip[IPV6_SHIFT_INDEX_MAC(15,ipv6SipShift)] & ipv6SipMask) ^
                                  (hSip[IPV6_SHIFT_INDEX_MAC(13,ipv6SipShift)] & ipv6SipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(15,ipv6DipShift)] & ipv6DipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(13,ipv6DipShift)] & ipv6DipMask) ^
                                  hFlowLabel;

                        /* ^ hashVal_for_case_1 */
                        hFlowLabel = (descrPtr->flowLabel >> 8) & ipv6FlowMask;
                        hashVal = (hSip[IPV6_SHIFT_INDEX_MAC(7,ipv6SipShift)] & ipv6SipMask) ^
                                  (hSip[IPV6_SHIFT_INDEX_MAC(0,ipv6SipShift)] & ipv6SipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(7,ipv6DipShift)] & ipv6DipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(0,ipv6DipShift)] & ipv6DipMask) ^
                                  hFlowLabel ^
                                  hashVal;
                        break;
                    case SNET_IPV6_TRUNK_HASH3_E:
                        __LOG(("ipv6HashMode = SNET_IPV6_TRUNK_HASH3_E \n"));
                        __LOG(("SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] \n"));
                        /* SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] */
                        hashVal = (hSip[IPV6_SHIFT_INDEX_MAC(15,ipv6SipShift)] & ipv6SipMask) ^
                                  (hSip[IPV6_SHIFT_INDEX_MAC(13,ipv6SipShift)] & ipv6SipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(15,ipv6DipShift)] & ipv6DipMask) ^
                                  (hDip[IPV6_SHIFT_INDEX_MAC(13,ipv6DipShift)] & ipv6DipMask) ;
                        break;
                }
            }
            else
            {
                /* IPV4 packet */
                __LOG(("hashing for IPV4 packet \n"));
                hSip = &descrPtr->l3StartOffsetPtr[12];
                hDip = &descrPtr->l3StartOffsetPtr[12+4];

                /* SIP[5:0] ^ SIP[21:16] ^ DIP[5:0] ^ DIP[21:16] */
                hashVal = (hSip[IPV4_SHIFT_INDEX_MAC(3,ipv4SipShift)] & ipv4SipMask) ^
                          (hSip[IPV4_SHIFT_INDEX_MAC(1,ipv4SipShift)] & ipv4SipMask) ^
                          (hDip[IPV4_SHIFT_INDEX_MAC(3,ipv4DipShift)] & ipv4DipMask) ^
                          (hDip[IPV4_SHIFT_INDEX_MAC(1,ipv4DipShift)] & ipv4DipMask) ;
            }

            __LOG_PARAM(hashVal);

            /* addL4Hash */
            if (addL4Hash &&
               (descrPtr->udpCompatible ||
                descrPtr->ipProt == SNET_TCP_PROT_E) &&
                descrPtr->l4StartOffsetPtr)
            {
                __LOG(("ADD L4 info into the hash \n"));

                hSrcTcpPort = descrPtr->l4SrcPort & l4SrcPortMask;
                hDstTcpPort = descrPtr->l4DstPort & l4DstPortMask;
                __LOG_PARAM(hSrcTcpPort);
                __LOG_PARAM(hDstTcpPort);

                hashVal = hashVal ^ hSrcTcpPort ^ hDstTcpPort;
                __LOG_PARAM(hashVal);

                if (l4LongHash)
                {
                    __LOG(("ADD L4 LONG info into the hash \n"));

                    /* L4LongTrunk LBH */
                    hSrcTcpPort = (descrPtr->l4SrcPort >> 8) & l4SrcPortMask;
                    hDstTcpPort = (descrPtr->l4DstPort >> 8) & l4DstPortMask;
                    __LOG_PARAM(hSrcTcpPort);
                    __LOG_PARAM(hDstTcpPort);

                    hashVal = hashVal ^ hSrcTcpPort ^ hDstTcpPort;
                    __LOG_PARAM(hashVal);
                }

            }
            /* AddMACHash */
            if (addMacHash)
            {
                __LOG(("Add MAC Hash \n"));
                hashVal = hashVal ^ hSrcMac ^ hDstMac;
            }
        }
        else
        {
            /* not IP and not MPLS hash function */
            __LOG(("not IP and not MPLS hash function"));
            hashVal = hSrcMac ^ hDstMac;
        }
    }
    else
    {
        /* Hash is based on the packet's Source Port# or Source Trunk# */
        __LOG(("Hash is based on the packet's Source Port# or Source Trunk# [0x%x]",
            descrPtr->origSrcEPortOrTrnk));
        hashVal = descrPtr->origSrcEPortOrTrnk & 0x3f;
    }

    __LOG(("(NOTE: 6 bits hash) Final packet Hash value [0x%x] \n" ,
        hashVal));

    descrPtr->pktHash = hashVal;
}

/*******************************************************************************
*   snetChtLinkStateNotify
*
* DESCRIPTION:
*       Notify devices database that link state changed
*
* INPUTS:
*       devObjPtr   - pointer to device object.
*       port        - port number.
*       linkState   - link state (0 - down, 1 - up)
*
*******************************************************************************/
static GT_VOID snetChtLinkStateNotify
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 port,
    IN GT_U32 linkState
)
{
    GT_U32 regAddress;          /* Register address */
    GT_U32 fldValue;            /* Register's field value */
    GT_U32 *regPtr;             /* Register's data pointer */
    GT_U32 regData;             /* Register's data */
    GT_U32 portInGlobBmp;       /* Port's sum interrupt bmp in the global register */
    GT_U32 fldPortBit;          /* Port sum interrupt bit */
    GT_U32 doInterrupt = 1;     /* Trigger global interrupt */
    GT_U32 oldLinkState;        /* Link status before the change*/
    GT_U32 portIntCauseReg;     /* Port interrupt cause register*/
    GT_U32 portIntMaskReg;      /* Port interrupt mask register*/
    GT_U32 outputPortBit;       /* the bit index for the egress port */
    GT_BOOL isSecondRegister;   /* is the per port config is in second register -- for bmp of ports */
    GT_U32 autoNeg, newSpeed;
    GT_U32  forceLinkDown , forceLinkPass;
    GT_U32  macPort;            /* MAC port number */

    if(!IS_CHT_VALID_PORT(devObjPtr,port))
    {
        /* port not exists */
        return;
    }

    if(devObjPtr->numOfPipes)
    {
        GT_U32  dummyPort;
        /* Update 'currentPipeId' and get new (local) port */
        smemConvertGlobalPortToCurrentPipeId(devObjPtr,port,&dummyPort);
    }

    macPort = snetChtRxMacPortGet(devObjPtr,port);

    if(IS_CHT_HYPER_GIGA_PORT(devObjPtr, port))
    {
        regAddress = SMEM_CHT_MAC_CONTROL0_REG(devObjPtr, macPort);
        regPtr = smemMemGet(devObjPtr, regAddress);
        forceLinkDown = SMEM_U32_GET_FIELD(regPtr[0], 2, 1);
        forceLinkPass = SMEM_U32_GET_FIELD(regPtr[0], 3, 1);
    }
    else
    {
        regAddress = SMEM_CHT_PORT_AUTO_NEG_REG(devObjPtr, macPort);
        regPtr = smemMemGet(devObjPtr, regAddress);
        forceLinkDown = SMEM_U32_GET_FIELD(regPtr[0], 0, 1);
        forceLinkPass = SMEM_U32_GET_FIELD(regPtr[0], 1, 1);
    }

    if(forceLinkDown == 1)
    {
        /* ignore the 'request' and force the link down */
        linkState = 0;
    }
    else if(forceLinkPass == 1)
    {
        /* ignore the 'request' and force the link up */
        linkState = 1;
    }

    /* Port Status Registers */
    regAddress = SMEM_CHT_PORT_STATUS0_REG(devObjPtr, macPort);
    regPtr = smemMemGet(devObjPtr, regAddress);

    oldLinkState = SMEM_U32_GET_FIELD(regPtr[0], 0, 1);

    if(linkState == oldLinkState)
    {
        /* no need to change status */
        return;
    }

    SMEM_U32_SET_FIELD(regPtr[0], 0, 1, linkState);

    if(SKERNEL_DEVICE_FAMILY_LION_PORT_GROUP_DEV(devObjPtr))
    {
        if(devObjPtr->txqRevision == 0)
        {
            fldPortBit = (IS_CHT_CPU_PORT(port)) ? 28 : port;

            /* set also register that all ports links show */
            smemRegFldSet(devObjPtr,SMEM_LION_LINKS_STATUS_REG_MAC(devObjPtr), fldPortBit, 1, linkState);
        }
        else
        {
            if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
            {
                regAddress = SMEM_LION_TXQ_PORTS_LINK_ENABLE_STATUS_REG(devObjPtr,macPort);
                outputPortBit = macPort & 0x1f;
                /* set also register that all ports links show */
                smemRegFldSet(devObjPtr, regAddress, outputPortBit, 1, linkState);
            }
            else
            {
                regAddress = SMEM_LION_TXQ_PORTS_LINK_ENABLE_STATUS_REG(devObjPtr,0/*not used*/);
                snetChtHaPerPortInfoGet(devObjPtr, port, &isSecondRegister, &outputPortBit);
                if(isSecondRegister == GT_TRUE)
                {
                    regAddress += 4;
                }

                /* set also register that all ports links show */
                smemRegFldSet(devObjPtr, regAddress, outputPortBit, 1, linkState);
            }
        }
    }

    /* Global Interrupt Cause register SUM bmp */
    portInGlobBmp = SMEM_CHT_PORT_CAUSE_INT_SUM_BMP(devObjPtr,macPort);

    if(devObjPtr->myInterruptsDbPtr)
    {
        /* the device has support for the tree of the port interrupts.
        from the port's mac (giga/XLG) to MG unit (global summary) */
        snetChetahDoInterrupt(devObjPtr,
                              SMEM_CHT_PORT_INT_CAUSE_REG(devObjPtr,macPort),
                              SMEM_CHT_PORT_INT_CAUSE_MASK_REG(devObjPtr,macPort),
                              (1 << 1),/* in Giga and in XLG bit 1 is the 'LINK STATUS CHANGED' */
                              portInGlobBmp);

        /* check for EEE interrupt support */
        snetBobcat2EeeCheckInterrupts(devObjPtr,macPort);

        return;
    }

    portIntCauseReg = SMEM_CHT_PORT_INT_CAUSE_REG(devObjPtr, macPort);
    smemRegGet(devObjPtr, portIntCauseReg, &regData);

    /* Link status changed on port (interrupt cause register) */
    SMEM_U32_SET_FIELD(regData, 1, 1, 1);
    /* Sum of all GOP interrupts */
    SMEM_U32_SET_FIELD(regData, 0, 1, 1);

    smemRegSet(devObjPtr, portIntCauseReg, regData);

    portIntMaskReg = SMEM_CHT_PORT_INT_CAUSE_MASK_REG(devObjPtr, macPort);
    smemRegFldGet(devObjPtr, portIntMaskReg, 1, 1, &fldValue);
    /* Link status changed on port bit (interrupt mask register) */
    if (fldValue != 1)
    {
        /* do not trigger global interrupt but still fill the cause
           registers in the tree to allow the interrupts be ready when the
           mask register value will be changed ...
        */
        doInterrupt = 0;
    }

    if(IS_CHT_CPU_PORT(port))
    {
        /* generate interrupt */
        snetChetahDoInterruptLimited(devObjPtr,
                              portIntCauseReg,
                              portIntMaskReg,
                              (1 << 1),
                              portInGlobBmp,
                              doInterrupt);/* let the function know if to set interrupt or not */
    }
    else if(IS_CHT_REGULAR_PORT(devObjPtr,port) &&
            (!SKERNEL_IS_LION2_DEV(devObjPtr)))/* Gig port in Lion2 similar to XLG(XG) port*/
    {
        smemRegFldGet(devObjPtr,
                      SMEM_CHT_PORT_AUTO_NEG_REG(devObjPtr, macPort), 7, 1, &autoNeg);
        if(autoNeg)
        {
            /* Link state UP */
            if(linkState)
            {
                if(devObjPtr->portsArr[port].state == SKERNEL_PORT_STATE_GE_E)
                {
                    /* Port speed 1000 Mbps */
                    newSpeed = 1;
                }
                else
                {
                    /* Port speed 100 Mbps */
                    newSpeed = 2;
                }
            }
            else
            {
                /* Default speed 10 Mbps */
                newSpeed = 0;
            }

            SMEM_U32_SET_FIELD(regPtr[0], 1, 2, newSpeed);
        }

        /* GE Ports */
        if(!SKERNEL_IS_CHEETAH1_ONLY_DEV(devObjPtr))
        {
            /* set summary bit in the
               Tri-Speed Ports Interrupt Summary Register 0x05004010 */
            regAddress = SMEM_CHT_TRI_SPEED_PORTS_INTERRUPT_SUMMARY_REG(devObjPtr);
            smemRegGet(devObjPtr, regAddress, &regData);

            /* set per port bit */
            SMEM_U32_SET_FIELD(regData, (macPort + 1), 1, 1);

            /* set Summary of all port interrupts */
            SMEM_U32_SET_FIELD(regData, 0, 1, 1);

            smemRegSet(devObjPtr, regAddress, regData);

            /* check interrupts mask
              Tri-Speed Ports Interrupt Summary Mask Register
              Offset: 0x04805114 */
            regAddress = SMEM_CHT_TRI_SPEED_PORTS_INTERRUPT_SUMMARY_MASK_REG(devObjPtr);
            smemRegFldGet(devObjPtr, regAddress, (macPort + 1), 1, &fldValue);
            if (fldValue != 1)
            {
                /* do not trigger global interrupt but still fill the cause
                   registers in the tree to allow the interrupts be ready when the
                   mask register value will be changed ...
                */
                doInterrupt = 0;
            }

            fldPortBit = 5;
        }
        else
        {
            /* The summary bit of port port<0-23> */
            fldPortBit = SMEM_CHT_PORT_MIB_CNT_PORT_BIT(macPort);

        }

        /* generate interrupt */
        snetChetahDoInterruptLimited(devObjPtr,
                              SMEM_CHT_PORTS_MIB_CNT_INT_SUM_REG(devObjPtr),
                              SMEM_CHT_PORTS_MIB_CNT_INT_SUM_MASK_REG(devObjPtr),
                              (1 << fldPortBit),
                              portInGlobBmp,
                              doInterrupt);/* let the function know if to set interrupt or not */
    }
    else
    {
        /* XG Ports ,
            and also 'stacking ports' in GE mode :
            SKERNEL_PORT_STATE_GE_STACK_A0_E,
            SKERNEL_PORT_STATE_GE_STACK_A1_E
        */
        /*
            in Lion2 also support Gig port mode
        */

        if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
        {
            /* set summary bit in the
               XG Ports Interrupt Cause register 0x00000080 */
            regAddress = SMEM_CHT3_XG_PORTS_INTERRUPT_CAUSE_REG(devObjPtr);
            smemRegGet(devObjPtr, regAddress, &regData);

            fldPortBit = macPort == 0 ? 31 : macPort;
            /* set per port bit */
            SMEM_U32_SET_FIELD(regData, fldPortBit, 1, 1);

            /* set Summary of all port interrupts */
            SMEM_U32_SET_FIELD(regData, 0, 1, 1);

            smemRegSet(devObjPtr, regAddress, regData);

            /* check interrupts mask
              XG Ports Interrupt mask register
              Offset: 0x00000084 */
            regAddress = SMEM_CHT3_XG_PORTS_INTERRUPT_MASK_REG(devObjPtr);

            fldPortBit &= 0x1f;/* patch for bobcat2 with port > 32 */

            smemRegFldGet(devObjPtr, regAddress, fldPortBit, 1, &fldValue);
            if (fldValue != 1)
            {
                /* do not trigger global interrupt but still fill the cause
                   registers in the tree to allow the interrupts be ready when the
                   mask register value will be changed ...
                */
                doInterrupt = 0;
            }
        }

        if(SKERNEL_IS_LION2_DEV(devObjPtr) &&
           devObjPtr->portGroupSharedDevObjPtr == 0 &&
           (IS_CHT_HYPER_GIGA_PORT(devObjPtr,port) == 0))
        {
            /* patch for Bobcat2 and not for Lion3 , as not supporting GOP of Lion3 yet */
            /* those are ports without XLG mac , so can't trigger interrupt in the XLG mac */
        }
        else
        if( SKERNEL_IS_LION2_DEV(devObjPtr) || /* Lion2 support all modes (GE/XLG/HGL...)*/
            (((SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr) ||
               SKERNEL_DEVICE_FAMILY_LION_PORT_GROUP_DEV(devObjPtr))) &&
             IS_CHT_HYPER_GIGA_PORT(devObjPtr,port))/* not 'Stacking GE' mode */
            )
        {
            /* the xcat/lion device has another hierarchy of cause registers before
               the XG/GE port */
            /* set summary bit in the
               XG Ports Summary Interrupt Cause register 0x08800058 + port*0x400 */
            /* in Lion2 this register is summary for GE,XLG,HGL..*/
            regAddress = SMEM_LION_XG_PORTS_SUMMARY_INTERRUPT_CAUSE_REG(devObjPtr,macPort);
            smemRegGet(devObjPtr, regAddress, &regData);

            if(IS_CHT_HYPER_GIGA_PORT(devObjPtr,port))
            {
                /* set bit 1 <XG Mac Cause Summary> */
                fldPortBit = 1;
            }
            else/* flor Lion 2 - support GE port */
            {
                /* set bit 2 <Giga port Cause Summary> */
                fldPortBit = 2;
            }

            SMEM_U32_SET_FIELD(regData, fldPortBit, 1, 1);

            /* set Summary of the port XG/GE interrupt */
            SMEM_U32_SET_FIELD(regData, 0, 1, 1);

            smemRegSet(devObjPtr, regAddress, regData);

            if(SKERNEL_IS_LION2_DEV(devObjPtr))
            {

                /* check interrupts mask
                   set summary bit in the
                   XG Ports Summary Interrupt Mask register 0x088C0058 + port*0x1000 */
                regAddress = SMEM_LION2_XG_PORTS_SUMMARY_INTERRUPT_MASK_REG(devObjPtr,macPort);
                smemRegFldGet(devObjPtr, regAddress, fldPortBit, 1, &fldValue);
                if (fldValue != 1)
                {
                    /* do not trigger global interrupt but still fill the cause
                       registers in the tree to allow the interrupts be ready when the
                       mask register value will be changed ...
                    */
                    doInterrupt = 0;
                }
            }
            else
            {
                /**********************************************************/
                /* There is no 'mask register'  for this cause register ! */
                /* So the logic always as those bits are unmasked         */
                /**********************************************************/
            }
        }

        /* generate interrupt */
        snetChetahDoInterruptLimited(devObjPtr,
                              portIntCauseReg,
                              portIntMaskReg,
                              (1 << 1),
                              portInGlobBmp,
                              doInterrupt);/* let the function know if to set interrupt or not */

    }
}

/*******************************************************************************
*   snetChtFromCpuDmaProcess
*
* DESCRIPTION:
*       Process transmitted SDMA queue frames in the Cheetah
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       bufferId        - pointer to received buffer
*
* OUTPUT:
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetChtFromCpuDmaProcess
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SBUF_BUF_ID bufferId
)
{
    GT_U32 startSdmaBmp;                        /* tx queue SDMA bitmap */
    GT_U32 txQue;                               /* index of queue */
    GT_U32 txSdmaCmdReg;                        /* Register entry value */
    SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr; /* frame descriptor pointer */
    GT_U32 i;                                   /* tx queue index */
    GT_U32 bypassOwnerEn;                       /* bypass owner bit is enabled */
    GT_BOOL isLastPacket;                       /* is last packet in chain */
    GT_U32 * txSdmaPktGenCfgRegPtr;             /* Pointer to register entry value */

    /*state from cpu command ()*/
    simLogPacketFrameCommandSet(SIM_LOG_FRAME_COMMAND_TYPE_FROM_CPU_E);

    descrPtr = snetChtEqDuplicateDescr(devObjPtr, NULL);
    /* save the ingress device*/
    descrPtr->ingressDevObjPtr = devObjPtr;

    bypassOwnerEn = 0;

    descrPtr->frameBuf = bufferId;

    /* Get tx SMDA queue bitmap */
    startSdmaBmp = bufferId->userInfo.data.txSdmaQueueBmp;

    /* Transmit SDMA Queue Command Register */
    smemRegGet(devObjPtr, SMEM_CHT_TX_SDMA_QUE_CMD_REG(devObjPtr), &txSdmaCmdReg);

    /* Scan all 8 bits in SDMA queue bitmap starting from highest */
    for (i = 0; i < SNET_CHT_SDMA_TX_QUEUE_MAX_NUMBER; i++)
    {
        txQue = SNET_CHT_SDMA_TX_QUEUE_MAX_NUMBER - (i+1);

        if (((txSdmaCmdReg >> (txQue + 8)) & 1) == 1)
        {
            /* Queue disabled */
            continue;
        }

        if (((startSdmaBmp >> txQue) & 1) == 0)
        {
            /* Queue was not triggered */
            continue;
        }


        if(devObjPtr->oamSupport.keepAliveSupport)
        {
            /* Tx SDMA Packet Generator Config Queue */
            txSdmaPktGenCfgRegPtr =
                &devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].txQueuePacketGenCfgReg;

            bypassOwnerEn = SMEM_U32_GET_FIELD(*txSdmaPktGenCfgRegPtr, 0, 1);
        }

        if (bypassOwnerEn == 0)
        {
            /* send all packets that are in this queue (fix CQ#119136) */
            do
            {
                snetChtFromCpuDmaTxQueue(devObjPtr, descrPtr, txQue, &isLastPacket);

            } while (isLastPacket == GT_FALSE);
        }
        else
        {
            /* Bypass owner bit is enabled */
            if(devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].taskHandle == 0)
            {
                devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].txQueue = txQue;
                devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].devObjPtr = devObjPtr;
                /* Create SKernel task */
                devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].taskHandle =
                    SIM_OS_MAC(simOsTaskCreate)(
                        GT_TASK_PRIORITY_NORMAL,
                        (unsigned (__TASKCONV *)(void*))snetLion3SdmaTaskPerQueue,
                        (void *)&devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue]);

                if (devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].taskHandle == NULL)
                {
                    skernelFatalError(" snetChtFromCpuDmaProcess: cannot create SDMA transmission task for"\
                                       " queue %u", txQue);
                }

                SCIB_SEM_TAKE;
                devObjPtr->numThreadsOnMe++;
                SCIB_SEM_SIGNAL;
            }
        }
    }

}

/*******************************************************************************
*   snetChtFromCpuDmaTxQueue
*
* DESCRIPTION:
*       Process transmitted frames per single SDMA queue
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       descrPtr        - pointer to descriptor
*       txQue           - TxQ number
*
* OUTPUT:
*       isLastPacketPtr - more packets in next SDMA descriptors
*
* RETURN:
*
*******************************************************************************/
GT_VOID snetChtFromCpuDmaTxQueue
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 txQue,
    OUT GT_BOOL *isLastPacketPtr
)
{
    DECLARE_FUNC_NAME(snetChtFromCpuDmaTxQueue);

    GT_BOOL queueEmpty;                         /* queue is empty */

    /* packet from cpu (DMA)*/
    __LOG((SIM_LOG_INGRESS_PACKET_FROM_CPU_DMA_STR " \n"));

    /* increment the number of packets in the system */
    skernelNumOfPacketsInTheSystemSet(GT_TRUE);

    /* consider as RXDMA of the CPU port */
    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_RXDMA_E);

    SIM_LOG_PACKET_DESCR_SAVE

    /* Fill frame descriptor from Tx SDMA descriptor */
    snetChtPerformFromCpuDma(devObjPtr, txQue, descrPtr, &queueEmpty, isLastPacketPtr);

    SIM_LOG_PACKET_DESCR_COMPARE("snetChtPerformFromCpuDma : prepare packet from CPU SDMA");

    if(queueEmpty == GT_FALSE)
    {
        if(devObjPtr->portGroupSharedDevObjPtr)
        {
            /* protect the full processing */
            SIM_OS_MAC(simOsMutexLock)(devObjPtr->portGroupSharedDevObjPtr->fullPacketWalkThroughProtectMutex);
        }

        /* packet from cpu (DMA) : Pass packet for further processing  */
        snetChtIngress(devObjPtr, descrPtr);

        if(devObjPtr->portGroupSharedDevObjPtr)
        {
            /* protect the egress processing */
            SIM_OS_MAC(simOsMutexUnlock)(devObjPtr->portGroupSharedDevObjPtr->fullPacketWalkThroughProtectMutex);
        }
    }

    /* decrement the number of packets in the system */
    skernelNumOfPacketsInTheSystemSet(GT_FALSE);

    /* packet from cpu (DMA) - Ended */
    __LOG((SIM_LOG_INGRESS_PACKET_FROM_CPU_DMA_ENDED_STR " \n"));
}

/* log the read/write DMA to log */
static void logScibDmaOperation
(
    IN SNET_CHT_DMA_CLIENT_ENT clientName,
    IN GT_BOOL doWrite,
    IN GT_U32 deviceId,
    IN GT_U32 address,
    IN GT_U32 memSize,
    IN GT_U32 * memPtr,
    IN GT_U32  dataIsWords
)
{
    GT_U32  ii;
    static GT_CHAR *operName[2] = {SIM_LOG_DMA_OPERATION_WRITE_TO_STR , SIM_LOG_DMA_OPERATION_READ_FROM_STR};
    GT_U32  index = (doWrite == GT_TRUE) ? 0 : 1;
    static GT_CHAR *clientNamesArr[SNET_CHT_DMA_CLIENT___LAST___E+1] = {
             STR(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E)
            ,STR(SNET_CHT_DMA_CLIENT_PACKET_TO_CPU_E)
            ,STR(SNET_CHT_DMA_CLIENT_AUQ_E)
            ,STR(SNET_CHT_DMA_CLIENT_FUQ_E)
            ,"unknown client"
        };
    GT_CHAR *clientNamePtr;

    if(clientName >= SNET_CHT_DMA_CLIENT___LAST___E)
    {
        /*"unknown client"*/
        clientNamePtr = clientNamesArr[SNET_CHT_DMA_CLIENT___LAST___E];
    }
    else
    {
        clientNamePtr = clientNamesArr[clientName];
    }

    scibAccessLock();

    simLogInfoSave(NULL,NULL,0,NULL,SIM_LOG_INFO_TYPE_MEMORY_E);
    simLogInternalLog(SIM_LOG_DMA_OPERATION_STR " %s ] the DMA by[ %s ] [%d] words: \n",
        operName[index],
        clientNamePtr,
        memSize
        );

    for(ii = 0 ; ii < memSize; ii++)
    {
        simLogInternalLog("address[0x%8.8x] value[0x%8.8x] \n",
            address + (4*ii) , memPtr[ii]);
    }

    scibAccessUnlock();
}


/*******************************************************************************
*  snetChtPerformScibDmaWrite
*
* DESCRIPTION:
*      wrap the scibDmaWrite to allow the LOG parser to emulate the DMA:
*      write to HOST CPU DMA memory function.
*      Asic is calling this function to write DMA.
* INPUTS:
*       clientName - the DMA client name
*       deviceId    - device id. (of the device in the simulation)
*       address     - physical address that PP refer to.
*                     HOST CPU must convert it to HOST memory address
*       memSize     - number of words of ASIC memory to write .
*       memPtr     - (pointer to) data to write to HOST CPU memory.
*       dataIsWords - the data to read is words or bytes
*                     1 - words --> swap network order to cpu order
*                     0 - bytes --> NO swap network order to cpu order
*
* OUTPUTS:
*       none
* RETURNS:
*
* COMMENTS:
*
*******************************************************************************/
void snetChtPerformScibDmaWrite
(
    IN SNET_CHT_DMA_CLIENT_ENT clientName,
    IN GT_U32 deviceId,
    IN GT_U32 address,
    IN GT_U32 memSize,
    IN GT_U32 * memPtr,
    IN GT_U32  dataIsWords
)
{
    if(simLogToRuntimeIsActive)
    {
        simLogToRuntime_scibDmaWrite(clientName,deviceId,address,memSize,memPtr,dataIsWords);
    }
    else
    {
        scibDmaWrite(deviceId,address,memSize,memPtr,dataIsWords);
    }

    if(simLogIsOpen())
    {
        logScibDmaOperation(clientName,GT_TRUE/*write*/,deviceId,address,memSize,memPtr,dataIsWords);
    }

}

/*******************************************************************************
* snetChtPerformScibDmaRead
*
* DESCRIPTION:
*        wrap the scibDmaRead to allow the LOG parser to emulate the DMA:
*      write to HOST CPU DMA memory function.
*      Asic is calling this function to write DMA.
*
* INPUTS:
*       clientName - the DMA client name
*       deviceId    - device id. (of the device in the simulation)
*       address     - physical address that PP refer to.
*                     HOST CPU must convert it to HOST memory address
*       memSize     - the number of words/bytes (according to dataIsWords)
*       dataIsWords - the data to read is words or bytes
*                     1 - words --> swap network order to cpu order
*                     0 - bytes --> NO swap network order to cpu order
*
* OUTPUTS:
*       memPtr     - (pointer to) PP's memory in which HOST CPU memory will be
*                    copied.
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
void snetChtPerformScibDmaRead
(
    IN SNET_CHT_DMA_CLIENT_ENT clientName,
    IN GT_U32 deviceId,
    IN GT_U32 address,
    IN GT_U32 memSize,
    OUT GT_U32 * memPtr,
    IN GT_U32  dataIsWords
)
{
    if(simLogToRuntimeIsActive)
    {
        simLogToRuntime_scibDmaRead(clientName,deviceId,address,memSize,memPtr,dataIsWords);
    }
    else
    {
        scibDmaRead(deviceId,address,memSize,memPtr,dataIsWords);
    }

    if(simLogIsOpen())
    {
        logScibDmaOperation(clientName,GT_FALSE/*read*/,deviceId,address,memSize,memPtr,dataIsWords);
    }
}

/*******************************************************************************
*   scibSetInterrupt
*
* DESCRIPTION:
*       wrap the scibSetInterrupt to allow the LOG parser to emulate the interrupt:
*       Generate interrupt for SKernel device.
*
* INPUTS:
*       deviceId  - ID of device, which is equal to PSS Core API device ID.
*
* OUTPUTS:
*       none.
*
* RETURNS:
*
*
* COMMENTS:
*
*
*******************************************************************************/
void snetChtPerformScibSetInterrupt
(
    IN  GT_U32        deviceId
)
{
    if(simLogToRuntimeIsActive)
    {
        simLogToRuntime_scibSetInterrupt(deviceId);
    }
    else
    {
        scibSetInterrupt(deviceId);
    }

    __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("Set interrupt by dev[%d] \n",
        deviceId));

}


/*******************************************************************************
*   snetChtPerformFromCpuDma
*
* DESCRIPTION:
*       Copy frame data from CPU memory to bufferId
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       txQue           - tx queue
*       descrPtr        - pointer to frame descriptor
*       queueEmptyPtr   - (pointer to) indicate that queue empty or not.
*                       GT_FALSE - queue may have another packet to send
*                       GT_TRUE - queue NOT have more packets to send
*
*******************************************************************************/
static GT_VOID snetChtPerformFromCpuDma
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32 txQue,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    OUT GT_BOOL * queueEmptyPtr,
    OUT GT_BOOL * isLastPacketPtr
)
{
    DECLARE_FUNC_NAME(snetChtPerformFromCpuDma);

    GT_U32 fldValue;                   /* register field value */
    GT_U32 copySize;                   /* size of copied data */
    SNET_STRUCT_TX_DESC * txDescPtr;   /* pointer to Tx descriptor */
    GT_U8 * dataPtr;                   /* pointer to buffer */
    SNET_STRUCT_TX_DESC txDesc;        /* buffer for TX descriptor */
    SNET_STRUCT_TX_DESC nextTxDesc;    /* buffer for next TX descriptor */
    GT_U32  currentDmaAddr;            /* current address for DMA */
    GT_BOOL resetEnqBit;               /* need to reset ENQ bit */
    GT_U32 *txSdmaPktGenCfgRegPtr;         /* Register data */
    GT_U32 bypassOwnerEn;              /* Bypass owner bit updating */
    GT_BIT  isLast;                    /* is last descriptor */
    GT_U32 nextDescPointer;            /* the next descriptor 'pointer' */

    /* init to indicate there are no more frames in the queue */
    *queueEmptyPtr = GT_TRUE;
    *isLastPacketPtr = GT_TRUE;

    /* read descriptor address of appropriate queue */
    smemRegGet(devObjPtr,
               SMEM_CHT_TX_SDMA_CUR_DESC_PTR0_REG(devObjPtr) + (txQue * 0x4), &fldValue);

    /*txDescPtr = (SNET_STRUCT_TX_DESC *)fldValue;*/
    currentDmaAddr = fldValue;
    /* Init DMA first and last descriptor address */
    txDescPtr = &txDesc;

    /* Do not bypass - default mode */
    bypassOwnerEn = 0;
    if(devObjPtr->oamSupport.keepAliveSupport)
    {
        /* Tx SDMA Packet Generator Config Queue */
        txSdmaPktGenCfgRegPtr =
            &devObjPtr->sdmaTransmitInfo.sdmaTransmitData[txQue].txQueuePacketGenCfgReg;

        bypassOwnerEn = SMEM_U32_GET_FIELD(*txSdmaPktGenCfgRegPtr, 0, 1);
    }

    if(currentDmaAddr == 0)
    {
        /* Generate interrupt Tx DMA stopped processing the queue */
        snetChetahDoInterrupt(devObjPtr,
                              SMEM_CHT_TX_SDMA_INT_CAUSE_REG(devObjPtr),
                              SMEM_CHT_TX_SDMA_INT_MASK_REG(devObjPtr),
                              SMEM_CHT_TX_ERROR_INT(txQue),
                              SMEM_CHT_TX_SDMA_SUM_INT(devObjPtr));

        /* although there is special interrupt for this case we need
           the FATAL ERROR --- because this state indicate that there is error
           in PSS */
        skernelFatalError("snetChtPerformFromCpuDma: NULL descriptor \n");
        return ;
    }

    /* read the DMA for needed value , put data into txDescPtr */
    snetChtPerformScibDmaRead(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
        devObjPtr->deviceId,currentDmaAddr,NUM_BYTES_TO_WORDS(sizeof(*txDescPtr)), (GT_U32*)txDescPtr,SCIB_DMA_WORDS);

    /* Indicates first buffer of a frame */
    if(TX_DESC_GET_FIRST_BIT(txDescPtr) == 0)
    {
        /* the SW did not prepared descriptors yet.
          This is legal situation when SW prepares packets to send without
          triggering. And only after this (may be in scope of other task)
          it triggers sending of batch of packets .*/

        /* Resets the matching ENQ bit */
        smemRegFldSet(devObjPtr, SMEM_CHT_TX_SDMA_QUE_CMD_REG(devObjPtr), txQue, 1, 0);
        return;
    }

    /* Point to the beginning of buffer */
    dataPtr = descrPtr->frameBuf->actualDataPtr;
    copySize = 0;

    while(currentDmaAddr != 0)
    {
        /* Buffer is owned by CPU */
        if (TX_DESC_GET_OWN_BIT(txDescPtr) == TX_DESC_CPU_OWN)
        {
            /* Resets the matching ENQ bit */
            smemRegFldSet(devObjPtr, SMEM_CHT_TX_SDMA_QUE_CMD_REG(devObjPtr), txQue, 1, 0);

            /* Generate interrupt Tx DMA stopped processing the queue */
            __LOG(("Generate interrupt Tx DMA stopped processing the queue"));
            snetChetahDoInterrupt(devObjPtr,
                                  SMEM_CHT_TX_SDMA_INT_CAUSE_REG(devObjPtr),
                                  SMEM_CHT_TX_SDMA_INT_MASK_REG(devObjPtr),
                                  SMEM_CHT_TX_ERROR_INT(txQue),
                                  SMEM_CHT_TX_SDMA_SUM_INT(devObjPtr));

            smemRegSet(devObjPtr,
                       SMEM_CHT_TX_SDMA_CUR_DESC_PTR0_REG(devObjPtr) + (txQue * 0x4),
                       currentDmaAddr);
            return;
        }

        /* Byte Count */
        fldValue = SMEM_U32_GET_FIELD(txDescPtr->word2, 16, 14);
        __LOG(("<Byte Count> : Added [%d] bytes to the 'SDMA packet' from current descriptor \n ",fldValue));


        copySize += fldValue;
        if(copySize > SBUF_DATA_SIZE_CNS)
        {
            /* we can't support packet larger then SBUF_DATA_SIZE_CNS */
            skernelFatalError("snetChtPerformFromCpuDma: packet too long \n");
        }

        /*memcpy(dataPtr, (GT_U32 *)txDescPtr->buffPointer, fldValue);*/
        snetChtPerformScibDmaRead(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
            devObjPtr->deviceId,txDescPtr->buffPointer,NUM_BYTES_TO_WORDS(fldValue),(GT_U32*)dataPtr,
                RX_BYTE_ORDER_MAC(devObjPtr));

        dataPtr += fldValue;

        /* Update next descriptor to feed.
          Do it before return ownership on descr to CPU in order to prevent race
          condition on the register between "CPU" tasks and simulation tasks.
          The "CPU" task may pool Own bit as indication that device finished
          descriptor processing. And "CPU" task changes current descriptor
          register when device finished processing of descriptor. Therefore
          simulation should update register before change the Own bit.  */
        smemRegSet(devObjPtr,
                   SMEM_CHT_TX_SDMA_CUR_DESC_PTR0_REG(devObjPtr) + (txQue * 0x4),
                   txDescPtr->nextDescPointer);

        /* Last buffer of frame. Need to check next descriptor. And need to
          resets the matching ENQ bit if next descriptor is not ready.
          Do it before return ownership on descr to CPU in order to prevent race
          condition. */
        isLast = TX_DESC_GET_LAST_BIT(txDescPtr);
        /* get value before update the ownership of the descriptor */
        nextDescPointer = txDescPtr->nextDescPointer;

        if (isLast)
        {
            if (txDescPtr->nextDescPointer)
            {
                /* read next descriptor*/
                snetChtPerformScibDmaRead(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                    devObjPtr->deviceId,txDescPtr->nextDescPointer,NUM_BYTES_TO_WORDS(sizeof(nextTxDesc)), (GT_U32*)&nextTxDesc,SCIB_DMA_WORDS);
                if((TX_DESC_GET_FIRST_BIT(&nextTxDesc) == 0) ||
                   (TX_DESC_GET_OWN_BIT(&nextTxDesc) == TX_DESC_CPU_OWN))
                {
                    /* next descriptor is not ready. Need to reset ENQ bit. */
                    resetEnqBit = GT_TRUE;
                }
                else
                {
                    /* next descriptor is ready. Do not reset ENQ bit. */
                    resetEnqBit = GT_FALSE;
                    *isLastPacketPtr = GT_FALSE;
                }
            }
            else
            {
                /* current descriptor is last one. Need to reset ENQ bit. */
                resetEnqBit = GT_TRUE;
            }

            if (resetEnqBit == GT_TRUE)
            {
                /* Resets the matching ENQ bit */
                smemRegFldSet(devObjPtr, SMEM_CHT_TX_SDMA_QUE_CMD_REG(devObjPtr), txQue, 1, 0);
            }
        }

        /* Do not bypass */
        if(bypassOwnerEn == 0)
        {
            /* Return ownership on descr to CPU to enable release of descr */
            TX_DESC_SET_OWN_BIT(txDescPtr, TX_DESC_CPU_OWN);

            /* write back to DMA the changes in the descriptor */
            __LOG(("write the DMA for return 'ownership' to CPU \n"));
            snetChtPerformScibDmaWrite(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                         devObjPtr->deviceId,currentDmaAddr,
                         1/* update first word txDescPtr->word1*/,
                         (GT_U32*)txDescPtr,
                         SCIB_DMA_WORDS);
        }

        /*txDescPtr = (SNET_STRUCT_TX_DESC * )txDescPtr->nextDescPointer;*/
        currentDmaAddr = nextDescPointer;

        /* Last buffer of frame */
        if (isLast)
        {
            __LOG(("Last descriptor with last buffer of frame \n"));
            break;
        }

        if(currentDmaAddr)
        {
            /* read the DMA for needed value , put data into txDescPtr */
            __LOG(("read the DMA for next descriptor \n"));
            snetChtPerformScibDmaRead(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                devObjPtr->deviceId,currentDmaAddr,NUM_BYTES_TO_WORDS(sizeof(*txDescPtr)), (GT_U32*)txDescPtr,SCIB_DMA_WORDS);
        }
    }

    __LOG(("Total [%d] bytes for the 'SDMA packet' \n ",copySize));

    descrPtr->frameBuf->actualDataSize = copySize;

    /* Last buffer has received and interrupt is enable */
    if (currentDmaAddr && TX_DESC_GET_INT_BIT(txDescPtr))
    {                                          /* Generate interrupt Tx DMA stopped processing the queue */
        snetChetahDoInterrupt(devObjPtr,
                              SMEM_CHT_TX_SDMA_INT_CAUSE_REG(devObjPtr),
                              SMEM_CHT_TX_SDMA_INT_MASK_REG(devObjPtr),
                              SMEM_CHT_TX_BUFFER_INT(txQue),
                              SMEM_CHT_TX_SDMA_SUM_INT(devObjPtr));

    }

    /* Set CPU port for local device source port */
    descrPtr->localDevSrcPort = SNET_CHT_CPU_PORT_CNS;

    if(devObjPtr->dmaNumOfCpuPort)
    {
        /* the packet came from the DMA of the CPU */
        descrPtr->ingressRxDmaPortNumber = devObjPtr->dmaNumOfCpuPort;
    }
    else
    {
        /* get the RXDMA port number */
        descrPtr->ingressRxDmaPortNumber = SMEM_LION2_LOCAL_PORT_TO_RX_DMA_PORT_MAC(devObjPtr,descrPtr->localDevSrcPort);
    }

    if(devObjPtr->numOfPipes)
    {
        GT_U32  dummyPort;
        /* Update 'currentPipeId' and get new (local) port */
        smemConvertGlobalPortToCurrentPipeId(devObjPtr,descrPtr->ingressRxDmaPortNumber,&dummyPort);
    }


    if(devObjPtr->cpuPortNoSpecialMac)
    {
        /* the SDMA CPU port does not hold 'GOP' !!! */
        descrPtr->ingressGopPortNumber = SMAIN_NOT_VALID_CNS;/* value to cause fatal error for using 'GOP' when should not */
    }
    else
    {
        /* get the MAC port number */
        descrPtr->ingressGopPortNumber = snetChtRxMacPortGet(devObjPtr,descrPtr->localDevSrcPort);
    }

    __LOG_PARAM_NO_LOCATION_META_DATA(descrPtr->localDevSrcPort);
    __LOG_PARAM_NO_LOCATION_META_DATA(descrPtr->ingressRxDmaPortNumber);
    __LOG_PARAM_NO_LOCATION_META_DATA(descrPtr->ingressGopPortNumber);

    /* Indicate frame received through DMA mechanism */
    descrPtr->isFromSdma = GT_TRUE;

    /* there might be more frames in the queue */
    *queueEmptyPtr = GT_FALSE;

    return;
}

/*******************************************************************************
* snetCht2TTermination
*
* DESCRIPTION:
*        T.T Engine processing for outgoing frame on Cheetah2/Cheetah3
*        asic simulation.
*        T.T processing, T.T assignment, key forming, 1 Lookup,
*        actions to descriptor processing
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to frame data buffer Id
*       internalTtiInfoPtr -  pointer to internal TTI info
*
* OUTPUTS:
*       descrPtr     - pointer to updated frame data buffer Id
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtTTermination
(
    IN    SKERNEL_DEVICE_OBJECT             * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr,
    IN    INTERNAL_TTI_DESC_INFO_STC        * internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtTTermination);

    if (SKERNEL_IS_CHEETAH2_ONLY_DEV(devObjPtr))
    {
        snetCht2TTermination(devObjPtr, descrPtr);
    }
    else
    if (SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        snetCht3TTermination(devObjPtr, descrPtr,internalTtiInfoPtr);
    }

    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_HARD_DROP_E ||
       descrPtr->packetCmd >= SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E)
    {
        __LOG(("At the end of TTI unit do next implicit Set of bypassBridge = 1 for HARD_DROP / not forward DSA tag \n"));
        descrPtr->bypassBridge = 1;
        __LOG_PARAM(descrPtr->bypassBridge);
    }
}

/*******************************************************************************
* pclAfterTtiPclLookupModeGet
*
* DESCRIPTION:
*        get pcl lookup mode after TTI
*
* INPUTS:
*       devObjPtr          - pointer to device object.
*       descrPtr           - pointer to frame descriptor.
*
* OUTPUTS:
*       descrPtr           - pointer to frame descriptor.
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID pclAfterTtiPclLookupModeGet
(
    IN    SKERNEL_DEVICE_OBJECT             *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   *descrPtr
)
{
    DECLARE_FUNC_NAME(snetXcatPclAfterTtiPclLookupModeGet);

    GT_U32 * portVlanCfgEntryPtr;   /* table entry pointer */
    GT_U32  regAddress;
    GT_U32   fieldVal;   /* Register's field value */
    GT_U32   bitNum;     /* Register's bit number  */
    GT_BIT  modifyArr[3] = {0,0,0};

    if(devObjPtr->supportEArch && devObjPtr->unitEArchEnable.tti)
    {
        portVlanCfgEntryPtr = NULL;
    }
    else
    {
        regAddress = SMEM_CHT_PORT_VLAN_QOS_CONFIG_TBL_MEM(devObjPtr,
                                                            descrPtr->localDevSrcPort);
        portVlanCfgEntryPtr = smemMemGet(devObjPtr, regAddress);
    }

    modifyArr[0] = modifyArr[1] = modifyArr[2] = 0;

    if(descrPtr->pclLookUpMode[0] == SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[0]);
    }

    if(descrPtr->pclLookUpMode[1] == SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[1]);
    }

    if(descrPtr->pclLookUpMode[2] == SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[2]);
    }

    if(descrPtr->eArchExtInfo.ttiPostTtiLookupIngressEPortTablePtr)
    {
        /*IPCL enable*/
        descrPtr->policyOnPortEn =
            SMEM_LION3_TTI_EPORT_ATTRIBUTES_ENTRY_FIELD_GET(devObjPtr,descrPtr,
                SMEM_LION3_TTI_EPORT_ATTRIBUTES_TABLE_FIELDS_ING_POLICY_EN);

        /*PCL0-0 Lookup Configuration Mode*/
        if(descrPtr->pclLookUpMode[0] != SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
        {
            modifyArr[0] = 1;
            descrPtr->pclLookUpMode[0] =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP0_PCL_CFG_MODE);
        }

        /*PCL0-1 Lookup Configuration Mode*/
        if(descrPtr->pclLookUpMode[1] != SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
        {
            modifyArr[1] = 1;
            descrPtr->pclLookUpMode[1] =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP1_PCL_CFG_MODE);
        }

        /*PCL1-0 Lookup Configuration Mode*/
        if(descrPtr->pclLookUpMode[2] != SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
        {
            modifyArr[2] = 1;
            descrPtr->pclLookUpMode[2] =
                SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
                    SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_LOOKUP2_PCL_CFG_MODE);
        }

    }
    else if(portVlanCfgEntryPtr == NULL)
    {
        /* fix for coverity warning "FORWARD_NULL" */
        skernelFatalError("pclAfterTtiPclLookupModeGet: invalid table entry pointer\n");
    }
    else
    {
        /* Ingress Policy Enable */
        descrPtr->policyOnPortEn =
            SNET_CHT_PORT_VLAN_QOS_PORT_POLICY_EN_GET_MAC(devObjPtr,
                                                          portVlanCfgEntryPtr);

        /*PCL0-0 Lookup Configuration Mode*/
        if(descrPtr->pclLookUpMode[0] != SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
        {
            modifyArr[0] = 1;
            descrPtr->pclLookUpMode[0] =
                SNET_CHT_PORT_VLAN_QOS_PCL0_0_LOOKUP_CONFIGURATION_MODE_GET_MAC(devObjPtr,portVlanCfgEntryPtr);
        }

        /*PCL0-1 Lookup Configuration Mode*/
        if(descrPtr->pclLookUpMode[1] != SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
        {
            modifyArr[1] = 1;
            descrPtr->pclLookUpMode[1] =
                SNET_CHT_PORT_VLAN_QOS_PCL0_1_LOOKUP_CONFIGURATION_MODE_GET_MAC(devObjPtr,portVlanCfgEntryPtr);
        }

        /*PCL1-0 Lookup Configuration Mode*/
        if(descrPtr->pclLookUpMode[2] != SKERNEL_PCL_LOOKUP_MODE_DESCRIPTOR_INDEX_E)
        {
            modifyArr[2] = 1;
            descrPtr->pclLookUpMode[2] =
                SNET_CHT_PORT_VLAN_QOS_PCL1_0_LOOKUP_CONFIGURATION_MODE_GET_MAC(devObjPtr,portVlanCfgEntryPtr);
        }
    }

    if(modifyArr[0])
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[0]);
    }

    if(modifyArr[1])
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[1]);
    }

    if(modifyArr[2])
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[2]);
    }

    modifyArr[0] = modifyArr[1] = modifyArr[2] = 0;

    __LOG(("Ingress Policy Enable: [%d]", descrPtr->policyOnPortEn));

    if(descrPtr->tunnelTerminated &&
       SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        /* get Force_VLAN_Mode_on_TTI field value */
        bitNum = SMEM_CHT_IS_SIP5_GET(devObjPtr)? 5 : 10;
        smemRegFldGet(devObjPtr, SMEM_XCAT_TTI_ENGINE_CONFIG_REG(devObjPtr), bitNum, 1, &fieldVal);

        if(fieldVal)
        {
            /*If TTI rule hit Policy Configuration table, access is according to the packet's VLAN-ID.*/
            __LOG(("enabled Force_VLAN_Mode_on_TTI \n"));
            descrPtr->pclLookUpMode[0] =
            descrPtr->pclLookUpMode[1] =
            descrPtr->pclLookUpMode[2] = SKERNEL_PCL_LOOKUP_MODE_VID_E;

            modifyArr[0] = modifyArr[1] = modifyArr[2] = 1;
        }
    }

    if(modifyArr[0])
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[0]);
    }

    if(modifyArr[1])
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[1]);
    }

    if(modifyArr[2])
    {
        __LOG_PARAM(descrPtr->pclLookUpMode[2]);
    }

}

/*******************************************************************************
*   snetChtAfterIPclGlue
*
* DESCRIPTION:
*       glue function after IPCL unit (and before the bridge) that used for LSR updates
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
static GT_VOID snetChtAfterIPclGlue(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtAfterIPclGlue);

    GT_BIT isSwap;/* is mpls command involve swap (swap/pop1_swap/pop2_swap)*/

    if(descrPtr->tunnelTerminated == GT_FALSE)
    {
        if(descrPtr->mpls && descrPtr->mplsCommand != SKERNEL_XCAT_TTI_MPLS_NOP_E)
        {
            if(descrPtr->VntL2Echo == GT_TRUE)
            {
                __LOG(("Do not treat LSR for VntL2Echo = 1 \n"));
            }
            else
            {
                __LOG(("For MPLS LSR set 'implicitly' the descrPtr->tunnelTerminated = GT_TRUE , for NON-tunnel terminated action ! \n"));
                descrPtr->tunnelTerminated = GT_TRUE;/* the HW set this bit !!! */
                descrPtr->isMplsLsr = 1;

                switch(descrPtr->mplsCommand)
                {
                case SKERNEL_XCAT_TTI_MPLS_SWAP_E:
                case SKERNEL_XCAT_TTI_MPLS_POP_SWAP_E:
                /* those cases are not treated here as swap (like in verifier)
                case SKERNEL_XCAT_TTI_MPLS_POP2_SWAP_E:
                case SKERNEL_XCAT_TTI_MPLS_POP3_SWAP_E:*/
                    isSwap = 1;
                    break;
                default:
                    isSwap = 0;
                    break;
                }
                /* an LSR is an intermediate MPLS router in the network */
                descrPtr->doRouterHa = isSwap ? 0 : 1;/*logic from Verifier*/
                descrPtr->routed = 1;
                if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
                {
                    /*
                        IF TTI Action<MPLS Command>==SWAP && Number_Of_Labels == 1
                            Desc<Inner Packet Type> = UNKNOWN (4)
                        Else if TTI Action<MPLS Command>==POP-SWAP && Number_Of_Labels == 2
                            Desc<Inner Packet Type> = UNKNOWN (4)
                        Else
                            Desc<Inner Packet Type> = MPLS (1)
                    */

                    if(descrPtr->mplsCommand == SKERNEL_XCAT_TTI_MPLS_SWAP_E && ((descrPtr->numOfLabels + 1) == 1))
                    {
                        descrPtr->innerPacketType = SKERNEL_INNER_PACKET_TYPE_UNKNOWN;
                    }
                    else
                    if(descrPtr->mplsCommand == SKERNEL_XCAT_TTI_MPLS_POP_SWAP_E/*POP-SWAP*/ && ((descrPtr->numOfLabels + 1) == 2))
                    {
                        descrPtr->innerPacketType = SKERNEL_INNER_PACKET_TYPE_UNKNOWN;
                    }
                    else
                    if(descrPtr->mplsCommand == SKERNEL_XCAT_TTI_MPLS_POP2_SWAP_E/*POP2-SWAP*/ && ((descrPtr->numOfLabels + 1) == 3))
                    {
                        descrPtr->innerPacketType = SKERNEL_INNER_PACKET_TYPE_UNKNOWN;
                    }
                    else
                    if(descrPtr->mplsCommand == SKERNEL_XCAT_TTI_MPLS_POP3_SWAP_E/*POP3-SWAP*/ && ((descrPtr->numOfLabels + 1) == 4))
                    {
                        descrPtr->innerPacketType = SKERNEL_INNER_PACKET_TYPE_UNKNOWN;
                    }
                    else
                    {
                        descrPtr->innerPacketType = SKERNEL_INNER_PACKET_TYPE_MPLS;
                    }
                }
                else
                {
                    /* the descrPtr->innerPacketType was already set according
                       to the passengerPacketType from the action */
                }

                descrPtr->tunnelTerminationOffset = 0;/* value set properly in start of chtHaUnit */
            }
        }
    }

}
/*******************************************************************************
*   snetChtIPcl
*
* DESCRIPTION:
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*       Call to cheetah2 or cheetah ingress PCL.
*
*******************************************************************************/
static GT_VOID snetChtIPcl(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIPcl);

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_IPCL_E);

    if(descrPtr->packetCmd >= SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E)
    {
        /* the commands of :
            SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E    --> only from DSA tag --> not doing IPCL
            SKERNEL_EXT_PKT_CMD_FROM_CSCD_TO_CPU_E  --> only from DSA tag --> not doing IPCL
            SKERNEL_EXT_PKT_CMD_FROM_CPU_E          --> only from DSA tag --> not doing IPCL
            SKERNEL_EXT_PKT_CMD_BRIDGE_MIRROR_E,    --> only inside the router engine --> never get here
            SKERNEL_EXT_PKT_CMD_BRIDGE_E,           --> only inside the router engine --> never get here
        */
        return;
    }

    /* function should be in TTI unit , but was easier to fix code in PCL unit
       then to move to TTI */
    __LOG(("Do pcl lookup mode resolution from TTI \n"));
    pclAfterTtiPclLookupModeGet(devObjPtr,descrPtr);

    if(SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
    {
        snetXCatIPcl(devObjPtr, descrPtr);
    }
    else if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        snetCht3IPcl(devObjPtr, descrPtr);
    }
    else if(SKERNEL_IS_CHEETAH2_ONLY_DEV(devObjPtr))
    {
        snetCht2IPcl(devObjPtr, descrPtr);
    }
    else /*cheetah+*/
    {
        snetChtPcl(devObjPtr, descrPtr);
    }

    /* L2/L3 Ingress VLAN CNC Trigger */
    __LOG(("CNC - L2/L3 Ingress VLAN CNC Trigger \n"));
    snetCht3CncCount(devObjPtr, descrPtr,
                     SNET_CNC_CLIENT_INGRESS_VLAN_L2_L3_E, 0);


    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        __LOG(("CNC - 'source eport' : use index from localDevSrcEPort \n"));
        /*  CNC counter index is taken from LocalDevSRCePort[13:0] after the
            optional assignment of source ePort by PCL/TTI action */
        snetCht3CncCount(devObjPtr, descrPtr,
                         SNET_CNC_CLIENT_SOURCE_EPORT_E,
                         descrPtr->eArchExtInfo.localDevSrcEPort);
    }

    /* call the glue that sets in the end of the IPCL (before) L2i */
    snetChtAfterIPclGlue(devObjPtr,descrPtr);

    if(devObjPtr->pclSupport.pclUseCFMEtherType)
    {
        if(descrPtr->VntL2Echo)
        {
            __LOG(("Do CFM classification from PCL unit \n"));
            snetChtCfmEtherTypeCheck(devObjPtr, descrPtr);
        }
        else
        {
            __LOG(("NO CFM classification when VntL2Echo = 0 \n"));
        }
    }


    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_HARD_DROP_E/* ||
       descrPtr->packetCmd >= SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E*/)
    {
        __LOG(("At the end of PCL unit do next implicit Set of bypassBridge = 1 for HARD_DROP \n"));
        descrPtr->bypassBridge = 1;
        __LOG_PARAM(descrPtr->bypassBridge);
    }
}

/*******************************************************************************
*   snetChtIPolicer
*
* DESCRIPTION:
*        Policer Processing  --- Policer Counters updates
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetChtIPolicer(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_IPLR_E);

    if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        /* ch3 and above */
        snetCht3Policer(devObjPtr, descrPtr);
    }
    else
    {
        /*ch1,2*/
        snetChtPolicer(devObjPtr, descrPtr);
    }

    /* reset the field as it hold no meaning outside the POLICER and it makes 'diff' for the LOGGER */
    descrPtr->policerCycle = 0;
}

/*******************************************************************************
*   snetChtRouting
*
* DESCRIPTION:
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*       Call to cheetah2 or cheetah ingress ROUTING.
*
*******************************************************************************/
static GT_VOID snetChtRouting(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtRouting);

    GT_U32  regAddr;/* register address */
    GT_U32  regVal;/* register value */
    GT_BIT  useCheetahUcRouter = 0;/* do we use cheetah 1 UC router */

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_IPVX_E);

    if (SMEM_CHT_IS_SIP5_GET(devObjPtr) == 0)
    {
        if (devObjPtr->supportOnlyUcRouter) /* device with only router glue */
        {
            /* cheetah 1, BullsEye */
            __LOG(("cheetah 1, BullsEye"));
            useCheetahUcRouter = 1;
        }
        else
        {
            /* devices with router engine */
            __LOG(("devices with router engine"));
            /* check if the router glue enabled */
            regAddr = SMEM_CHT2_ROUTER_ADDITIONAL_CONTROL_REG(devObjPtr);
            smemRegFldGet(devObjPtr,regAddr,0,1,&regVal);
            if(regVal == 1)
            {
                /* router mode */
                __LOG(("router mode"));
                if(descrPtr->pclRedirectCmd == PCL_TTI_ACTION_REDIRECT_CMD_PBR_OR_VPLS_E)
                {
                    /* don't do routing */
                    __LOG(("don't do routing"));
                    return;
                }
            }
            else
            {
                /* router glue mode */
                __LOG(("router glue mode"));
                useCheetahUcRouter = 1;
            }
        }
    }

    if (useCheetahUcRouter == 0)     /* : cheetah2,3 ROUTER */
    {
        snetCht2Routing(devObjPtr, descrPtr);
    }
    else
    {
        snetChtUcRouting(devObjPtr,descrPtr);     /* : cheetah ROUTER */

        if(devObjPtr->errata.routerGlueResetPartsOfDescriptor)
        {
            /* IN HW : bits [214:249] in the descriptor that is going out to the plr are zeroed*/

            /* the router glue reset some of the fields of the descriptor */
            descrPtr->cfidei = 0;               /* cfi */
            descrPtr->pktIsLooped = 0;          /*PktIsLooped*/
            /* DropOnSource --> not implemented */
            /* OrigVID --> not implemented */
            descrPtr->cfm = 0;                 /*CFMPkt*/
            descrPtr->policerEn = 0;           /*PolicerEn*/
            descrPtr->policerPtr = 0;          /*PolicerPtr*/
            descrPtr->policerCounterEn = 0;    /*BillingEn*/
        }
    }
}

/*******************************************************************************
*   snetChtFromEmbeddedCpuProcess
*
* DESCRIPTION:
*       Process transmitted SDMA queue frames in the Cheetah
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       bufferId        - pointer to received buffer
*
* OUTPUT:
*
* RETURN:
*
*******************************************************************************/
static GT_VOID snetChtFromEmbeddedCpuProcess
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SBUF_BUF_ID bufferId
)
{
    /* treat the frame that came from the embedded CPU as all other frames ,
       as if it came from port "embedded CPU port" */
    snetChtFrameProcess(devObjPtr,bufferId,SNET_CHT_EMBEDDED_CPU_PORT_CNS);

    return;
}


/*******************************************************************************
*   snetChtIngressMacSa
*
* DESCRIPTION:
*       Ingress MAC SA LookUp ,VLAN assignment , RSSI
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtIngressMacSa(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{

    /* only frame that matched valid action in CAPWAP TTI lookup , will be
       subject to the next steps */
    if(descrPtr->capwap.validAction == GT_FALSE)
    {
        return;
    }

    if(SKERNEL_IS_CHEETAH3P_ONLY_DEV(devObjPtr))
    {
        snetCht3IngressMacSa(devObjPtr,descrPtr);
    }

    return;
}


/*******************************************************************************
*   snetChtIngressTunnelReplication
*
* DESCRIPTION:
*       Ingress L2 tunnel replication
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtIngressL2TunnelReplication
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngressL2TunnelReplication);

    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_MLL_E);

    if(descrPtr->useVidx == 0)
    {
        /* single destination , no need for replications */
        __LOG(("single destination , no need for replications"));
        return;
    }

    if(SKERNEL_IS_CHEETAH3P_ONLY_DEV(devObjPtr))
    {
        __LOG(("Packet needs for replications"));

        snetCht3IngressL2TunnelReplication(devObjPtr,descrPtr);
    }
}

/*******************************************************************************
*   snetChtIngressL3IpReplication
*
* DESCRIPTION:
*       Ingress L2 tunnel replication
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtIngressL3IpReplication
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngressL3IpReplication);

    if(descrPtr->validMll == 0)
    {
        /* not valid MLL to act according */
        __LOG(("not valid MLL to act according"));
        return;
    }

    snetCht3IngressL3IpReplication(devObjPtr,descrPtr);
}


/*******************************************************************************
*   snetLion3MllStart
*
* DESCRIPTION:
*       SIP5 : entry point to MLL unit , before any L3/L2 replications
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetLion3MllStart
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
)
{
    DECLARE_FUNC_NAME(snetLion3MllStart);

    GT_U32  regValue;
    GT_U32  multiTargetePortValue,multiTargetePortMask,multiTargetePortBase;
    GT_U32  ePortToEVidxBase;
    GT_32   eVidx;/* !!! signed integer !!!*/

    if(descrPtr->useVidx || descrPtr->targetIsTrunk)
    {
        __LOG(("Multi-Target ePort : not relevant to useVidx == 1 or targetIsTrunk == 1 \n"));
        return;
    }

    smemRegGet(devObjPtr, SMEM_LION3_MLL_REPLICATED_TRAFFIC_CTRL_REG(devObjPtr) ,&regValue);

    /*<Multi-Target ePort Enable>*/
    if(0 == SMEM_U32_GET_FIELD(regValue,11,1))
    {
        __LOG(("Multi-Target ePort : Disabled \n"));
        return;
    }

    smemRegGet(devObjPtr, SMEM_LION3_MLL_MULTI_TARGET_EPORT_VALUE_REG(devObjPtr) ,&regValue);
    multiTargetePortValue = SMEM_U32_GET_FIELD(regValue,0,17);

    smemRegGet(devObjPtr, SMEM_LION3_MLL_MULTI_TARGET_EPORT_MASK_REG(devObjPtr) ,&regValue);
    multiTargetePortMask = SMEM_U32_GET_FIELD(regValue,0,17);

    if((descrPtr->trgEPort & multiTargetePortMask) != multiTargetePortValue)
    {
        __LOG(("Multi-Target ePort : the target ePort[%x] is not in range for mapping. \n",
            descrPtr->trgEPort));
        return;
    }

    smemRegGet(devObjPtr, SMEM_LION3_MLL_MULTI_TARGET_EPORT_BASE_REG(devObjPtr) ,&regValue);
    multiTargetePortBase = SMEM_U32_GET_FIELD(regValue,0,17);

    smemRegGet(devObjPtr, SMEM_LION3_MLL_MULTI_TARGET_EPORT_TO_EVIDX_BASE_REG(devObjPtr) ,&regValue);
    ePortToEVidxBase = SMEM_U32_GET_FIELD(regValue,0,16);

    /*
        Desc<UseVIDX>=1
        Desc<eVIDX>=Desc<TRGePort>-<Multi-Target ePort Base>+<ePort to eVIDX Base>

        NOTE: If the result of the eVIDX in the last line is < 0, the MLL assigns eVIDX=0.
        If the result is > 0xFFFF, the MLL assigns eVIDX=0xFFFF.
    */

    eVidx = descrPtr->trgEPort - multiTargetePortBase +  ePortToEVidxBase;
    if(eVidx < 0)
    {
        eVidx = 0;
    }
    else if(eVidx > 0xFFFF)
    {
        eVidx = 0xFFFF;
    }

    descrPtr->useVidx = 1;
    descrPtr->eVidx = (GT_U32)eVidx;

    __LOG(("Multi-Target ePort : the target ePort[%x] mapped to: useVidx = 1 and eVidx[%x] ! \n",
        descrPtr->trgEPort,
        descrPtr->eVidx));


    /* 'destroy' the target ePort .
        it is not needed but just to change it from previous value */
    descrPtr->trgEPort = 0;

    return;

}

/*******************************************************************************
*   snetChtMll
*
* DESCRIPTION:
*       Ingress MLL unit (L2,L3 replications)
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtMll
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
)
{
    simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_MLL_E);

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* entry point to MLL unit , before any L3/L2 replications */
        SIM_LOG_PACKET_DESCR_SAVE
        snetLion3MllStart(devObjPtr, descrPtr);
        SIM_LOG_PACKET_DESCR_COMPARE("snetLion3MllStart");
    }


    /* L3 (Ipv4/6) MLL Replication */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtIngressL3IpReplication(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("(on orig descriptor) snetChtIngressL3IpReplication \n");

    /* L2 MLL Replication */
    SIM_LOG_PACKET_DESCR_SAVE
    snetChtIngressL2MllEngine(devObjPtr, descrPtr);
    SIM_LOG_PACKET_DESCR_COMPARE("(on orig descriptor) snetChtIngressL2MllEngine \n");
}

/*******************************************************************************
*   snetChtIngressL2MllEngineVer1
*
* DESCRIPTION:
*       Ingress L2 MLL engine - version 1 (xCat-C0)
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:   code based on snetCht3IngressMllReplication
*
*******************************************************************************/
static GT_VOID snetChtIngressL2MllEngineVer1
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngressL2MllEngineVer1);

    SKERNEL_FRAME_CHEETAH_DESCR_STC *origDescPtr;/* (pointer to)original descriptor info */
    GT_U32  index;/* index to a table */
    GT_U32  *memPtr;/*pointer to memory*/
    GT_U32  l2MllIndex;/* L2 MLL Index */
    GT_BOOL sendReplication; /* check if to send replication to current single
                                MLL , or skip it */
    GT_U32  origDescrFreeIndx;/* original number of descriptors used before starting the replications */
    SNET_CHT3_DOUBLE_MLL_STC mllEntry;/* L3 MLL entry format ! most of it is the same as L2 MLL format */
    SNET_CHT3_SINGLE_MLL_STC *singleMllPtr; /* pointer to the info about single
                                            L3 MLL (first/second half of the pair) most of it is the same as L2 MLL format*/
    GT_U32  ii;/* iterator */
    GT_U32  unkUcFilter,unkMcFilter,bcFilter;   /* L2Mll specific fields*/
    GT_U32  meshId;                             /* L2Mll specific fields*/
    GT_U32  localSwitchingEnable;               /* L2Mll specific fields*/
    GT_U32  isAps1Plus1LogicalPort;/*L2Mll specific fields .
                        Used for Source filtering on UNI-PW when duplication is done for 1+1 protection
                        0x0 = NonProtection_1Plus1; NonProtection_1Plus1; This duplication is not for 1+1 protection;
                        0x1 = Protection_1Plus1; Protection_1Plus1; This duplication is done for 1+1 protection;   */
    GT_U32  localSwitchingPortMask;/* mask on the port when do local switching to support 1+1 protection */

    GT_U32  bitsOffset;/* bits offset*/

    if(descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E &&
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_TO_TRG_SNIFFER_E )
    {
        return;
    }

    if(devObjPtr->vplsModeEnable.mll == 0 ||
       descrPtr->validMll == 1 ||
       descrPtr->tunnelStart == 1 ||
       descrPtr->routed == 1)
    {
        /* not triggering the L2Mll format */
        __LOG(("not triggering the L2Mll format"));
        return;
    }

    if(descrPtr->useVidx)
    {
        /*If (Enable L2MLL table entry==1) DescOut<MLLPtr>=InDesc<VIDX>*/
        index = descrPtr->eVidx / 32;/* each entry hold 32 L2MllEn bits*/

        memPtr = smemMemGet(devObjPtr,SMEM_XCAT_L2_MLL_VIDX_TO_MLL_MAPPING_TBL_MEM(devObjPtr,index));

        if( 0 ==  SMEM_U32_GET_FIELD(memPtr[0],(descrPtr->eVidx & 0x1f) , 1))
        {
            /* the L2Mll not enabled for this vidx */
            __LOG(("the L2Mll not enabled for this vidx"));
            return;
        }
        /*VIDX value is used as MLLPtr*/
        l2MllIndex = descrPtr->eVidx;
    }
    else   /* used for supporting 1+1 protection of unicast packets*/
    {
        if(descrPtr->targetIsTrunk)
        {
            return;
        }
        /*Map {TrgDev, TrgPort} to DescOut<MLLPtr> using Virtual Port to MLL mapping table*/

        if(descrPtr->trgDev & 0xFFFFFFF0)
        {
            /*If TrgDev[4]==1 then DescOut<MLLPtr> is set to 0x0 (NULL)*/
            return;
        }

        index = (descrPtr->trgEPort & 0x3f) | /* 6 bits from the target port */
                (descrPtr->trgDev & 0xf) << 6;/* 4 bits from the target device */

        memPtr = smemMemGet(devObjPtr,SMEM_XCAT_L2_MLL_VIRTUAL_PORT_TO_MLL_MAPPING_TBL_MEM(devObjPtr,index));

        /*Table entry is the new DescOut<MLLPtr> except when entry value is 0x0 (NULL)*/
        l2MllIndex = memPtr[0];

        if(l2MllIndex == 0)
        {
            return;
        }
    }

    /* duplicate descriptor from the ingress core */
    origDescPtr = snetChtEqDuplicateDescr(descrPtr->ingressDevObjPtr,descrPtr);

    /* save the number of used descriptors after the general duplication */
    origDescrFreeIndx = devObjPtr->descrFreeIndx;

    /**************************/
    /* start the replications */
    /**************************/

    while(1)
    {
        snetCht3ReadMllEntry(devObjPtr,l2MllIndex,&mllEntry);

        memPtr = smemMemGet(devObjPtr,SMEM_CHT3_ROUTER_MULTICAST_LIST_TBL_MEM(devObjPtr,l2MllIndex));

        /* check the 2 MLL sections */
        __LOG(("check the 2 MLL sections"));
        for(ii = 0 ; ii < 2 ; ii++)
        {
            sendReplication = GT_TRUE;
            if(ii == 0)
            {
                singleMllPtr = &mllEntry.first_mll;
            }
            else
            {
                singleMllPtr = &mllEntry.second_mll;
            }

            bitsOffset = (64*ii);

            unkUcFilter  =   snetFieldValueGet(memPtr,2 + bitsOffset ,1);
            unkMcFilter  =   snetFieldValueGet(memPtr,3 + bitsOffset ,1);
            bcFilter     =   snetFieldValueGet(memPtr,4 + bitsOffset ,1);
            meshId       =   snetFieldValueGet(memPtr,5 + bitsOffset ,2);
            isAps1Plus1LogicalPort  = snetFieldValueGet(memPtr,7 + bitsOffset ,1);

            localSwitchingEnable    = snetFieldValueGet(memPtr,50 + bitsOffset ,1);

            if(meshId)
            {
                if(meshId == descrPtr->vplsInfo.srcMeshId)
                {
                    /*if matching MLL action entry<meshId> descriptor is not duplicated. Used for split horizon filtering */
                    __LOG(("if matching MLL action entry<meshId> descriptor is not duplicated. Used for split horizon filtering"));
                    sendReplication = GT_FALSE;
                }
            }

            if(localSwitchingEnable == 0)
            {
                localSwitchingPortMask = isAps1Plus1LogicalPort ?
                                        0xFFFFFFFE :/* bit 0 is not in the mask */
                                        0xFFFFFFFF; /* all bits are in the mask */

                if((singleMllPtr->lll.dstInterface ==  SNET_DST_INTERFACE_PORT_E) &&
                    ((singleMllPtr->lll.interfaceInfo.devPort.port & localSwitchingPortMask) == (descrPtr->bridgeToMllInfo.virtualSrcPort & localSwitchingPortMask) &&
                    (singleMllPtr->lll.interfaceInfo.devPort.devNum == descrPtr->bridgeToMllInfo.virtualSrcDev)))
                {
                    /* came from the {dev,port} that need to send to it --> filter it */
                    __LOG(("came from thedev,port} that need to send to it --> filter it"));
                    sendReplication = GT_FALSE;
                }
            }


            /* check replication for the unknown/unregistered traffic */
            if(descrPtr->egressFilterRegistered == 0)
            {
                switch(descrPtr->macDaType)
                {
                    case SKERNEL_UNICAST_MAC_E:
                        if(unkUcFilter)
                        {
                            sendReplication = GT_FALSE;
                        }
                        break;
                    case SKERNEL_MULTICAST_MAC_E:
                        if(unkMcFilter)
                        {
                            sendReplication = GT_FALSE;
                        }
                        break;
                    default:/* BC traffic */
                        if(bcFilter)
                        {
                            sendReplication = GT_FALSE;
                        }
                        break;
                }
            }

            if(sendReplication == GT_TRUE)
            {
                /* the vid is not part of the L2Mll entry ! */
                singleMllPtr->vid = descrPtr->eVid;

                /* set the target outLif into descriptor - for single MLL
                   and Update mll counters */
                snetCht3IngressMllSingleMllOutlifSet(devObjPtr, descrPtr,singleMllPtr);

                /* send the replication down the pipe */
                snetChtEq(devObjPtr, descrPtr);

                simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_MLL_E);

                /* restore values of the descriptor */
                *descrPtr = *origDescPtr;

                /* restore the number of used descriptors in the device */
                devObjPtr->descrFreeIndx = origDescrFreeIndx;

                /*******************/
                /* end replication */
                /*******************/
            }

            if (singleMllPtr->last == 1)
            {
                 break;
            }
        }

        if(mllEntry.nextPtr == 0)
        {
            /* NOTE : we should not get here because the second section of MLL
                should have been set to singleMllPtr->last = 0 */
            break;
        }
        /* update the address for the next MLL */
        l2MllIndex = mllEntry.nextPtr;
    }

    /*NOTE: the original descriptor should not be flooded !*/
    /*assigned a HARD_DROP packet*/
    snetChtIngressCommandAndCpuCodeResolution(devObjPtr,descrPtr,
                                              descrPtr->packetCmd,
                                              SKERNEL_EXT_PKT_CMD_HARD_DROP_E,
                                              descrPtr->cpuCode,
                                              0,/*don't care*/
                                              SNET_CHEETAH_ENGINE_UNIT_L2MLL_E,
                                              GT_TRUE);


    return;
}


/*******************************************************************************
*   snetLion3IngressMllAccessCheck
*
* DESCRIPTION:
*       Lion3 : check that IP/L2 MLL is not access out of range.
*               generate interrupt in case of access violation.
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*       usedForIp       - GT_TRUE  - used for IP-MLL
*                         GT_FALSE - used for L2-MLL
*       index           - index into the MLL table
* OUTPUT:
*
* RETURN:
*       indication that did error.
*       GT_TRUE  - error (access out of range) , and interrupt was generated.
*                   the MLL memory should NOT be accessed
*       GT_FALSE - no error , can continue MLL processing.
*
* COMMENTS:
*
*******************************************************************************/
GT_BOOL snetLion3IngressMllAccessCheck
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr,
    IN GT_BOOL      usedForIp,
    IN GT_U32       index
)
{
    DECLARE_FUNC_NAME(snetLion3IngressMllAccessCheck);

    GT_U32  typeIndex = (usedForIp == GT_TRUE) ? 0 : 1;
    GT_BOOL error = GT_FALSE;
    GT_CHAR *typeNameArr[2] = { "IP-MLL" , "L2-MLL" };
    GT_CHAR *typeNamePtr = typeNameArr[typeIndex];
    GT_U32  interruptBitIndexArr[2] = {1,2};/* bit in register : MLL Interrupt Cause Register*/
    GT_U32  regAddr;
    GT_U32  regValue;
    GT_U32  limit;

    if(usedForIp == GT_TRUE)
    {
        regAddr = SMEM_LION3_MLL_IP_MLL_TABLE_RESOURCE_SHARING_CONFIG_REG(devObjPtr);
    }
    else
    {
        regAddr = SMEM_LION3_MLL_L2_MLL_TABLE_RESOURCE_SHARING_CONFIG_REG(devObjPtr);
    }

    smemRegGet(devObjPtr, regAddr,&regValue);
    /*<L2 MLL Table Invalid Access Check Enable>*/
    if(SMEM_U32_GET_FIELD(regValue,17,1))
    {
        __LOG(("%s Table Invalid Access Check Enabled \n",
            typeNamePtr));

        limit = SMEM_U32_GET_FIELD(regValue,0,16);
        /*Determines whether <L2 MLL Pointer Limit> is used as an upper limit (max), or a lower limit (min)*/
        /*<L2 MLL Access Check MinMax>*/
        if(SMEM_U32_GET_FIELD(regValue,16,1))
        {
            /*Max; <L2 MLL Pointer Limit> is used as an upper limit*/
            __LOG(("< %s MLL Pointer Limit> is used as an upper limit \n",
                typeNamePtr));

            if(index > limit)
            {
                /* limit error */
                error = GT_TRUE;
                __LOG(("ERROR : %s limit error : index[%x] > max[%x] \n",
                    typeNamePtr,
                    index,
                    limit));
            }
        }
        else
        {
            /*Min; <L2 MLL Pointer Limit> is used as a lower limit*/
            __LOG(("< %s MLL Pointer Limit> is used as a lower limit \n",
                typeNamePtr));
            if(index < limit)
            {
                /* limit error */
                error = GT_TRUE;
                __LOG(("ERROR : %s limit error : index[%x] < min[%x] \n",
                    typeNamePtr,
                    index,
                    limit));
            }
        }
    }

    if(error == GT_TRUE)
    {
        /* generate interrupt */
        __LOG(("Generate interrupt %s access violation: in MLL Interrupt Cause Register \n",
            typeNamePtr));
        snetChetahDoInterrupt(devObjPtr,
                              SMEM_LION3_MLL_INTERRUPT_CAUSE_REG(devObjPtr),
                              SMEM_LION3_MLL_INTERRUPT_MASK_REG(devObjPtr),
                              (1 << interruptBitIndexArr[typeIndex]),
                              (GT_U32)(1<<31));/* dummy index in global register */
    }

    return error;
}


/*******************************************************************************
*   snetChtIngressL2MllEngine
*
* DESCRIPTION:
*       Ingress L2 MLL engine
*
* INPUTS:
*       devObjPtr       - pointer to device object
*       descrPtr        - pointer to frame descriptor
*
* OUTPUT:
*
* RETURN:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtIngressL2MllEngine
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtIngressL2MllEngine);

    SKERNEL_FRAME_CHEETAH_DESCR_STC *previousDescPtr;/* (pointer to)'previous' descriptor info */
    SKERNEL_FRAME_CHEETAH_DESCR_STC *nextDescPtr;/* (pointer to)'next' descriptor info */
    SKERNEL_FRAME_CHEETAH_DESCR_STC *origDescPtr;/* (pointer to)original descriptor info */
    GT_U32  enableMllLookupForAllEVidx = 0;/* Enable MLL Lookup for All eVIDX */
    GT_U32  l2MllLttIndex = 0;/* index to the LTT table (of L2MLL) */
    GT_U32  *memPtr;/*pointer to memory*/
    GT_U32  l2MllIndex;/* L2 MLL Index */
    GT_U32  entrySelector;/* the L2 MLL entry hold 2 parts : 0,1.*/
    GT_U32  maskBitmap;/*mask bitmap from the L2Mll entry*/
    GT_U32  egressMeshId;/* meshId from the L2Mll entry */
    GT_BIT  filterEnable;/* UC/MC/BC filter - from the L2Mll entry*/
    GT_U32  ttlThreshold;/*ttl Threshold - from the L2Mll entry*/
    GT_U32  last;/* indication that last replication*/
    GT_U32  mllMaskProfile;/* MLL Mask Profile */
    GT_U32  value,value2;/*field value*/
    GT_BOOL sendReplication; /* check if to send replication to current single
                                MLL , or skip it */
    GT_BIT  TTL_EXCEPTION_FLAG;
    GT_BIT  targetIsTrunk;/* mll target is trunk ?*/
    GT_BIT  targetIsVidx; /* mll target is vidx ?*/
    GT_U32  targetEPort=0;  /* mll target eport */
    GT_U32  targetDevice=0; /* mll target device */
    GT_U32  targetTrunkID=0;/* mll target trunk */
    GT_U32  targetVidx=0;   /* mll target vidx */
    GT_U32 globalEPortVal;/*Value for Global ePort. Refer to Global ePort logic below*/
    GT_U32 globalEPortMask;/*"0" masks the corresponding bit in the <GLOBALePortVal>*/
    GT_BOOL didAnyReplication = GT_FALSE;/*No Replication There is a corner case where a packet
            accesses the L2 MLL and does not trigger any replications.
            This is possible if all the elements in the linked list are masked out, or if all copies are filtered.
            In these cases the original descriptor is assigned a SOFT_DROP packet command and forwarded to the EQ.*/
    GT_U32  origDescrFreeIndx;/* original number of descriptors used before starting the replications */
    GT_U32  ingressMeshId;/* mesh id for this packet */
    GT_U32  meshIdOffset;/* offset from sstId to use for ingressMeshId */
    GT_U32  meshIdSize;/* number of bits from sstId to use for ingressMeshId */
    GT_U32  ePortMaskForSrcFilter;/*mask on the ePort when doing SRC filtering */
    GT_CHAR *srcFilterReasonNameArr[2] = {"MC local switching filtering" , "One Plus One Filtering"};
    GT_CHAR *srcFilterReasonNamePtr;
    GT_BIT  mcLocalSwitchingEnable;/*Determines whether traffic can be replicated to the source ePort, i.e., if the source {dev,ePort}
                                    is equal to the {dev,ePort} in this entry, then <MCLocalSwitchingEnable>
                                    determines wether the packet is replicated or not*/
    GT_U32  srcFilter_isTrunk;/* the isTrunk to use for src filtering */
    GT_U32  srcFilter_portTrunk;/* the port/trunk to use for src filtering */
    GT_U32  srcFilter_device;/* the device to use for src filtering */
    GT_U32  isLastReplication;/*indication that this is last replication of the MLL unit */
    GT_BIT  nextReplicationExists = GT_FALSE;/* there is at least one more L2Mll replication */


    switch(devObjPtr->l2MllVersionSupport)
    {
        case 0:
            /* those are legacy devices (that are not xCat-C0)*/
            return;
        case 1:
            /* do the xCat-C0 L2 MLL */
            __LOG(("do the xCat-C0 L2 MLL"));
            snetChtIngressL2MllEngineVer1(devObjPtr,descrPtr);
            return;
        default:
            /* this is SIP5 device */
            break;
    }

    /* by default the vidx is 12 LSB of the eVidx*/
    descrPtr->eArchExtInfo.vidx = SMEM_U32_GET_FIELD(descrPtr->eVidx,0,12);

    if(descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E &&
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E &&
       descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FROM_CPU_E )
    {
        return;
    }

    if(descrPtr->useVidx == 0)
    {
        return;
    }

    smemRegFldGet(devObjPtr, SMEM_LION3_MLL_LOOKUP_TRIGGER_CONFIG_REG(devObjPtr), 0, 13, &value);

    enableMllLookupForAllEVidx = SMEM_U32_GET_FIELD(value,12,1);

    __LOG_PARAM(enableMllLookupForAllEVidx);

    if(enableMllLookupForAllEVidx == 0)
    {
        value &= 0xfff;

        if(descrPtr->eVidx < (value + 1))
        {
            /* this is considered as VIDX and not as eVIDX */
            return;
        }

        l2MllLttIndex = descrPtr->eVidx - (value + 1);
    }
    else
    {
        l2MllLttIndex = descrPtr->eVidx;
    }

    __LOG_PARAM(l2MllLttIndex);

    smemRegGet(devObjPtr, SMEM_LION3_MLL_SOURCE_BASED_L2_MLL_FILTERING_REG(devObjPtr), &value);
    meshIdOffset = SMEM_U32_GET_FIELD(value,0,4);
    meshIdSize   = SMEM_U32_GET_FIELD(value,4,4);

    __LOG_PARAM(meshIdOffset);
    __LOG_PARAM(meshIdSize);


    if(meshIdOffset > 11)
    {
        __LOG(("Global Config: ERROR <meshIdOffset>[%d] > 11 \n",
            meshIdOffset));
    }
    else if (meshIdSize > 8)
    {
        __LOG(("Global Config: ERROR <meshIdSize>[%d] > 8 \n",
            meshIdSize));
    }

    ingressMeshId = SMEM_U32_GET_FIELD(descrPtr->sstId,meshIdOffset,meshIdSize);
    __LOG_PARAM(ingressMeshId);
    if(ingressMeshId)
    {
        __LOG(("calculated ingressMeshId according SST-ID and global config is [%d]",ingressMeshId));
    }


    /* the eVidx >= 4K or enableMllLookupForAllEVidx == 1 -->
       use the eVidx (or eVidx-4K) as LTT index */

    memPtr = smemMemGet(devObjPtr,SMEM_LION3_L2_MLL_LTT_TBL_MEM(devObjPtr,l2MllLttIndex));

    /* L2 MLL Index */
    entrySelector = snetFieldValueGet(memPtr,0,1);
    l2MllIndex = snetFieldValueGet(memPtr,1,15);
    /* MLL Mask Profile */
    mllMaskProfile = snetFieldValueGet(memPtr,16,4);

    __LOG_PARAM(entrySelector);
    __LOG_PARAM(l2MllIndex);
    __LOG_PARAM(mllMaskProfile);


    smemRegGet(devObjPtr, SMEM_LION3_L2_MLL_GLOBAL_E_PORT_REG(devObjPtr), &value);
    globalEPortVal = SMEM_U32_GET_FIELD(value,0,20);
    smemRegGet(devObjPtr, SMEM_LION2_L3_MLL_GLOBAL_E_PORT_MASK_REG(devObjPtr) , &value);
    globalEPortMask = SMEM_U32_GET_FIELD(value,0,20);

    __LOG_PARAM(globalEPortVal);
    __LOG_PARAM(globalEPortMask);

    /* 'orig descriptor' : duplicate descriptor from the ingress core */
    origDescPtr = snetChtEqDuplicateDescr(descrPtr->ingressDevObjPtr,descrPtr);
    /* 'next replication' : duplicate descriptor from the ingress core */
    nextDescPtr = snetChtEqDuplicateDescr(descrPtr->ingressDevObjPtr,descrPtr);
    /* 'previous replication' : duplicate descriptor from the ingress core */
    previousDescPtr = snetChtEqDuplicateDescr(descrPtr->ingressDevObjPtr,descrPtr);

    /* save the number of used descriptors after the general duplication */
    origDescrFreeIndx = devObjPtr->descrFreeIndx;

    TTL_EXCEPTION_FLAG = 0;

    /* build the info needed for 'src filterring' */
    if(descrPtr->packetCmd == SKERNEL_EXT_PKT_CMD_FROM_CPU_E)
    {
        /*from_cpu :  MC excluded filtering for FromCpu */
        srcFilter_isTrunk   = descrPtr->excludeIsTrunk;
        srcFilter_portTrunk = descrPtr->excludeIsTrunk ?
                                    descrPtr->excludedTrunk :
                                    descrPtr->excludedPort;
        srcFilter_device    = descrPtr->excludedDevice;

        if(srcFilter_isTrunk == 0 && descrPtr->eArchExtInfo.fromCpu.excludedIsPhyPort == 1)
        {
            /* set values to make sure 'no match' of the ePort */
            srcFilter_portTrunk = 0xFFFFFFFF;
        }

    }
    else
    {
        /* forward / mirrorToCpu : MC local switching filtering */
        srcFilter_isTrunk   = descrPtr->origIsTrunk;
        srcFilter_portTrunk = descrPtr->origSrcEPortOrTrnk;
        srcFilter_device    = descrPtr->srcDev;
    }

    __LOG_PARAM(srcFilter_isTrunk);
    __LOG_PARAM(srcFilter_portTrunk);
    __LOG_PARAM(srcFilter_device);


    __LOG(("Start L2 MLL replications \n"));


    do
    {
        sendReplication = GT_FALSE;

        if(GT_TRUE ==
            snetLion3IngressMllAccessCheck(devObjPtr,descrPtr,GT_FALSE,l2MllIndex))
        {
            /* the l2MllIndex is 'out of range' */
            break;
        }

        memPtr = smemMemGet(devObjPtr,SMEM_CHT3_ROUTER_MULTICAST_LIST_TBL_MEM(devObjPtr,l2MllIndex));

        targetIsVidx =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_USE_VIDX_0);

        if(targetIsVidx == 0)
        {
            targetIsTrunk =
                SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                    entrySelector ?
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_1:
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_TARGET_IS_TRUNK_0);

            if(targetIsTrunk)
            {
                targetTrunkID =
                    SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                        entrySelector ?
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_1:
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_TRUNK_ID_0);
            }
            else
            {
                targetEPort =
                    SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                        entrySelector ?
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_1:
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_EPORT_0);
                targetDevice =
                    SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                        entrySelector ?
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_1:
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_TRG_DEV_0);

                if(targetEPort == SNET_CHT_NULL_PORT_CNS)
                {
                    goto nextMllPointer_lbl;
                }
            }
        }
        else
        {
            targetVidx =
                SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                    entrySelector ?
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_1:
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_VIDX_0);

            targetIsTrunk = 0;
        }

        maskBitmap =
                SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                    entrySelector ?
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_1:
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_MASK_BITMAP_0);

        /*Mask Bitmap*/
        if (mllMaskProfile && (0 == (maskBitmap & (1 << (mllMaskProfile - 1)))))
        {
            goto nextMllPointer_lbl;
        }

        /* check replication for the unknown/unregistered traffic */
        switch(descrPtr->macDaType)
        {
            case SKERNEL_UNICAST_MAC_E:
                /*Unknown UC Filter Enable*/
                filterEnable =
                    SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                        entrySelector ?
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_1:
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_UNKNOWN_UC_FILTER_ENABLE_0);
                if(descrPtr->egressFilterRegistered == 0 && filterEnable)
                {
                    __LOG(("Unknown UC Filter Enable"));
                    goto nextMllPointer_lbl;
                }
                break;
            case SKERNEL_MULTICAST_MAC_E:
                /*Unregistered MC Filter Enable*/
                filterEnable =
                    SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                        entrySelector ?
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_1:
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_UNREGISTERED_MC_FILTER_ENABLE_0);
                if(descrPtr->egressFilterRegistered == 0 && filterEnable)
                {
                    __LOG(("Unregistered MC Filter Enable"));
                    goto nextMllPointer_lbl;
                }
                break;
            default:/* BC traffic */
                /*BC Filter Enable*/ /* NOTE: also for registered BC */
                filterEnable =
                    SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                        entrySelector ?
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_1:
                            SMEM_LION3_L2_MLL_TABLE_FIELDS_BC_FILTER_ENABLE_0);
                if(filterEnable)
                {
                    __LOG(("BC Filter Enable(also for registered BC)"));
                    goto nextMllPointer_lbl;
                }
                break;
        }

        egressMeshId =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_MESH_ID_0);

        if(ingressMeshId)
        {
            if(egressMeshId == ingressMeshId)
            {
                /*if matching MLL action entry<meshId> descriptor is not duplicated. Used for split horizon filtering */
                __LOG(("Source-based (Split Horizon) Filtering on meshId [%d] \n",
                    ingressMeshId));
                goto nextMllPointer_lbl;
            }
        }

        ttlThreshold =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_TTL_THRESHOLD_0);

        /*TTL Threshold*/
        if(descrPtr->ttl < ttlThreshold)
        {
            __LOG(("failed to pass TTL Threshold [%d] < [%d] \n",
                descrPtr->ttl,ttlThreshold));
            TTL_EXCEPTION_FLAG = 1;
            goto nextMllPointer_lbl;
        }

        mcLocalSwitchingEnable =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_MC_LOCAL_SWITCHING_ENABLE_0);

        /*MC local switching Enable*/
        if(mcLocalSwitchingEnable == 0 && (targetIsVidx == 0))
        {
            filterEnable =
                SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                    entrySelector ?
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_1:
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_ONE_PLUS_ONE_FILTERING_ENABLE_0);
            if(filterEnable)
            {
                /* When enabled, and <MC Local Switching Enable> is disabled,
                   source filtering ignores the least significant bit of the ePort.
                   The assumption is that the two ePorts in the 1+1 scheme are two
                   contiguous ePort numbers, that differ only in the lsbit.*/

                __LOG(("One Plus One Filtering Enabled --> do source filtering and ignore the least significant bit of the ePort \n"));

                ePortMaskForSrcFilter = 0xFFFFFFFE;/* ignore the LSBit*/
                srcFilterReasonNamePtr = srcFilterReasonNameArr[1];
            }
            else
            {
                ePortMaskForSrcFilter = 0xFFFFFFFF;
                srcFilterReasonNamePtr = srcFilterReasonNameArr[0];
            }

            if(targetIsTrunk == 0)
            {   /* target is EPort */
                if(srcFilter_isTrunk == 0 && /* src not from trunk (from DSA/not)*/
                   (srcFilter_portTrunk & ePortMaskForSrcFilter) == (targetEPort & ePortMaskForSrcFilter)) /* src Eport == target EPORT */
                {
                    if((targetEPort & globalEPortMask) == globalEPortVal) /*global port not need to check <device> */
                    {
                        __LOG(("%s - filter this Target global ePort [%x] \n",
                        srcFilterReasonNamePtr,
                        targetEPort));
                        goto nextMllPointer_lbl;
                    }
                    else if(srcFilter_device == targetDevice)/* not global port so need to check <device>*/
                    {
                        __LOG(("%s - filter this Target ePort [%x] in device[%x] \n",
                            srcFilterReasonNamePtr,
                            targetEPort,
                            targetDevice));
                        goto nextMllPointer_lbl;
                    }
                }
            }
            else /*targetIsTrunk == 1*/
            {
                if(srcFilter_isTrunk == 1 && /* src from trunk (from DSA/not)*/
                   srcFilter_portTrunk == targetTrunkID) /* src trunk == target trunk */
                {
                    __LOG(("%s - filter this Target trunk [%x] \n",
                        srcFilterReasonNamePtr,
                        targetTrunkID));
                    goto nextMllPointer_lbl;
                }
            }
            __LOG(("MC local switching Disabled (but there was NO SRC filtering match) \n"));
        }
        else
        {
            __LOG(("MC local switching Enabled (so NO SRC filtering attempt) \n"));
        }

        sendReplication = GT_TRUE;
        /*********************/
        /* start replication */
        /*********************/
        if(descrPtr->packetCmd != SKERNEL_EXT_PKT_CMD_FROM_CPU_E)
        {
            /* the replication must be 'forward' unless orig is 'from_cpu' */
            __LOG(("the replication must be 'forward' unless orig is 'from_cpu' \n"));
            nextDescPtr->packetCmd = SKERNEL_EXT_PKT_CMD_FORWARD_E;
        }
        nextDescPtr->analyzerIndex = 0;/* must be 0 in all replications other then 'last one' */

        nextDescPtr->eArchExtInfo.isTrgPhyPortValid = 0;
        /* assign egress interface */
        __LOG(("assign egress interface"));
        if(targetIsTrunk == 0 && targetIsVidx == 0)
        {
            nextDescPtr->trgEPort = targetEPort;
            nextDescPtr->trgDev = targetDevice;
            nextDescPtr->useVidx = 0;
            nextDescPtr->targetIsTrunk = 0;
        }
        else if (targetIsTrunk == 1)
        {
            nextDescPtr->trgTrunkId = targetTrunkID;
            nextDescPtr->useVidx = 0;
            nextDescPtr->targetIsTrunk = 1;
        }
        else if (targetIsVidx == 1)
        {
            nextDescPtr->useVidx = 1;
            /*descrPtr->eVidx = targetVidx; no eVidx modification (should save it for the DSA tagging)*/
            nextDescPtr->eArchExtInfo.vidx = targetVidx;
            nextDescPtr->targetIsTrunk = 0;
        }

        value =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_HOP_COUNT_ENABLE_0);
        /*Max Hop Count Enable*/
        if(value)
        {
            value =
                SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                    entrySelector ?
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_1:
                        SMEM_LION3_L2_MLL_TABLE_FIELDS_MAX_OUTGOING_HOP_COUNT_0);
            /*Max Outgoing Hop Count*/
            if(descrPtr->ttl > value)
            {
                nextDescPtr->ttl = value;
            }
        }

        /*Bind To MLL Counter*/
        value =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_BIND_TO_MLL_COUNTER_0);

        if(value)
        {
            __LOG(("Bind To MLL Counter[%d]",value));

            smemRegGet(devObjPtr, SMEM_LION3_L2_MLL_VALID_PROCESSED_ENTRIES_COUNTER_REG(devObjPtr, value) , &value2);
            value2++;/*value of the counter*/
            smemRegSet(devObjPtr, SMEM_LION3_L2_MLL_VALID_PROCESSED_ENTRIES_COUNTER_REG(devObjPtr, value) , value2);
        }


        if(nextReplicationExists == GT_TRUE)
        {
            if(simLogIsOpen())
            {
                /*restore original values for the 'compare' of descriptors 'old and new'*/
                *descrPtr = *origDescPtr;
            }

            /* because there is at least one more replication ,
               it means that this is not the 'last' replication */
            SIM_LOG_PACKET_DESCR_SAVE

            *descrPtr = *previousDescPtr;

            SIM_LOG_PACKET_DESCR_COMPARE("L2MllEngine replication ('NON last' replication) \n");

            /* Update L2 mll counters */
            __LOG(("Update L2_MLL counters \n"));
            snetCht3mllCounters(devObjPtr, descrPtr , GT_TRUE/*count L2 MLL (not IP MLL)*/);

            /* send the replication down the pipe */
            __LOG(("send the replication to EQ (only after assured that this is 'NOT LAST' replication) \n"));
            snetChtEq(devObjPtr, descrPtr);

            simLogPacketFrameUnitSet(SIM_LOG_FRAME_UNIT_MLL_E);

            /* restore the number of used descriptors in the device */
            devObjPtr->descrFreeIndx = origDescrFreeIndx;

            /* restore values of the descriptor */
            *descrPtr = *origDescPtr;
        }

        /* save the 'next' one info , as 'previous' */
        nextReplicationExists = GT_TRUE;
        *previousDescPtr = *nextDescPtr;

        /*******************/
        /* end replication */
        /*******************/

        didAnyReplication = GT_TRUE;

nextMllPointer_lbl:
        if(sendReplication == GT_FALSE)
        {
            /* count the number of MLLs that not send replications */
            __LOG(("Increment the 'Skip Counter' of the number of MLLs that not send replications \n"));
            smemRegGet(devObjPtr, SMEM_LION3_L2_MLL_EXCEPTION_COUNTER_SKIP_COUNTER_REG(devObjPtr) , &value);
            value++;/*value of the counter*/
            smemRegSet(devObjPtr, SMEM_LION3_L2_MLL_EXCEPTION_COUNTER_SKIP_COUNTER_REG(devObjPtr) , value);
        }

        /*last*/
        last =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                entrySelector ?
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_1:
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_LAST_0);

        if(last == 1)
        {
            /* this was the last replication by the L2Mll */
            break;
        }

        if(entrySelector == 0)
        {
            /* use now the second part of the entry */
            entrySelector++;
            continue;
        }

        /* get the entry section to use after we jump to new entry */
        /* we can update 'next' entrySelector only after all field already updated
           with 'currnt' entrySelector */
        entrySelector =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                SMEM_LION3_L2_MLL_TABLE_FIELDS_ENTRY_SELECTOR);

        /* Next MLL Pointer */
        l2MllIndex =
            SMEM_LION3_L2_MLL_ENTRY_FIELD_GET(devObjPtr,memPtr,l2MllIndex,
                    SMEM_LION3_L2_MLL_TABLE_FIELDS_L2_NEXT_MLL_PTR);

    }
    while(1);

    __LOG(("L2 MLL replications Ended \n"));

    __LOG_PARAM(TTL_EXCEPTION_FLAG);

    /* TTL Exception affects only that last copy that is not skipped.*/
    if(TTL_EXCEPTION_FLAG)
    {
        smemRegGet(devObjPtr, SMEM_LION3_L2_MLL_EXCEPTION_COUNTER_TTL_EXCEPTION_COUNTER_REG(devObjPtr) , &value);
        value++;/*value of the counter*/
        smemRegSet(devObjPtr, SMEM_LION3_L2_MLL_EXCEPTION_COUNTER_TTL_EXCEPTION_COUNTER_REG(devObjPtr) , value);
    }

    __LOG_PARAM(didAnyReplication);

    if(didAnyReplication == GT_TRUE)
    {
        /* indication that we not send the 'last' replication !
        and the info is in nextDescPtr / previousDescPtr */

        SIM_LOG_PACKET_DESCR_SAVE

        *descrPtr = *previousDescPtr;

        isLastReplication = 1;

        __LOG_PARAM(origDescPtr->ipm);
        if(origDescPtr->ipm)
        {
            __LOG_PARAM(origDescPtr->routed);
            if(origDescPtr->routed == 1)
            {
                /* this is NOT the last copy of the IP_MLL */
                isLastReplication = 0;
            }
        }

        __LOG_PARAM(isLastReplication);

        if(isLastReplication == 0)
        {
            /* this is NOT the last copy of the IP_MLL , so we NOT allow the mirrorIndex */
            descrPtr->analyzerIndex = 0;
        }
        else
        {
            /* use the original analyzer index */
            descrPtr->analyzerIndex = origDescPtr->analyzerIndex;
        }

        __LOG_PARAM(descrPtr->analyzerIndex);

        /* use the original command */
        descrPtr->packetCmd = origDescPtr->packetCmd;
        __LOG_PARAM(descrPtr->packetCmd);

        /* TTL Exception affects only that last copy that is not skipped.*/
        if(TTL_EXCEPTION_FLAG)
        {
            smemRegGet(devObjPtr, SMEM_LION3_L2_MLL_GLOBAL_TTL_EXCEPTION_CONFIG_REG(devObjPtr) , &value);
            if(SMEM_U32_GET_FIELD(value,8,1))
            {
                /* resolve packet command and CPU code */
                __LOG(("resolve packet command and CPU code"));
                snetChtIngressCommandAndCpuCodeResolution(devObjPtr,descrPtr,
                                                          descrPtr->packetCmd,
                                                          SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E,
                                                          descrPtr->cpuCode,
                                                          SMEM_U32_GET_FIELD(value,0,8),/*CPU code*/
                                                          SNET_CHEETAH_ENGINE_UNIT_L2MLL_E,
                                                          GT_TRUE);
            }
        }

        SIM_LOG_PACKET_DESCR_COMPARE("L2MllEngine replication ('LAST' replication) \n");

        /* Update L2 mll counters */
        __LOG(("Update L2_MLL counters \n"));
        snetCht3mllCounters(devObjPtr, descrPtr , GT_TRUE/*count L2 MLL (not IP MLL)*/);

        /* send the replication down the pipe */
        __LOG(("send the replication to EQ (this is 'LAST' replication) \n"));

        /* restore the number of used descriptors in the device */
        devObjPtr->descrFreeIndx = origDescrFreeIndx;

        /* ... continue to the EQ ... */
        __LOG(("... continue to the EQ ... \n"));
    }
    else
    {
        memPtr = smemMemGet(devObjPtr, SMEM_LION3_L2_MLL_SILENT_DROP_COUNTER_REG(devObjPtr));
        __LOG(("increment l2 mll silent drop Counter from [%d]\n", *memPtr));
        (*memPtr)++;


        /*assigned a SOFT_DROP packet*/
        __LOG(("assigned a SOFT_DROP packet , because not did any replications (use original descriptor) \n"));
        snetChtIngressCommandAndCpuCodeResolution(devObjPtr,descrPtr,
                                                  descrPtr->packetCmd,
                                                  SKERNEL_EXT_PKT_CMD_SOFT_DROP_E,
                                                  descrPtr->cpuCode,
                                                  0,/*don't care*/
                                                  SNET_CHEETAH_ENGINE_UNIT_L2MLL_E,
                                                  GT_TRUE);
    }

    return;
}


/*******************************************************************************
*   snetChtCpuCodeResolution
*
* DESCRIPTION:
*       resolve from old and new commands the new packet cpu code / DROP code
*
* INPUTS:
*       devObjPtr       - (pointer to) device object.
*       descrPtr        - (pointer to) frame descriptor
*       prevCmd         - previous command
*       currCmd          current command
*       afterResolutionCmd - the command after the resolution
*       prevCpuCode     - previous cpu code
*       currCpuCode      current cpu code
* OUTPUTS:
*       descrPtr        - (pointer to) frame descriptor
*
* RETURN:
*       none
*
* COMMENTS:
*
*
*
*******************************************************************************/
static void snetChtCpuCodeResolution
(
    IN SKERNEL_DEVICE_OBJECT                    *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC       *descrPtr,
    IN SKERNEL_EXT_PACKET_CMD_ENT prevCmd,
    IN SKERNEL_EXT_PACKET_CMD_ENT currCmd,
    IN SKERNEL_EXT_PACKET_CMD_ENT afterResolutionCmd,
    IN GT_U32                prevCpuCode,
    IN GT_U32                currCpuCode
)
{


    GT_BOOL cpuCodeUpdated = GT_FALSE;
    enum _RESOLUTION_COMMAND_ENT{
        PREV_STRONGER_E,
        PREV_WEAKER_E,
        PREV_EQUAL_E,
    };
    GT_U32 resolutionCommand;
    static GT_U32 _resolutionCommands[5/*prev*/][5/*new*/] = {
/*prev*/ /*new*//* {CMD_FORWARD,     CMD_MIRROR,    CMD_TRAP,      CMD_HARD_DROP, CMD_SOFT_DROP} */
/*CMD_FORWARD,  */ {PREV_EQUAL_E,    PREV_WEAKER_E, PREV_WEAKER_E,    PREV_WEAKER_E, PREV_WEAKER_E},
/*CMD_MIRROR,   */ {PREV_STRONGER_E, PREV_EQUAL_E,  PREV_WEAKER_E,    PREV_WEAKER_E, PREV_STRONGER_E},
/*CMD_TRAP,     */ {PREV_STRONGER_E, PREV_STRONGER_E, PREV_EQUAL_E,   PREV_WEAKER_E, PREV_STRONGER_E},
/*CMD_HARD_DROP,*/ {PREV_STRONGER_E, PREV_STRONGER_E, PREV_STRONGER_E,PREV_EQUAL_E,  PREV_STRONGER_E},
/*CMD_SOFT_DROP,*/ {PREV_STRONGER_E, PREV_WEAKER_E, PREV_WEAKER_E,  PREV_WEAKER_E, PREV_EQUAL_E}
    };

    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        /* the device support CPU code for any non-forward command */
        if(afterResolutionCmd != SKERNEL_EXT_PKT_CMD_FORWARD_E)
        {
            resolutionCommand = _resolutionCommands[prevCmd][currCmd];

            /* If the previous command is 'stronger' than the current command:
               The CPU/Drop code is unchanged.*/
            if(resolutionCommand != PREV_STRONGER_E)
            {
                /* If the previous command is equal to the current command:
                   If the resulting command is not FORWARD, the CPU/Drop code is
                   changed to reflect the value of the current assignment.*/

                /*If the previous command is 'weaker' than the current command:
                 The CPU/Drop code is changed to reflect the value of the
                 current assignment.*/
                cpuCodeUpdated = GT_TRUE;
            }
        }
    }
    else if(afterResolutionCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E ||
            afterResolutionCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
    {
        /* the device support CPU codes only for 'trap'/'mirror' */
        if(currCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E)
        {
            cpuCodeUpdated = GT_TRUE;
        }
        else if(prevCmd == SKERNEL_EXT_PKT_CMD_TRAP_TO_CPU_E)
        {
        }
        else if(currCmd == SKERNEL_EXT_PKT_CMD_MIRROR_TO_CPU_E)
        {
            cpuCodeUpdated = GT_TRUE;
        }
    }

    if(currCpuCode > 0xFF)
    {
        /* the 'cpu code' is 8 bits in the register but some places in the logic
           there are '+' on the value read from the register.
           the simulation must recognize when value > 255 and notify into the LOG about it.
           anyway it should do cpuCode = (cpuCode & 0xff) */


        /* for example see: snetLion2TrillGeneralExceptionChecking , snetLion2TrillRbidTable
            snetLion3TTActionApplyMplsCwBasedPw */

        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("WARNING: The CPU code [0x%x] > 0xFF !!! meaning that logic of '+' added it to be value greater then 0xFF \n",
            currCpuCode));

        currCpuCode &= 0xFF;

        __LOG_NO_LOCATION_META_DATA__WITH_SCIB_LOCK(("The CPU code will be trimmed to 8 bits --> [0x%x] \n",
            currCpuCode));
    }

    if(cpuCodeUpdated == GT_FALSE || descrPtr->cpuCode == currCpuCode)
    {
        /*__LOG(("CPU code not changed \n"));*/
        return;
    }

    /* update the CPU code */
    descrPtr->cpuCode = currCpuCode;

    if(simLogIsOpen())
    {
        scibAccessLock();

        __LOG_NO_LOCATION_META_DATA(("prevCpuCode:"));
        simLogPacketDescrCpuCodeDump(devObjPtr,prevCpuCode);
        __LOG_NO_LOCATION_META_DATA(("\n"));

        __LOG_NO_LOCATION_META_DATA(("descrPtr->cpuCode:"));
        simLogPacketDescrCpuCodeDump(devObjPtr,descrPtr->cpuCode);
        __LOG_NO_LOCATION_META_DATA(("\n"));

        scibAccessUnlock();
    }
}


/*******************************************************************************
*   snetChtIngressCommandAndCpuCodeResolution
*
* DESCRIPTION:
*       1. resolve from old and current commands the new packet command
*       2. resolve from old and new commands the new packet cpu code (relevant
*          to copy that goes to CPU)
*
* INPUTS:
*       devObjPtr       - (pointer to) device object.
*       descrPtr        - (pointer to) frame descriptor
*       prevCmd         - previous command
*       currCmd          current command
*       prevCpuCode     - previous cpu code
*       currCpuCode      current cpu code
*       engineUnit      - the engine unit that need resolution with previous engine
*                         (isFirst = GT_TRUE) or need resolution with previous
*                         hit inside the same engine (isFirst = GT_FALSE)
*       isFirst - indication that the resolution is within the same engine or
*                         with previous engine
* OUTPUTS:
*       descrPtr        - (pointer to) frame descriptor
*
* RETURN:
*       none
*
* COMMENTS:
*
*
*
*******************************************************************************/
extern void snetChtIngressCommandAndCpuCodeResolution
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC   * descrPtr,
    IN SKERNEL_EXT_PACKET_CMD_ENT prevCmd,
    IN SKERNEL_EXT_PACKET_CMD_ENT currCmd,
    IN GT_U32                     prevCpuCode,
    IN GT_U32                     currCpuCode,
    IN SNET_CHEETAH_ENGINE_UNIT_ENT engineUnit,
    IN GT_BOOL                    isFirst
)
{
    DECLARE_FUNC_NAME(snetChtIngressCommandAndCpuCodeResolution);

    SKERNEL_PRECEDENCE_ORDER_ENT  cpuCodePrecedence = SKERNEL_PRECEDENCE_ORDER_HARD;/*CPU Code Precedence */
    GT_BOOL usePrecedence = GT_FALSE;
    GT_U32  value;/* tempo register value */
    GT_BOOL keepPreviousCpuCode;/* do we keep previous CPU code */

    if(engineUnit == SNET_CHEETAH_ENGINE_UNIT_PCL_E)
    {
        if(0 == SKERNEL_IS_XCAT_REVISON_A1_DEV(devObjPtr))
        {
            /* Policy Global Configuration Register */
            smemRegFldGet(devObjPtr, SMEM_CHT_PCL_GLOBAL_REG(devObjPtr), 5, 1, &value);
        }
        else
        {
            /* Policy Global Configuration Register */
            smemRegFldGet(devObjPtr,SMEM_XCAT_A1_TTI_UNIT_GLB_CONF_REG(devObjPtr), 6, 1, &value);
        }

        __LOG(("PCL cpuCodePrecedence [%s] \n" , (value == 0) ? "SKERNEL_PRECEDENCE_ORDER_HARD" : "SKERNEL_PRECEDENCE_ORDER_SOFT"));
        if(value == 0)
        {
            cpuCodePrecedence = SKERNEL_PRECEDENCE_ORDER_HARD;
        }
        else
        {
            cpuCodePrecedence = SKERNEL_PRECEDENCE_ORDER_SOFT;
        }

        usePrecedence = GT_TRUE;
    }

    /* when we use precedence , this is actually the precedence of
       previous inter-engine match */
    if((usePrecedence == GT_TRUE) &&
       (currCmd == prevCmd) &&
       (cpuCodePrecedence == SKERNEL_PRECEDENCE_ORDER_HARD) &&
       (isFirst == GT_FALSE))
    {
        keepPreviousCpuCode = GT_TRUE;
    }
    else
    {
        keepPreviousCpuCode = GT_FALSE;
    }

    /* Apply packet command */
    descrPtr->packetCmd = snetChtPktCmdResolution(prevCmd,currCmd);

    if(keepPreviousCpuCode == GT_FALSE)
    {
        /* allow to do resolution on the CPU/DROP code */
        snetChtCpuCodeResolution(devObjPtr,descrPtr,
            prevCmd,currCmd,descrPtr->packetCmd,
            prevCpuCode,currCpuCode);
    }

}

/*******************************************************************************
*   snetChtClassifyFlowControlPacket
*
* DESCRIPTION:
*        Flow Control Packet Recognition
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* RETURN:
*     SNET_NOT_FC_PACKET_E       -   Not FC packet
*     SNET_FC_PACKET_E           -   Valid FC packet
*     SNET_PFC_PACKET_E          -   Priority Flow control frame
*     SNET_UNKNOWN_FC_PACKET_E   -   Unknown MAC control frame
*
*******************************************************************************/
static SNET_FLOW_CONTROL_PACKET_TYPE_ENT snetChtClassifyFlowControlPacket
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr
)
{
    DECLARE_FUNC_NAME(snetChtClassifyFlowControlPacket);

    GT_U32 regAddr;                     /* Register address */
    GT_U32 * regPtr;                    /* Register pointer */
    GT_U32 fldValue;                    /* Register field value */
    SGT_MAC_ADDR_TYP portMacAddr;       /* Ports configured MAC Address */
    GT_U32 etherType;                   /* Flow Control Ethernet type */
    GT_U32 opCode;                      /* Flow Control OpCode */
    GT_BOOL isFcMac;                    /* Packets MAC DA is 01-80-C2-00-00-01 or the ports configured MAC Address */

    /* Flow Control Ethernet type */
    etherType = SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, 12);
    __LOG_PARAM(etherType);
    if(etherType != SNET_CHT_FC_ETHERTYPE)
    {
        if (SGT_MAC_ADDR_IS_PAUSE(descrPtr->macDaPtr))
        {
            /* even if etherType not match, the DA mac is enough to classify it as pause frame =>  ch3 HW behavior */
            __LOG(("recognized 'flow control packet' according to the MAC DA , even though ethertype is not [0x%x] \n",SNET_CHT_FC_ETHERTYPE));
            return SNET_FC_PACKET_E;
        }

        __LOG(("pack is not 'flow control' \n"));
        return SNET_NOT_FC_PACKET_E;
    }

    regAddr = SMEM_CHT_SRC_ADDRESS_MID_REG(devObjPtr);
    regPtr = smemMemGet(devObjPtr, regAddr);

    portMacAddr.bytes[4] = SMEM_U32_GET_FIELD(regPtr[0], 0, 8);
    portMacAddr.bytes[3] = SMEM_U32_GET_FIELD(regPtr[1], 0, 8);
    portMacAddr.bytes[2] = SMEM_U32_GET_FIELD(regPtr[1], 8, 8);
    portMacAddr.bytes[1] = SMEM_U32_GET_FIELD(regPtr[1], 16, 8);
    portMacAddr.bytes[0] = SMEM_U32_GET_FIELD(regPtr[1], 24, 8);

    if(descrPtr->ingressGopPortNumber >= SKERNEL_DEV_MAX_SUPPORTED_PORTS_CNS)
    {
        skernelFatalError("snetChtClassifyFlowControlPacket: invalid MAC number [%d] \n",
            descrPtr->ingressGopPortNumber);
    }

    if(IS_CHT_HYPER_GIGA_PORT(devObjPtr,descrPtr->ingressGopPortNumber))
    {
        /* XG port */
        regAddr = SMEM_CHT_MAC_CONTROL2_REG(devObjPtr, descrPtr->ingressGopPortNumber);
        regPtr = smemMemGet(devObjPtr, regAddr);

        fldValue = SMEM_U32_GET_FIELD(regPtr[0], 0, 8);
    }
    else
    {
        /* Gig port */
        regAddr = SMEM_CHT_MAC_CONTROL_REG(devObjPtr, descrPtr->ingressGopPortNumber);
        regPtr = smemMemGet(devObjPtr, regAddr);

        fldValue = SMEM_U32_GET_FIELD(regPtr[0], 7, 8);
    }

    portMacAddr.bytes[5] = fldValue;

    /* Packets MAC DA is 01-80-C2-00-00-01 or the ports configured MAC Address */
    isFcMac = ( (SGT_MAC_ADDR_IS_PAUSE(descrPtr->macDaPtr)) ||
                (SGT_MAC_ADDR_ARE_EQUAL(descrPtr->macDaPtr, portMacAddr.bytes)) );

    if (isFcMac)
    {
        /* Flow Control OpCode */
        opCode = (descrPtr->startFramePtr[14] << 8) | descrPtr->startFramePtr[15];
        __LOG_PARAM_WITH_NAME("Flow Control OpCode : ",opCode);
        if (opCode == SNET_CHT_FC_OPCODE)
        {
            __LOG(("recognized Flow control packet (FC) \n"));
            return SNET_FC_PACKET_E;
        }
        if (opCode == SNET_CHT_PFC_OPCODE)
        {
            __LOG(("recognized Priority Flow control packet (PFC) \n"));
            return SNET_PFC_PACKET_E;
        }
    }

    __LOG(("unknown Flow control packet (ethertype of 'FC' but mac DA not match standard and not match 'the FC mac of port') \n"));
    return SNET_UNKNOWN_FC_PACKET_E;
}

/*******************************************************************************
*   snetChtDoForwardFcFrame
*
* DESCRIPTION:
*       Forward (to ingress pipe) or terminate Flow Control frame.
*       Some of FC packet types must be terminated, depend on configuration
*       Not FC packets are always forwarded
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - frame data buffer Id
*
* OUTPUTS:
*       fcPacketTypePtr - (pointer to) FC packet type classification.
*
* RETURN:
*     GT_TRUE - continue packet processing
*     GT_FALSE - terminate packet processing
*******************************************************************************/
static GT_BOOL snetChtDoForwardFcFrame
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    OUT SNET_FLOW_CONTROL_PACKET_TYPE_ENT   *fcPacketTypePtr
)
{
    GT_U32      regAddress; /* register address */
    GT_U32      fldValue;
    GT_BOOL     forward;    /* GT_TRUE - continue pkt processing;  GT_FALSE - terminate */

    *fcPacketTypePtr = snetChtClassifyFlowControlPacket(devObjPtr, descrPtr);

    if(descrPtr->ingressGopPortNumber >= SKERNEL_DEV_MAX_SUPPORTED_PORTS_CNS)
    {
        skernelFatalError("snetChtDoForwardFcFrame: invalid MAC number [%d] \n",
            descrPtr->ingressGopPortNumber);
    }

    switch (*fcPacketTypePtr)
    {
        case SNET_FC_PACKET_E:
            forward = GT_FALSE;
            if (devObjPtr->supportForwardFcPackets)
            {
                regAddress =
                    SMEM_CHT3_PORT_SERIAL_PARAMETERS_REG(devObjPtr, descrPtr->ingressGopPortNumber);
                    smemRegFldGet(devObjPtr, regAddress, 3, 1, &fldValue);
                    /* forwardFcEnable */
                    forward = fldValue ? GT_TRUE : GT_FALSE;
            }
            break;
        case SNET_UNKNOWN_FC_PACKET_E:
            forward = GT_TRUE; /* ch3 forward such packets */
            if (devObjPtr->supportForwardUnknowMacControlFrames &&
                (descrPtr->ingressGopPortNumber != SNET_CHT_CPU_PORT_CNS))
            {
                regAddress =
                    SMEM_XCAT2_PORT_SERIAL_PARAMS1_REG(devObjPtr, descrPtr->ingressGopPortNumber);
                smemRegFldGet(devObjPtr, regAddress, 2, 1, &fldValue);
                /* forwardUnknownMacControlFramesEnable */
                forward = fldValue ? GT_TRUE : GT_FALSE;
            }
            break;
        case SNET_PFC_PACKET_E:
            forward = GT_TRUE; /* ch3 forward such packets */
            if (devObjPtr->supportForwardPfcFrames &&
                (descrPtr->ingressGopPortNumber != SNET_CHT_CPU_PORT_CNS))
            {
                regAddress =
                    SMEM_XCAT2_PORT_SERIAL_PARAMS1_REG(devObjPtr, descrPtr->ingressGopPortNumber);
                smemRegFldGet(devObjPtr, regAddress, 1, 1, &fldValue);
                /* forwardPfcFramesEnable */
                forward = fldValue ? GT_TRUE : GT_FALSE;
            }
            break;
        default:
            forward = GT_TRUE;  /* forward non Flow-control packets */
            break;
    }
    return forward;
}

/*******************************************************************************
*   snetCht1SoftReset
*
* DESCRIPTION:
*       Soft reset of Cheetah device object for devices : ch1,2,3,xCat,Lion
*
* INPUTS:
*       devObjPtr - pointer to device object.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       new device object that replaces the one that soft reset
* COMMENTS:
*       Function do soft reset on the following order:
*           - force link of all active SLANs down
*           - disable device interrupts
*           - unbind SCIB interface
*           - disable SAGING task
*           - reset all AISC memories
*           - enable SAGING task
*           - re-bind SCIB interface
*           - enable device interrupts
*           - force link of all active SLANs up
*
*******************************************************************************/
static SKERNEL_DEVICE_OBJECT *  snetCht1SoftReset
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    GT_U32  * regPtr;       /* register pointer */

    /* Get Global Configuration register */
    regPtr = smemMemGet(devObjPtr, SMEM_CHT_GLB_CTRL_REG(devObjPtr));

    /* NOTE: see function smemChtActiveWriteGlobalReg(...) with preparations before
        this function like scibUnBindDevice(...) */


    /* Force link DOWN of all active SLANs */
    skernelForceLinkDownOrLinkUpOnAllPorts(devObjPtr,GT_FALSE);

    SIM_OS_MAC(simOsSleep)(200);

    SHOSTG_interrupt_disable_one(devObjPtr->interruptLine + 1);

    /* Reset device memory */
    smemChtMemReset(devObjPtr);

    /* Cheetah 3 and above(PEX devices) support the option to unbind/bind SCIB interface */
    if(SKERNEL_IS_CHEETAH3_DEV(devObjPtr))
    {
        /* Rebind SCIB interface */
        scibReBindDevice(devObjPtr->deviceId);
    }

    SHOSTG_interrupt_enable_one(devObjPtr->interruptLine + 1);

    /* Force link UP of all active SLANs  */
    skernelForceLinkDownOrLinkUpOnAllPorts(devObjPtr,GT_TRUE);

    /* Set initStage to DEV_INIT_DONE */
    smemChtInitStateSet(devObjPtr);

    /* Clear Soft Reset Trigger */
    snetFieldValueSet(regPtr, 16, 1, 0);

    SIM_OS_MAC(simOsSleep)(200);

    /* we keep orig device and not replace with new device */
    return devObjPtr;
}

/*******************************************************************************
*   snetChtXcat2SoftReset
*
* DESCRIPTION:
*       Soft reset of Cheetah device object for devices : xcat2,lion2
*
* INPUTS:
*       devObjPtr - pointer to device object.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       new device object that replaces the one that soft reset
* COMMENTS:
*       Function do soft reset on the following order:
*           - force link of all active SLANs down
*           - disable device interrupts
*           - unbind SCIB interface
*           - disable SAGING task
*           - reset all AISC memories
*           - enable SAGING task
*           - re-bind SCIB interface
*           - enable device interrupts
*           - force link of all active SLANs up
*
*******************************************************************************/
static SKERNEL_DEVICE_OBJECT * snetChtXcat2SoftReset
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    /* xcat2,lion2--> DFX server not via SMEM_CHT_GLB_CTRL_REG()
        need to use SMEM_LION2_DFX_SERVER_RESET_CONTROL_REG()


        and there is no active memory on this register
    */
    /* not implemented */
    return devObjPtr;
}

/*******************************************************************************
*   snetChtSoftReset
*
* DESCRIPTION:
*       Soft reset of Cheetah device object
*
* INPUTS:
*       devObjPtr - pointer to device object.
*
* OUTPUTS:
*       None.
*
* RETURNS:
*       new device object that replaces the one that soft reset
* COMMENTS:
*       Function do soft reset on the following order:
*           - force link of all active SLANs down
*           - disable device interrupts
*           - unbind SCIB interface
*           - disable SAGING task
*           - reset all AISC memories
*           - enable SAGING task
*           - re-bind SCIB interface
*           - enable device interrupts
*           - force link of all active SLANs up
*
*******************************************************************************/
static SKERNEL_DEVICE_OBJECT *  snetChtSoftReset
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr
)
{
    if(SMEM_CHT_IS_SIP5_GET(devObjPtr))/* sip5--> DFX server */
    {
        skernelFatalError("snetChtSoftReset: should not get here see function skernelDeviceSoftResetGeneric(...) \n");
        return NULL;
    }
    else
    if (SKERNEL_IS_XCAT2_DEV(devObjPtr))/* xcat2,lion2--> DFX server */
    {
        return snetChtXcat2SoftReset(devObjPtr);
    }
    else
    {
        return snetCht1SoftReset(devObjPtr);
    }

}

/*******************************************************************************
*   parsingTrillInnerFrame
*
* DESCRIPTION:
*        L2,3,QOS Parsing for 'Inner frame' of TRILL. need to be done regardless
*        to tunnel termination.
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to the descriptor of the !!! Inner frame !!!
*       internalTtiInfoPtr -  pointer to internal TTI info
*
* RETURN:
*
*******************************************************************************/
static GT_VOID parsingTrillInnerFrame
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN INTERNAL_TTI_DESC_INFO_STC        * internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(parsingTrillInnerFrame);

    /* update the length of the inner packet */
    descrPtr->byteCount -=
        (descrPtr->ingressTunnelInfo.innerMacDaPtr - /* start of the inner packet */
         descrPtr->startFramePtr);           /* start of the outer packet */

    /* update the start of the inner packet */
    descrPtr->startFramePtr = descrPtr->ingressTunnelInfo.innerMacDaPtr;
    /* reset the L3 pointer , because it is not relevant any more -->
               will be set inside snetChtL2Parsing(...) for the inner packet */
    descrPtr->l3StartOffsetPtr = NULL;
    descrPtr->macDaPtr = descrPtr->startFramePtr;
    descrPtr->macSaPtr = descrPtr->startFramePtr + SGT_MAC_ADDR_BYTES;

    /* Fill MAC data type of descriptor */
    __LOG(("Fill MAC data type of descriptor"));
    if (SGT_MAC_ADDR_IS_MCST(descrPtr->macDaPtr))
    {
        if (SGT_MAC_ADDR_IS_BCST(descrPtr->macDaPtr))
        {
            descrPtr->macDaType = SKERNEL_BROADCAST_MAC_E;
        }
        else
        {
            descrPtr->macDaType = SKERNEL_MULTICAST_MAC_E;
        }
    }
    else
    {
        descrPtr->macDaType = SKERNEL_UNICAST_MAC_E;
    }

    /* do L2 parsing (vlan tag , ethertype , nested vlan , encapsulation) */
    snetChtL2Parsing(devObjPtr, descrPtr,SNET_CHT_FRAME_PARSE_MODE_TRILL_E,internalTtiInfoPtr);

    if(descrPtr->l3StartOffsetPtr == NULL)
    {
        /* function snetChtL2Parsing should set descrPtr->l3StartOffsetPtr */

        /* fix for coverity warning "FORWARD_NULL" */
        skernelFatalError("parsingTrillInnerFrame: invalid table entry pointer\n");
    }

    /* L3, L4 protocols parsing */
    __LOG(("L3, L4 protocols parsing"));
    snetChtL3L4ProtParsing(devObjPtr, descrPtr, descrPtr->etherTypeOrSsapDsap, internalTtiInfoPtr);

    /* VLAN and QoS Profile Assign */
    __LOG(("VLAN and QoS Profile Assign"));
    snetChtVlanQosProfAssign(devObjPtr, descrPtr,
                             descrPtr->etherTypeOrSsapDsap,
                             descrPtr->l2Encaps,
                             NULL/*portVlanCfgEntryPtr*/);
}

/*******************************************************************************
*   snetChtParsingTrillInnerFrame
*
* DESCRIPTION:
*        L2,3,QOS Parsing for 'Inner frame' of TRILL. need to be done regardless
*        to tunnel termination.
*        the function will save the 'parsing descriptor' in descrPtr->ingressTunnelInfo.innerFrameDescrPtr
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to the descriptor of the original frame (outer frame)
*       internalTtiInfoPtr -  pointer to internal TTI info
*
* RETURN:
*
*******************************************************************************/
extern GT_VOID snetChtParsingTrillInnerFrame
(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN INTERNAL_TTI_DESC_INFO_STC        * internalTtiInfoPtr
)
{
    DECLARE_FUNC_NAME(snetChtParsingTrillInnerFrame);

    if(descrPtr->ingressTunnelInfo.innerPacketL2FieldsAreValid == 0)
    {
        /* can't parse the inner packet , because the parser can't reach all the
          fields due to long offset from the start of the packet */
        return;
    }

    /* duplicate the inner packet descriptor from the 'original' */
    __LOG(("duplicate the inner packet descriptor from the 'original'"));
    descrPtr->ingressTunnelInfo.innerFrameDescrPtr = snetChtEqDuplicateDescr(devObjPtr,descrPtr);

    /* start using the 'Inner frame' descriptor --> do parsing of the inner frame */
    __LOG(("start using the 'Inner frame' descriptor --> do parsing of the inner frame"));
    parsingTrillInnerFrame(devObjPtr,descrPtr->ingressTunnelInfo.innerFrameDescrPtr,internalTtiInfoPtr);
}

/*******************************************************************************
*   snetChtTimestampTagAndTimestampInfo
*
* DESCRIPTION:
*       Save TST and timestamp information.
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to the descriptor of the original frame (outer frame)
*       tstStartOffset -  offset to the start of the TST
*
* OUTPUTS:
*
* RETURNS:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtTimestampTagAndTimestampInfo(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    IN GT_U32 tstStartOffset
)
{
    GT_U32  internalOffset;

    if( (descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] ==
         SKERNEL_TIMESTAMP_TAG_TYPE_NON_EXTENDED_E) ||
        (descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] ==
         SKERNEL_TIMESTAMP_TAG_TYPE_EXTENDED_E) )
    {
        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].U =
            (descrPtr->startFramePtr[tstStartOffset + 2] & 0x01);

        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].T =
            (descrPtr->startFramePtr[tstStartOffset + 2] & 0x02);

        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].OffsetProfile =
            (descrPtr->startFramePtr[tstStartOffset + 3] & 0x7F);

        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].OE =
            (descrPtr->startFramePtr[tstStartOffset + 3] & 0x80);

        internalOffset = 4;
        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].timestamp.nanoSecondTimer =
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 0] << 24) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 1] << 16) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 2] <<  8) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 3] <<  0) ;

        if( descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] ==
            SKERNEL_TIMESTAMP_TAG_TYPE_EXTENDED_E )
        {
            internalOffset = 8;

            descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].timestamp.secondTimer.l[1] =
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 0] <<  8) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 1] <<  0) ;

            descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].timestamp.secondTimer.l[0] =
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 2] << 24) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 3] << 16) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 4] <<  8) |
                (descrPtr->startFramePtr[tstStartOffset + internalOffset + 5] <<  0) ;
        }
    }
    else if ( descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] ==
              SKERNEL_TIMESTAMP_TAG_TYPE_HYBRID_E)
    {
        internalOffset = 2;

        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].timestamp.secondTimer.l[1] =
            (descrPtr->startFramePtr[tstStartOffset + internalOffset + 0] <<  8) |
            (descrPtr->startFramePtr[tstStartOffset + internalOffset + 1] <<  0) ;
        descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].timestamp.secondTimer.l[0] =
            (descrPtr->startFramePtr[tstStartOffset + internalOffset + 2] << 24) |
            (descrPtr->startFramePtr[tstStartOffset + internalOffset + 3] << 16) |
            (descrPtr->startFramePtr[tstStartOffset + internalOffset + 4] <<  8) |
            (descrPtr->startFramePtr[tstStartOffset + internalOffset + 5] <<  0) ;
    }

    descrPtr->timestampTagInfo[SMAIN_DIRECTION_INGRESS_E].timestamp.fractionalNanoSecondTimer = 0;
}

/*******************************************************************************
*   snetChtTimestampTagDetection
*
* DESCRIPTION:
*       Identify the timestamp tag in the incoming packet.
*
* INPUTS:
*       devObjPtr    - pointer to device object.
*       descrPtr     - pointer to the descriptor of the original frame (outer frame)
*       ethTypeOffsetPtr -  pointer to start of the timestamp tag (if exists)
*
* OUTPUTS:
*
* RETURNS:
*
* COMMENTS:
*
*******************************************************************************/
static GT_VOID snetChtTimestampTagDetection(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN SKERNEL_FRAME_CHEETAH_DESCR_STC * descrPtr,
    INOUT GT_U32 * ethTypeOffsetPtr
)
{
    DECLARE_FUNC_NAME(snetChtTimestampTagDetection);

    GT_U32 etherType;              /* real frame ethernet type */
    GT_U32 regAddress;             /* register addres  */
    GT_U32 *memoryPtr;             /* pointer to memory */
    GT_U32 tstEtherType;           /* ethertype of the Timestamp Tag */
    GT_U32 hybridTstEtherType;     /* ethertype of the Hybrid Timestamp Tag */
    GT_U32 tstStartOffset;         /* offset to the start of the TST is exists */

    /* Real ethernet type */
    etherType =
        SNET_GET_PCKT_TAG_ETHER_TYPE_MAC(descrPtr, *ethTypeOffsetPtr);
    __LOG_PARAM(etherType);

    regAddress = SMEM_LION3_TTI_PTP_TS_ETHERTYPES_REG(devObjPtr);
    memoryPtr = smemMemGet(devObjPtr, regAddress);
    tstEtherType = SMEM_U32_GET_FIELD(*memoryPtr, 0,  16);
    hybridTstEtherType = SMEM_U32_GET_FIELD(*memoryPtr, 16, 16);

    regAddress = SMEM_LION3_TTI_PTP_TS_CONFIG_REG(devObjPtr);
    memoryPtr = smemMemGet(devObjPtr, regAddress);

    tstStartOffset = *ethTypeOffsetPtr;

    if( (SMEM_U32_GET_FIELD(*memoryPtr, 0, 1)) && (etherType == tstEtherType) )
    {
        /* TS Tag Parsing */
        if( (descrPtr->startFramePtr[*ethTypeOffsetPtr + 2] & 0x80) == 0 )
        {
            descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] =
                SKERNEL_TIMESTAMP_TAG_TYPE_NON_EXTENDED_E;
            *ethTypeOffsetPtr += 8;
        }
        else
        {
            descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] =
                SKERNEL_TIMESTAMP_TAG_TYPE_EXTENDED_E;
            *ethTypeOffsetPtr += 16;
        }
    }
    else if( (SMEM_U32_GET_FIELD(*memoryPtr, 1, 1)) && (etherType == hybridTstEtherType) )
    {
        /* Hybrid TST Parsing */
        descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] =
            SKERNEL_TIMESTAMP_TAG_TYPE_HYBRID_E;
        *ethTypeOffsetPtr += 8;
    }
    else
    {
        descrPtr->timestampTagged[SMAIN_DIRECTION_INGRESS_E] =
            SKERNEL_TIMESTAMP_TAG_TYPE_UNTAGGED_E;
    }

    snetChtTimestampTagAndTimestampInfo(devObjPtr, descrPtr, tstStartOffset);
}

/*******************************************************************************
* localTablesFormatInit
*
* DESCRIPTION:
*        init the format of local tables.
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*
* OUTPUTS:
*       None.
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
static void localTablesFormatInit(
    IN SKERNEL_DEVICE_OBJECT            * devObjPtr
)
{


    if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_TTI_PHYSICAL_PORT_ATTRIBUTE_E,
            sip5_20TtiPhysicalPortTableFieldsFormat, bobcat2B0TtiPhysicalPortTableFieldsNames);
    }
    else
    if(SMEM_CHT_IS_SIP5_10_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_TTI_PHYSICAL_PORT_ATTRIBUTE_E,
            bobcat2B0TtiPhysicalPortTableFieldsFormat, bobcat2B0TtiPhysicalPortTableFieldsNames);
    }
    else
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_TTI_PHYSICAL_PORT_ATTRIBUTE_E,
            lion3TtiPhysicalPortTableFieldsFormat, lion3TtiPhysicalPortFieldsTableNames);
    }

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_TTI_DEFAULT_EPORT_E,
        lion3TtiDefaultEPortTableFieldsFormat, lion3TtiDefaultEPortFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_VLAN_PORT_PROTOCOL_E,
        lion3TtiDefaultPortProtocolEvlanAndQosConfigurationTableFieldsFormat, lion3TtiDefaultPortProtocolEvlanAndQosConfigurationFieldsTableNames);

    LION3_TABLES_FORMAT_INIT_MAC(
        devObjPtr, SKERNEL_TABLE_FORMAT_TTI_EPORT_ATTRIBUTES_E,
        lion3TtiEPortAttributesTableFieldsFormat, lion3TtiEPortAttributesFieldsTableNames);

    if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(devObjPtr, SKERNEL_TABLE_FORMAT_L2_MLL_E,
            sip5_20L2MllTableFieldsFormat, lion3L2MllFieldsTableNames);


        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_IP_MLL_E,
            sip5_20IpMllTableFieldsFormat, lion3IpMllFieldsTableNames);
    }
    else
    {
        LION3_TABLES_FORMAT_INIT_MAC(devObjPtr, SKERNEL_TABLE_FORMAT_L2_MLL_E,
            lion3L2MllTableFieldsFormat, lion3L2MllFieldsTableNames);

        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_IP_MLL_E,
            lion3IpMllTableFieldsFormat, lion3IpMllFieldsTableNames);
    }


    if(SMEM_CHT_IS_SIP5_20_GET(devObjPtr))
    {
        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_TTI_PHYSICAL_PORT_2_ATTRIBUTE_E,
            sip5_20TtiPhysicalPort2TableFieldsFormat, sip5_20TtiPhysicalPort2TableFieldsNames);

        LION3_TABLES_FORMAT_INIT_MAC(
            devObjPtr, SKERNEL_TABLE_FORMAT_EGF_QAG_PORT_TARGET_ATTRIBUTES_E,
            sip5_20EgfQagPortTargetAttributesTableFieldsFormat, sip5_20EgfQagPortTargetAttributesTableFieldsNames);
    }

}

/*******************************************************************************
* snetIngressTablesFormatInit
*
* DESCRIPTION:
*        init the format of ingress tables.
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*
* OUTPUTS:
*       None.
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
void snetIngressTablesFormatInit(
    IN SKERNEL_DEVICE_OBJECT            * devObjPtr
)
{
    GT_U32 ii;

    /* init local tables */
    localTablesFormatInit(devObjPtr);
    /* init TTI tables */
    snetTtiTablesFormatInit(devObjPtr);
    /* init PCL tables */
    snetPclTablesFormatInit(devObjPtr);
    /* init L2i tables */
    snetL2iTablesFormatInit(devObjPtr);
    /* init EQ tables */
    snetEqTablesFormatInit(devObjPtr);
    /* init PLR tables */
    snetPlrTablesFormatInit(devObjPtr);
    /* init HA tables */
    snetHaTablesFormatInit(devObjPtr);
    /* init IPvx tables */
    snetIpvxTablesFormatInit(devObjPtr);

    for(ii = 0; ii < SKERNEL_TABLE_FORMAT_LAST_E; ii++)
    {
        if(devObjPtr->tableFormatInfo[ii].fieldsInfoPtr)
        {
            snetFillFieldsStartBitInfo(devObjPtr,
                devObjPtr->tableFormatInfo[ii].formatNamePtr,
                devObjPtr->tableFormatInfo[ii].numFields,
                devObjPtr->tableFormatInfo[ii].fieldsInfoPtr,
                devObjPtr->tableFormatInfo[ii].fieldsNamePtr);
        }
    }

    return;
}

/*******************************************************************************
*   snetLion3PassengerOuterTagIsTag0_1
*
* DESCRIPTION:
*        set innerTag0Exists,innerPacketTag0Vid,innerPacketTag0CfiDei,innerPacketTag0Up fields in descriptor
*
* INPUTS:
*        deviceObj  - pointer to device object.
*        descrPtr   - pointer to the frame's descriptor.
* OUTPUTS:
*        descrPtr   - pointer to the frame's descriptor.
*
*******************************************************************************/
void  snetLion3PassengerOuterTagIsTag0_1(
    IN    SKERNEL_DEVICE_OBJECT           *devObjPtr,
    INOUT SKERNEL_FRAME_CHEETAH_DESCR_STC *descrPtr
)
{
    DECLARE_FUNC_NAME(snetLion3PassengerOuterTagIsTag0_1);

    /* ttiPassengerOuterTagIsTag0_1 - need to swap tag0 and tag 1 recognitions */
    if((descrPtr->eArchExtInfo.ttiPreTtiLookupIngressEPortTablePtr)&&
       (SMEM_LION3_TTI_DEFAULT_EPORT_ENTRY_FIELD_GET(devObjPtr, descrPtr,
        SMEM_LION3_TTI_DEFAULT_E_PORT_TABLE_FIELDS_TTI_802_1AH_PASSENGER_STAG_IS_TAG0_1)))
    {
        __LOG(("ttiPassengerOuterTagIsTag0_1 --> check if tag 1 is the outer tag (of passenger) \n"));
        descrPtr->ingressTunnelInfo.innerTag0Exists = (descrPtr->ingressTunnelInfo.innerFrameDescrPtr->ingressVlanTag1Type ==
                SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E) ?
            1 : 0;
        if(descrPtr->ingressTunnelInfo.innerTag0Exists)
        {
            /* use values from TAG 1 */
            __LOG(("use values from TAG 1 (vid1,cfidei1,up1) \n"));
            descrPtr->ingressTunnelInfo.innerPacketTag0Vid = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->vid1;
            descrPtr->ingressTunnelInfo.innerPacketTag0CfiDei = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->cfidei1;
            descrPtr->ingressTunnelInfo.innerPacketTag0Up     = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->up1;
        }
        else
        {
            __LOG(("TAG 1 was not recognized as the outer tag (of passenger)\n"));
            if(descrPtr->ingressTunnelInfo.innerFrameDescrPtr->ingressVlanTag1Type == SKERNEL_FRAME_TR101_VLAN_TAG_INNER_E)
            {
                __LOG(("Note that tag 0 was recognized as 'outer' and tag 1 as 'inner' (of passenger)\n "));
            }
            else
            if(descrPtr->ingressTunnelInfo.innerFrameDescrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
            {
                __LOG(("Note that tag 0 was recognized as 'outer' and tag 1 NOT exists (of passenger)\n "));
            }
        }

    }
    else
    {
        __LOG(("ttiPassengerOuterTagIsTag0_1 --> check if tag 0 is the outer tag (of passenger) \n"));
        descrPtr->ingressTunnelInfo.innerTag0Exists = (descrPtr->ingressTunnelInfo.innerFrameDescrPtr->ingressVlanTag0Type ==
                SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E) ?
            1 : 0;
        if(descrPtr->ingressTunnelInfo.innerTag0Exists)
        {
            /* use values from TAG 0 */
            __LOG(("use values from TAG 0 (eVid,cfidei,up) \n"));
            descrPtr->ingressTunnelInfo.innerPacketTag0Vid = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->eVid;
            descrPtr->ingressTunnelInfo.innerPacketTag0CfiDei = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->cfidei;
            descrPtr->ingressTunnelInfo.innerPacketTag0Up     = descrPtr->ingressTunnelInfo.innerFrameDescrPtr->up;
        }
        else
        {
            __LOG(("TAG 0 was not recognized as the outer tag (of passenger)\n"));

            if(descrPtr->ingressTunnelInfo.innerFrameDescrPtr->ingressVlanTag0Type == SKERNEL_FRAME_TR101_VLAN_TAG_INNER_E)
            {
                __LOG(("Note that tag 1 was recognized as 'outer' and tag 0 as 'inner' (of passenger)\n "));
            }
            else
            if(descrPtr->ingressTunnelInfo.innerFrameDescrPtr->ingressVlanTag1Type == SKERNEL_FRAME_TR101_VLAN_TAG_OUTER_E)
            {
                __LOG(("Note that tag 1 was recognized as 'outer' and tag 0 NOT exists (of passenger)\n "));
            }
        }
    }


    __LOG_PARAM(descrPtr->ingressTunnelInfo.innerPacketTag0Vid);
    __LOG_PARAM(descrPtr->ingressTunnelInfo.innerPacketTag0Up);
    __LOG_PARAM(descrPtr->ingressTunnelInfo.innerPacketTag0CfiDei);
    __LOG_PARAM(descrPtr->ingressTunnelInfo.innerTag0Exists);

}


#if 0
/*******************************************************************************
* sdmaTxPacketGeneratorConfigSet_test
*
* DESCRIPTION:
*        init the format of ingress tables.
*
* INPUTS:
*       devObjPtr       - pointer to device object.
*       txQue           - SDMA TxQ number
*       firstDmaAddr    - first SDMA descriptor used to close descriptor ring
*       lastDmaAddr     - last SDMA descriptor used to close descriptor ring
*
* OUTPUTS:
*       None.
*
* RETURN:
*
* COMMENTS:
*
*
*******************************************************************************/
GT_VOID sdmaTxPacketGeneratorConfigSet_test
(
IN SKERNEL_DEVICE_OBJECT * devObjPtr,
IN GT_U32 txQue,
IN GT_U32 firstDmaAddr,
IN GT_U32 lastDmaAddr
)
{
    SNET_STRUCT_TX_DESC * txDescPtr;
    SNET_STRUCT_TX_DESC txDesc;                 /* buffer for TX descriptor */
    GT_U32 currentDmaAddr = firstDmaAddr;
    GT_U32 regVal;

    txDescPtr = &txDesc;

    /* Start read from first descriptor in chain */
    smemRegSet(devObjPtr,
               SMEM_CHT_TX_SDMA_CUR_DESC_PTR0_REG(devObjPtr) + (txQue * 0x4),
               currentDmaAddr);

    /* read the DMA for needed value , put data into txDescPtr */
    snetChtPerformScibDmaRead(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                              devObjPtr->deviceId, currentDmaAddr,
                              NUM_BYTES_TO_WORDS(sizeof(*txDescPtr)),
                              (GT_U32*)txDescPtr,SCIB_DMA_WORDS);

    while(currentDmaAddr != lastDmaAddr)
    {

        /* Set ownership on descr to SDMA */
        TX_DESC_SET_OWN_BIT(txDescPtr, TX_DESC_DMA_OWN);

        /* Write DMA memory new descriptor */
        snetChtPerformScibDmaWrite(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                                   devObjPtr->deviceId, currentDmaAddr,
                                   NUM_BYTES_TO_WORDS(sizeof(*txDescPtr)),
                                   (GT_U32*)txDescPtr, SCIB_DMA_WORDS);

        currentDmaAddr = txDescPtr->nextDescPointer;

        /* Update next descriptor to feed */
        smemRegSet(devObjPtr,
                   SMEM_CHT_TX_SDMA_CUR_DESC_PTR0_REG(devObjPtr) + (txQue * 0x4),
                   currentDmaAddr);

        /* Read the DMA for needed value, put data into txDescPtr */
        snetChtPerformScibDmaRead(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                                  devObjPtr->deviceId, currentDmaAddr,
                                  NUM_BYTES_TO_WORDS(sizeof(*txDescPtr)),
                                  (GT_U32*)txDescPtr, SCIB_DMA_WORDS);
    }

    /* Set ownership on descr to SDMA */
    TX_DESC_SET_OWN_BIT(txDescPtr, TX_DESC_DMA_OWN);
    /* Last descriptor in chain */
    TX_DESC_SET_LAST_BIT(txDescPtr, 1);
    /* Close descriptors ring */
    txDescPtr->nextDescPointer = firstDmaAddr;

    /* Write DMA memory last descriptor */
    snetChtPerformScibDmaWrite(SNET_CHT_DMA_CLIENT_PACKET_FROM_CPU_E,
                               devObjPtr->deviceId, lastDmaAddr,
                               NUM_BYTES_TO_WORDS(sizeof(*txDescPtr)),
                               (GT_U32*)txDescPtr, SCIB_DMA_WORDS);

    /* Set descriptor pointer to first one */
    smemRegSet(devObjPtr,
               SMEM_CHT_TX_SDMA_CUR_DESC_PTR0_REG(devObjPtr) + (txQue * 0x4),
               firstDmaAddr);

    /* Enable packet generator, enable packet interval counter max value */
    regVal = 0xffffffff;

    /* Tx SDMA Packet Generator Config Queue */
    scibWriteMemory(devObjPtr->deviceId,
                    SMEM_CHT_PACKET_GENERATOR_CONFIG_QUEUE_REG(devObjPtr, txQue),
                    1, &regVal);

    scibReadMemory(devObjPtr->deviceId, 0x00002868, 1, &regVal);

    /* Disable the Tx SDMA queue  */
    SMEM_U32_SET_FIELD(regVal, txQue, 1, 0);

    /* Transmit SDMA Fixed Priority Configuration Register */
    smemRegFldSet(devObjPtr, 0x00002870, txQue, 1, 1);

    /* Enable the Tx SDMA queue  */
    SMEM_U32_SET_FIELD(regVal, txQue, 1, 1);

    scibWriteMemory(devObjPtr->deviceId, 0x00002868, 1, &regVal);
}
#endif
/*******************************************************************************
*   snetBobcat2EeeProcess
*
* DESCRIPTION:
*       process EEE
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       macPort             - the mac port number.
*       direction           - ingress egress direction
*
*******************************************************************************/
void snetBobcat2EeeProcess(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                   macPort,
    IN SMAIN_DIRECTION_ENT      direction
)
{
    DECLARE_FUNC_NAME(snetBobcat2EeeProcess);
    GT_BIT enable;

    if (! SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        __LOG(("EEE not implemented by simulation on this device \n"));
        return;
    }

    if(IS_CHT_HYPER_GIGA_PORT(devObjPtr, macPort))
    {
        __LOG(("port [%d] is not in GE mode : EEE only on GE ports 10/100/1000 \n",macPort));
        return;
    }

    /* check if the EEE enabled on the port */
    /*<LPI request enable>*/
    smemRegFldGet(devObjPtr,
        SMEM_SIP_5_MAC_LPI_CTRL_REG(devObjPtr,macPort,1),
        0,1,&enable);

    if (enable == 0)
    {
        __LOG(("EEE is not enabled on the port[%d] \n",macPort));
        return;
    }

    /* make atomic action */
    scibAccessLock();

    if (direction == SMAIN_DIRECTION_INGRESS_E)
    {
        __LOG(("EEE is enabled on the port[%d] , generate Rx direction interrupts (PCS,MAC) \n",macPort));
        /* <PCS Rx Path Received LPI> */
        smemBobcat2DoPortInterrupt(devObjPtr,macPort,11);
        /* <MAC Rx Path Received LPI> */
        smemBobcat2DoPortInterrupt(devObjPtr,macPort,13);
    }
    else
    {
        __LOG(("EEE is enabled on the port[%d] , generate Tx direction interrupt (PCS) \n",macPort));
        /* <PCS Tx Path Received LPI> */
        smemBobcat2DoPortInterrupt(devObjPtr,macPort,12);
    }

    /* release the action */
    scibAccessUnlock();

    /* NOTE: due to Erratum the counter is not incremented ..
       and there is no intention to fix it */

}
/*******************************************************************************
*   snetBobcat2EeeCheckInterrupts
*
* DESCRIPTION:
*       check for EEE interrupts
*
* INPUTS:
*       devObjPtr           - pointer to device object.
*       macPort             - the mac port number.
*
*******************************************************************************/
void snetBobcat2EeeCheckInterrupts(
    IN SKERNEL_DEVICE_OBJECT * devObjPtr,
    IN GT_U32                   macPort
)
{
    DECLARE_FUNC_NAME(snetBobcat2EeeCheckInterrupts);
    GT_BIT fldValue;

    if (! SMEM_CHT_IS_SIP5_GET(devObjPtr))
    {
        __LOG(("EEE not implemented by simulation on this device \n"));
        return;
    }

    if(IS_CHT_HYPER_GIGA_PORT(devObjPtr, macPort))
    {
        __LOG(("port [%d] is not in GE mode : EEE only on GE ports 10/100/1000 \n",macPort));
        return;
    }

    /*<LinkUp>*/
    smemRegFldGet(devObjPtr,
        SMEM_CHT_PORT_STATUS0_REG(devObjPtr, macPort),
        0, 1, &fldValue);
    if (fldValue != 1)
    {
        /* link is down */
        return;
    }

    /* check if the EEE enabled on the port */
    /*<LPI request enable>*/
    smemRegFldGet(devObjPtr,
        SMEM_SIP_5_MAC_LPI_CTRL_REG(devObjPtr,macPort,1),
        0,1,&fldValue);

    if (fldValue == 0)
    {
        __LOG(("EEE is not enabled on the port[%d] \n",macPort));
        return;
    }

    /*portInLoopBack*/
    smemRegFldGet(devObjPtr,
        SMEM_CHT_MAC_CONTROL_REG(devObjPtr, macPort),
        5, 2, &fldValue);

    /* make atomic action */
    scibAccessLock();

    __LOG(("EEE is enabled on the port[%d] , generate Tx direction interrupt (PCS) \n",macPort));
    /* <PCS Tx Path Received LPI> */
    smemBobcat2DoPortInterrupt(devObjPtr,macPort,12);

    if(fldValue)
    {
        __LOG(("EEE is enabled on the port[%d] in loopback mode , generate Rx direction interrupts (PCS,MAC) \n",macPort));
        /* <PCS Rx Path Received LPI> */
        smemBobcat2DoPortInterrupt(devObjPtr,macPort,11);
        /* <MAC Rx Path Received LPI> */
        smemBobcat2DoPortInterrupt(devObjPtr,macPort,13);
    }

    /* release the action */
    scibAccessUnlock();

    /* NOTE: due to Erratum the counter is not incremented ..
       and there is no intention to fix it */

}

